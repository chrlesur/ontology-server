[
  {
    "name": "main.go",
    "content": "package main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/api\"\r\n\t\"github.com/chrlesur/ontology-server/internal/config\"\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-contrib/cors\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc main() {\r\n\t// Load configuration\r\n\tcfg, err := config.LoadConfig(\"config.yaml\")\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Failed to load configuration: %v\", err)\r\n\t}\r\n\r\n\t// Initialize logger\r\n\tlogLevel := logger.INFO // You might want to parse this from the config\r\n\tl, err := logger.NewLogger(logLevel, cfg.Logging.Directory)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Failed to initialize logger: %v\", err)\r\n\t}\r\n\r\n\t// Set Gin mode based on config\r\n\tif cfg.Server.Mode == \"release\" {\r\n\t\tgin.SetMode(gin.ReleaseMode)\r\n\t} else {\r\n\t\tgin.SetMode(gin.DebugMode)\r\n\t}\r\n\r\n\t// Initialize Gin router\r\n\trouter := gin.New()\r\n\r\n\t// Use Gin's logger and recovery middleware\r\n\trouter.Use(gin.Logger())\r\n\trouter.Use(gin.Recovery())\r\n\r\n\t// Initialize storage\r\n\tmemoryStorage := storage.NewMemoryStorage()\r\n\r\n\t// Setup API routes\r\n\tapiGroup := router.Group(\"/api\")\r\n\tapi.SetupRoutes(apiGroup, memoryStorage, l)\r\n\r\n\t// Serve static files\r\n\trouter.NoRoute(gin.WrapH(http.FileServer(http.Dir(\"./web\"))))\r\n\r\n\t// Dans votre fonction main ou de configuration du routeur\r\n\trouter.Use(cors.Default())\r\n\r\n\t// Prepare HTTP server\r\n\taddr := fmt.Sprintf(\"%s:%d\", cfg.Server.Host, cfg.Server.Port)\r\n\tl.Info(fmt.Sprintf(\"Server listening on %s\", addr))\r\n\r\n\t// Start the server\r\n\terr = router.Run(addr)\r\n\tif err != nil {\r\n\t\tl.Error(fmt.Sprintf(\"Server failed to start: %v\", err))\r\n\t}\r\n}\r\n",
    "size": 1687,
    "modTime": "2024-10-26T20:48:42.8559155+02:00",
    "path": "cmd\\server\\main.go"
  },
  {
    "name": "config.yaml",
    "content": "server:\r\n  port: 8080\r\n  host: localhost\r\n  mode: debug  # Peut être \"debug\" ou \"release\"\r\nlogging:\r\n  level: info\r\n  directory: ./logs\r\nstorage:\r\n  temp_directory: ./temp",
    "size": 172,
    "modTime": "2024-10-26T20:18:57.7028616+02:00",
    "path": "config.yaml"
  },
  {
    "name": "errors.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n)\r\n\r\n// APIError représente une erreur de l'API\r\ntype APIError struct {\r\n\tCode    int    `json:\"code\"`\r\n\tMessage string `json:\"message\"`\r\n}\r\n\r\nfunc (e APIError) Error() string {\r\n\treturn fmt.Sprintf(\"API Error %d: %s\", e.Code, e.Message)\r\n}\r\n\r\n// Constantes pour les codes d'erreur\r\nconst (\r\n\tErrBadRequest          = 400\r\n\tErrNotFound            = 404\r\n\tErrInternalServerError = 500\r\n)\r\n\r\n// Constantes pour les messages d'erreur communs\r\nconst (\r\n\tMsgInvalidInput        = \"Invalid input provided\"\r\n\tMsgResourceNotFound    = \"Requested resource not found\"\r\n\tMsgInternalServerError = \"An internal server error occurred\"\r\n)\r\n\r\n// NewAPIError crée une nouvelle instance de APIError\r\nfunc NewAPIError(code int, message string) APIError {\r\n\treturn APIError{Code: code, Message: message}\r\n}\r\n\r\n// WriteJSONError écrit une réponse d'erreur JSON\r\nfunc WriteJSONError(w http.ResponseWriter, err APIError) {\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tw.WriteHeader(err.Code)\r\n\tjson.NewEncoder(w).Encode(err)\r\n}\r\n",
    "size": 1084,
    "modTime": "2024-10-26T15:10:17.9357821+02:00",
    "path": "internal\\api\\errors.go"
  },
  {
    "name": "handlers.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\n// Handler encapsule les dépendances nécessaires pour gérer les requêtes API\r\ntype Handler struct {\r\n\tStorage *storage.MemoryStorage\r\n\tLogger  *logger.Logger\r\n\tSearch  *search.SearchEngine\r\n}\r\n\r\n// NewHandler crée une nouvelle instance de Handler avec le stockage, le logger et le moteur de recherche fournis\r\nfunc NewHandler(storage *storage.MemoryStorage, logger *logger.Logger, search *search.SearchEngine) *Handler {\r\n\treturn \u0026Handler{Storage: storage, Logger: logger, Search: search}\r\n}\r\n\r\n// GetOntology récupère une ontologie par son ID\r\nfunc (h *Handler) GetOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting ontology with ID: %s\", id))\r\n\r\n\tontology, err := h.Storage.GetOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting ontology: %v\", err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": MsgResourceNotFound})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology)\r\n}\r\n\r\n// AddOntology ajoute une nouvelle ontologie\r\nfunc (h *Handler) AddOntology(c *gin.Context) {\r\n\tvar ontology models.Ontology\r\n\tif err := c.ShouldBindJSON(\u0026ontology); err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": MsgInvalidInput})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Générer un ID unique\r\n\tontology.ID = fmt.Sprintf(\"onto_%d\", time.Now().UnixNano())\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Adding new ontology: %s with ID: %s\", ontology.Name, ontology.ID))\r\n\r\n\terr := h.Storage.AddOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error adding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusCreated, ontology)\r\n}\r\n\r\n// UpdateOntology met à jour une ontologie existante\r\nfunc (h *Handler) UpdateOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\tvar ontology models.Ontology\r\n\tif err := c.ShouldBindJSON(\u0026ontology); err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": MsgInvalidInput})\r\n\t\treturn\r\n\t}\r\n\r\n\tontology.ID = id\r\n\th.Logger.Info(fmt.Sprintf(\"Updating ontology: %s\", id))\r\n\r\n\terr := h.Storage.UpdateOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error updating ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology)\r\n}\r\n\r\n// DeleteOntology supprime une ontologie par son ID\r\nfunc (h *Handler) DeleteOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Deleting ontology: %s\", id))\r\n\r\n\terr := h.Storage.DeleteOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error deleting ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.Status(http.StatusNoContent)\r\n}\r\n\r\n// ListOntologies récupère la liste de toutes les ontologies\r\nfunc (h *Handler) ListOntologies(c *gin.Context) {\r\n\th.Logger.Info(\"Listing all ontologies\")\r\n\r\n\tontologies := h.Storage.ListOntologies()\r\n\r\n\t// Créer une structure pour l'affichage\r\n\ttype OntologyInfo struct {\r\n\t\tID           string `json:\"id\"`\r\n\t\tName         string `json:\"name\"`\r\n\t\tElementCount int    `json:\"elementCount\"`\r\n\t\tContextCount int    `json:\"contextCount\"`\r\n\t}\r\n\r\n\tvar ontologyInfos []OntologyInfo\r\n\r\n\tfor _, onto := range ontologies {\r\n\t\tcontextCount := 0\r\n\t\tfor _, elem := range onto.Elements {\r\n\t\t\tcontextCount += len(elem.Contexts)\r\n\t\t}\r\n\r\n\t\tontologyInfos = append(ontologyInfos, OntologyInfo{\r\n\t\t\tID:           onto.ID,\r\n\t\t\tName:         onto.Name,\r\n\t\t\tElementCount: len(onto.Elements),\r\n\t\t\tContextCount: contextCount,\r\n\t\t})\r\n\t}\r\n\r\n\t// Assurez-vous de toujours renvoyer un tableau, même s'il est vide\r\n\tif ontologyInfos == nil {\r\n\t\tontologyInfos = []OntologyInfo{}\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontologyInfos)\r\n}\r\n\r\n// SearchOntologies effectue une recherche dans les ontologies\r\nfunc (h *Handler) SearchOntologies(c *gin.Context) {\r\n\tquery := c.Query(\"q\")\r\n\tontologyID := c.Query(\"ontology_id\")\r\n\telementType := c.Query(\"type\")\r\n\tcontextSize := 5 // Valeur par défaut, vous pouvez la rendre configurable si nécessaire\r\n\r\n\tif query == \"\" {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Query parameter 'q' is required\"})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Searching ontologies with query: %s\", query))\r\n\r\n\tresults, err := h.Search.Search(query, ontologyID, elementType, contextSize)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error during search: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"An error occurred during the search\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Log des résultats côté serveur\r\n\th.Logger.Info(fmt.Sprintf(\"Search results: %+v\", results))\r\n\r\n\t// Assurez-vous que chaque résultat inclut les contextes\r\n\tfor i, result := range results {\r\n\t\telement, err := h.Storage.GetElement(result.ElementName)\r\n\t\tif err == nil \u0026\u0026 element != nil {\r\n\t\t\tresults[i].Contexts = element.Contexts\r\n\t\t}\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, results)\r\n}\r\n\r\n// ElementDetailsHandler récupère les détails d'un élément spécifique\r\nfunc (h *Handler) ElementDetailsHandler(c *gin.Context) {\r\n\telementName := c.Param(\"element_id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting details for element: %s\", elementName))\r\n\r\n\telement, err := h.Storage.GetElement(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting element details: %v\", err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": MsgResourceNotFound})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Si les contextes sont nuls, essayez de les récupérer séparément\r\n\tif element.Contexts == nil {\r\n\t\tcontexts, err := h.Storage.GetElementContexts(elementName)\r\n\t\tif err == nil {\r\n\t\t\telement.Contexts = contexts\r\n\t\t}\r\n\t}\r\n\tc.JSON(http.StatusOK, element)\r\n}\r\n\r\nfunc (h *Handler) LoadOntology(c *gin.Context) {\r\n\tontologyFile, err := c.FormFile(\"ontologyFile\")\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No ontology file uploaded\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Sauvegarder le fichier d'ontologie temporairement\r\n\tontologyTempFile := filepath.Join(os.TempDir(), ontologyFile.Filename)\r\n\tif err := c.SaveUploadedFile(ontologyFile, ontologyTempFile); err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save ontology file\"})\r\n\t\treturn\r\n\t}\r\n\tdefer os.Remove(ontologyTempFile)\r\n\r\n\tvar contextTempFile string\r\n\tcontextFile, err := c.FormFile(\"contextFile\")\r\n\tif err == nil {\r\n\t\t// Un fichier de contexte a été fourni\r\n\t\tcontextTempFile = filepath.Join(os.TempDir(), contextFile.Filename)\r\n\t\tif err := c.SaveUploadedFile(contextFile, contextTempFile); err != nil {\r\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save context file\"})\r\n\t\t\treturn\r\n\t\t}\r\n\t\tdefer os.Remove(contextTempFile)\r\n\t}\r\n\r\n\t// Charger l'ontologie\r\n\terr = h.Storage.LoadOntologyFromFile(ontologyTempFile, contextTempFile)\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": fmt.Sprintf(\"Failed to load ontology: %v\", err)})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Ontology loaded successfully\"})\r\n}\r\n\r\n// GetElementRelations récupère les relations d'un élément spécifique\r\nfunc (h *Handler) GetElementRelations(c *gin.Context) {\r\n\th.Logger.Info(\"GetElementRelations endpoint called\")\r\n\tencodedElementName := c.Param(\"element_name\")\r\n\telementName, err := url.QueryUnescape(encodedElementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding element name: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid element name\"})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting relations for element: %s\", elementName))\r\n\r\n\trelations, err := h.Storage.GetElementRelations(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting element relations: %v\", err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Relations not found\"})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Found %d relations for element: %s\", len(relations), elementName))\r\n\tc.JSON(http.StatusOK, relations)\r\n}\r\n\r\nfunc (h *Handler) GetElementContexts(c *gin.Context) {\r\n\telementName := c.Param(\"element_name\")\r\n\tcontexts, err := h.Storage.GetElementContexts(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting contexts for element %s: %v\", elementName, err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Element not found\"})\r\n\t\treturn\r\n\t}\r\n\tc.JSON(http.StatusOK, contexts)\r\n}\r\n",
    "size": 8789,
    "modTime": "2024-10-27T11:39:54.054466+01:00",
    "path": "internal\\api\\handlers.go"
  },
  {
    "name": "handlers_test.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"encoding/json\"\r\n\t\"net/http\"\r\n\t\"net/http/httptest\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc setupTestHandler() (*Handler, *gin.Engine) {\r\n\tstorage := storage.NewMemoryStorage()\r\n\tlogger, _ := logger.NewLogger(logger.INFO, \"test_logs\")\r\n\tsearchEngine := search.NewSearchEngine(storage, logger)\r\n\thandler := NewHandler(storage, logger, searchEngine)\r\n\r\n\tgin.SetMode(gin.TestMode)\r\n\trouter := gin.New()\r\n\treturn handler, router\r\n}\r\n\r\nfunc TestGetOntology(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Add a test ontology\r\n\ttestOntology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\t// Test successful retrieval\r\n\trouter.GET(\"/ontologies/:id\", h.GetOntology)\r\n\treq, _ := http.NewRequest(\"GET\", \"/ontologies/test1\", nil)\r\n\tw := httptest.NewRecorder()\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedOntology)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedOntology.ID != testOntology.ID {\r\n\t\tt.Errorf(\"Expected ontology ID %s, got %s\", testOntology.ID, returnedOntology.ID)\r\n\t}\r\n\r\n\t// Test non-existent ontology\r\n\treq, _ = http.NewRequest(\"GET\", \"/ontologies/nonexistent\", nil)\r\n\tw = httptest.NewRecorder()\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusNotFound {\r\n\t\tt.Errorf(\"Expected status 404, got %d\", w.Code)\r\n\t}\r\n}\r\n\r\nfunc TestAddOntology(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\trouter.POST(\"/ontologies\", h.AddOntology)\r\n\r\n\tnewOntology := models.Ontology{Name: \"New Test Ontology\"}\r\n\tbody, _ := json.Marshal(newOntology)\r\n\treq, _ := http.NewRequest(\"POST\", \"/ontologies\", bytes.NewBuffer(body))\r\n\treq.Header.Set(\"Content-Type\", \"application/json\")\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusCreated {\r\n\t\tt.Errorf(\"Expected status 201, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedOntology)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedOntology.Name != newOntology.Name {\r\n\t\tt.Errorf(\"Expected ontology name %s, got %s\", newOntology.Name, returnedOntology.Name)\r\n\t}\r\n}\r\n\r\nfunc TestSearchOntologies(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\trouter.GET(\"/search\", h.SearchOntologies)\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/search?q=Test\", nil)\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar results []search.SearchResult\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026results)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\r\n\t// Add more specific assertions based on your expected search results\r\n}\r\n\r\nfunc TestElementDetailsHandler(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Add a test ontology with an element\r\n\ttestElement := \u0026models.OntologyElement{\r\n\t\tName:        \"Test Element\",\r\n\t\tType:        \"TestType\",\r\n\t\tDescription: \"This is a test element\",\r\n\t}\r\n\ttestOntology := \u0026models.Ontology{\r\n\t\tID:       \"test1\",\r\n\t\tName:     \"Test Ontology\",\r\n\t\tElements: []*models.OntologyElement{testElement},\r\n\t}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\trouter.GET(\"/elements/:element_id\", h.ElementDetailsHandler)\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/elements/Test Element\", nil)\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedElement models.OntologyElement\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedElement)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedElement.Name != \"Test Element\" {\r\n\t\tt.Errorf(\"Expected element name 'Test Element', got '%s'\", returnedElement.Name)\r\n\t}\r\n}\r\n",
    "size": 4210,
    "modTime": "2024-10-26T20:17:28.1015909+02:00",
    "path": "internal\\api\\handlers_test.go"
  },
  {
    "name": "router.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc SetupRoutes(router *gin.RouterGroup, storage *storage.MemoryStorage, logger *logger.Logger) {\r\n\tsearchEngine := search.NewSearchEngine(storage, logger)\r\n\thandler := NewHandler(storage, logger, searchEngine)\r\n\r\n\trouter.GET(\"/ontologies\", handler.ListOntologies)\r\n\trouter.POST(\"/ontologies\", handler.AddOntology)\r\n\trouter.GET(\"/ontologies/:id\", handler.GetOntology)\r\n\trouter.PUT(\"/ontologies/:id\", handler.UpdateOntology)\r\n\trouter.DELETE(\"/ontologies/:id\", handler.DeleteOntology)\r\n\trouter.POST(\"/ontologies/load\", handler.LoadOntology)\r\n\r\n\trouter.GET(\"/search\", handler.SearchOntologies)\r\n\r\n\trouter.GET(\"/elements/details/:element_id\", handler.ElementDetailsHandler)\r\n\trouter.GET(\"/elements/relations/:element_name\", handler.GetElementRelations)\r\n}\r\n",
    "size": 982,
    "modTime": "2024-10-26T22:02:31.4151535+02:00",
    "path": "internal\\api\\router.go"
  },
  {
    "name": "config.go",
    "content": "package config\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"gopkg.in/yaml.v2\"\r\n)\r\n\r\n// Config holds the application configuration\r\ntype Config struct {\r\n\tServer struct {\r\n\t\tPort int    `yaml:\"port\"`\r\n\t\tHost string `yaml:\"host\"`\r\n\t\tMode string `yaml:\"mode\"` // Ajout du champ Mode\r\n\t} `yaml:\"server\"`\r\n\tLogging struct {\r\n\t\tLevel     string `yaml:\"level\"`\r\n\t\tDirectory string `yaml:\"directory\"`\r\n\t} `yaml:\"logging\"`\r\n\tStorage struct {\r\n\t\tTempDirectory string `yaml:\"temp_directory\"`\r\n\t} `yaml:\"storage\"`\r\n}\r\n\r\n// LoadConfig reads the config file and returns a Config struct\r\nfunc LoadConfig(filename string) (*Config, error) {\r\n\tconfig := \u0026Config{}\r\n\r\n\t// Read the config file\r\n\tdata, err := os.ReadFile(filename)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error reading config file: %w\", err)\r\n\t}\r\n\r\n\t// Parse the YAML\r\n\terr = yaml.Unmarshal(data, config)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error parsing config YAML: %w\", err)\r\n\t}\r\n\r\n\treturn config, nil\r\n}\r\n",
    "size": 957,
    "modTime": "2024-10-26T20:18:44.8959427+02:00",
    "path": "internal\\config\\config.go"
  },
  {
    "name": "logger.go",
    "content": "package logger\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"runtime\"\r\n\t\"time\"\r\n)\r\n\r\n// LogLevel represents the severity of a log message\r\ntype LogLevel int\r\n\r\nconst (\r\n\t// DEBUG level\r\n\tDEBUG LogLevel = iota\r\n\t// INFO level\r\n\tINFO\r\n\t// WARNING level\r\n\tWARNING\r\n\t// ERROR level\r\n\tERROR\r\n)\r\n\r\nvar levelStrings = map[LogLevel]string{\r\n\tDEBUG:   \"DEBUG\",\r\n\tINFO:    \"INFO\",\r\n\tWARNING: \"WARNING\",\r\n\tERROR:   \"ERROR\",\r\n}\r\n\r\n// Logger represents a custom logger\r\ntype Logger struct {\r\n\tlevel     LogLevel\r\n\tlogFile   *os.File\r\n\tlogger    *log.Logger\r\n\tdirectory string\r\n}\r\n\r\n// NewLogger creates a new Logger instance\r\nfunc NewLogger(level LogLevel, directory string) (*Logger, error) {\r\n\tlogger := \u0026Logger{\r\n\t\tlevel:     level,\r\n\t\tdirectory: directory,\r\n\t}\r\n\r\n\t// Ensure the log directory exists\r\n\tif err := os.MkdirAll(directory, 0755); err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to create log directory: %w\", err)\r\n\t}\r\n\r\n\terr := logger.rotate()\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error creating logger: %w\", err)\r\n\t}\r\n\treturn logger, nil\r\n}\r\n\r\n// rotate creates a new log file for the current day\r\nfunc (l *Logger) rotate() error {\r\n\tif l.logFile != nil {\r\n\t\tl.logFile.Close()\r\n\t}\r\n\r\n\tnow := time.Now()\r\n\tfilename := filepath.Join(l.directory, fmt.Sprintf(\"%s.log\", now.Format(\"2006-01-02\")))\r\n\r\n\tfile, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"error opening log file: %w\", err)\r\n\t}\r\n\r\n\tl.logFile = file\r\n\tl.logger = log.New(file, \"\", 0)\r\n\treturn nil\r\n}\r\n\r\n// log writes a log message with the given level\r\nfunc (l *Logger) log(level LogLevel, message string) {\r\n\tif level \u003c l.level {\r\n\t\treturn\r\n\t}\r\n\r\n\tnow := time.Now()\r\n\tif now.Day() != time.Now().Day() {\r\n\t\terr := l.rotate()\r\n\t\tif err != nil {\r\n\t\t\tfmt.Printf(\"Error rotating log file: %v\\n\", err)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\r\n\t_, file, line, _ := runtime.Caller(2)\r\n\tlogMessage := fmt.Sprintf(\"[%s] [%s] [%s:%d] %s\",\r\n\t\tlevelStrings[level],\r\n\t\tnow.Format(\"2006-01-02 15:04:05\"),\r\n\t\tfilepath.Base(file),\r\n\t\tline,\r\n\t\tmessage)\r\n\r\n\tl.logger.Println(logMessage)\r\n\tfmt.Printf(\"\\n%s\", logMessage)\r\n}\r\n\r\n// Debug logs a debug message\r\nfunc (l *Logger) Debug(message string) {\r\n\tl.log(DEBUG, message)\r\n}\r\n\r\n// Info logs an info message\r\nfunc (l *Logger) Info(message string) {\r\n\tl.log(INFO, message)\r\n}\r\n\r\n// Warning logs a warning message\r\nfunc (l *Logger) Warning(message string) {\r\n\tl.log(WARNING, message)\r\n}\r\n\r\n// Error logs an error message\r\nfunc (l *Logger) Error(message string) {\r\n\tl.log(ERROR, message)\r\n}\r\n",
    "size": 2547,
    "modTime": "2024-10-26T15:25:00.231732+02:00",
    "path": "internal\\logger\\logger.go"
  },
  {
    "name": "element.go",
    "content": "package models\r\n\r\ntype JSONContext struct {\r\n\tPosition    int      `json:\"position\"`\r\n\tBefore      []string `json:\"before\"`\r\n\tAfter       []string `json:\"after\"`\r\n\tElement     string   `json:\"element\"`\r\n\tLength      int      `json:\"length\"`\r\n\tStartOffset int      // Nouvelle: position de début de l'intervalle\r\n\tEndOffset   int      // Nouvelle: position de fin de l'intervalle\r\n}\r\n",
    "size": 384,
    "modTime": "2024-10-27T08:54:38.895739+01:00",
    "path": "internal\\models\\element.go"
  },
  {
    "name": "ontology.go",
    "content": "package models\r\n\r\nimport (\r\n\t\"time\"\r\n)\r\n\r\n// OntologyElement représente un élément individuel dans l'ontologie\r\ntype OntologyElement struct {\r\n\tName         string\r\n\tOriginalName string\r\n\tType         string\r\n\tPositions    []int\r\n\tDescription  string\r\n\tContexts     []JSONContext\r\n}\r\n\r\n// Relation représente une relation entre deux éléments de l'ontologie\r\ntype Relation struct {\r\n\tSource      string\r\n\tType        string\r\n\tTarget      string\r\n\tDescription string\r\n}\r\n\r\n// Ontology représente une ontologie complète\r\ntype Ontology struct {\r\n\tID         string\r\n\tName       string\r\n\tFilename   string\r\n\tFormat     string\r\n\tSize       int64\r\n\tSHA256     string\r\n\tImportedAt time.Time\r\n\tElements   []*OntologyElement\r\n\tRelations  []*Relation\r\n}\r\n",
    "size": 752,
    "modTime": "2024-10-27T11:47:00.3567949+01:00",
    "path": "internal\\models\\ontology.go"
  },
  {
    "name": "ontology_test.go",
    "content": "package models\r\n\r\nimport (\r\n\t\"testing\"\r\n\t\"time\"\r\n)\r\n\r\nfunc TestOntologyStructure(t *testing.T) {\r\n\t// Créer une nouvelle ontologie\r\n\tontology := Ontology{\r\n\t\tID:         \"test-ontology\",\r\n\t\tName:       \"Test Ontology\",\r\n\t\tFilename:   \"test.tsv\",\r\n\t\tFormat:     \"TSV\",\r\n\t\tSize:       1024,\r\n\t\tSHA256:     \"abcdef1234567890\",\r\n\t\tImportedAt: time.Now(),\r\n\t\tElements: []*OntologyElement{\r\n\t\t\t{\r\n\t\t\t\tName:        \"TestElement\",\r\n\t\t\t\tType:        \"Concept\",\r\n\t\t\t\tPositions:   []int{1, 2, 3},\r\n\t\t\t\tDescription: \"This is a test element\",\r\n\t\t\t},\r\n\t\t},\r\n\t\tRelations: []*Relation{\r\n\t\t\t{\r\n\t\t\t\tSource:      \"TestElement\",\r\n\t\t\t\tType:        \"isA\",\r\n\t\t\t\tTarget:      \"ParentElement\",\r\n\t\t\t\tDescription: \"Test relation\",\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\t// Vérifier que les champs sont correctement définis\r\n\tif ontology.ID != \"test-ontology\" {\r\n\t\tt.Errorf(\"Expected ID to be 'test-ontology', got '%s'\", ontology.ID)\r\n\t}\r\n\r\n\tif len(ontology.Elements) != 1 {\r\n\t\tt.Errorf(\"Expected 1 element, got %d\", len(ontology.Elements))\r\n\t}\r\n\r\n\tif len(ontology.Relations) != 1 {\r\n\t\tt.Errorf(\"Expected 1 relation, got %d\", len(ontology.Relations))\r\n\t}\r\n}\r\n\r\nfunc TestJSONContextStructure(t *testing.T) {\r\n\t// Tester la structure JSONContext\r\n\tcontext := JSONContext{\r\n\t\tPosition: 1,\r\n\t\tBefore:   []string{\"before\"},\r\n\t\tAfter:    []string{\"after\"},\r\n\t\tElement:  \"TestElement\",\r\n\t\tLength:   1,\r\n\t}\r\n\r\n\tif context.Element != \"TestElement\" {\r\n\t\tt.Errorf(\"Expected Element to be 'TestElement', got '%s'\", context.Element)\r\n\t}\r\n}\r\n",
    "size": 1485,
    "modTime": "2024-10-26T14:23:08.141458+02:00",
    "path": "internal\\models\\ontology_test.go"
  },
  {
    "name": "json.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\n// ParseJSON parses a JSON file and returns a slice of JSONContext structures\r\nfunc ParseJSON(filename string) ([]models.JSONContext, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse JSON file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tvar contexts []models.JSONContext\r\n\tdecoder := json.NewDecoder(file)\r\n\r\n\terr = decoder.Decode(\u0026contexts)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to decode JSON: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to decode JSON: %w\", err)\r\n\t}\r\n\r\n\t// Calculer StartOffset et EndOffset pour chaque contexte\r\n\tfor i := range contexts {\r\n\t\tctx := \u0026contexts[i]\r\n\t\tctx.StartOffset = ctx.Position - len(ctx.Before)\r\n\t\tctx.EndOffset = ctx.Position + ctx.Length + len(ctx.After) - 1\r\n\t\tlog.Info(fmt.Sprintf(\"Context for '%s': StartOffset=%d, EndOffset=%d\", ctx.Element, ctx.StartOffset, ctx.EndOffset))\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Parsed %d contexts from JSON file\", len(contexts)))\r\n\tfor i, ctx := range contexts {\r\n\t\tlog.Info(fmt.Sprintf(\"Context %d: Element=%s, Position=%d, StartOffset=%d, EndOffset=%d\",\r\n\t\t\ti, ctx.Element, ctx.Position, ctx.StartOffset, ctx.EndOffset))\r\n\t}\r\n\r\n\treturn contexts, nil\r\n}\r\n",
    "size": 1440,
    "modTime": "2024-10-27T09:02:05.7024735+01:00",
    "path": "internal\\parser\\json.go"
  },
  {
    "name": "json_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseJSON(t *testing.T) {\r\n\t// Create a temporary JSON file for testing\r\n\ttestContexts := []models.JSONContext{\r\n\t\t{\r\n\t\t\tPosition: 1,\r\n\t\t\tBefore:   []string{\"La\"},\r\n\t\t\tAfter:    []string{\"juridique\", \"sert\", \"de\", \"premier\", \"plan.\"},\r\n\t\t\tElement:  \"Qualification_Juridique\",\r\n\t\t\tLength:   1,\r\n\t\t},\r\n\t\t{\r\n\t\t\tPosition: 8,\r\n\t\t\tBefore:   []string{\"La\", \"qualification\", \"juridique\", \"sert\", \"de\", \"premier\", \"plan.\", \"Dans\"},\r\n\t\t\tAfter:    []string{\"cas\", \"des\", \"internationales,\", \"le\", \"Conseil\"},\r\n\t\t\tElement:  \"Joueuse_Internationale\",\r\n\t\t\tLength:   1,\r\n\t\t},\r\n\t}\r\n\r\n\tcontent, err := json.Marshal(testContexts)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to marshal test data: %v\", err)\r\n\t}\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.json\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write(content); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Test the ParseJSON function\r\n\tcontexts, err := ParseJSON(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseJSON returned an error: %v\", err)\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(contexts, testContexts) {\r\n\t\tt.Errorf(\"ParseJSON returned unexpected result. Got %v, want %v\", contexts, testContexts)\r\n\t}\r\n}\r\n",
    "size": 1538,
    "modTime": "2024-10-26T14:17:29.0160883+02:00",
    "path": "internal\\parser\\json_test.go"
  },
  {
    "name": "owl.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/knakk/rdf\"\r\n)\r\n\r\n// ParseOWL parses an OWL file and returns slices of OntologyElement and Relation\r\nfunc ParseOWL(filename string) ([]models.OntologyElement, []models.Relation, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse OWL file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tdecoder := rdf.NewTripleDecoder(file, rdf.RDFXML)\r\n\r\n\telements := make(map[string]*models.OntologyElement)\r\n\trelations := make(map[string]*models.Relation)\r\n\r\n\tfor triple, err := decoder.Decode(); err == nil; triple, err = decoder.Decode() {\r\n\t\tsubj := triple.Subj.String()\r\n\t\tpred := triple.Pred.String()\r\n\t\tobj := triple.Obj.String()\r\n\r\n\t\tswitch pred {\r\n\t\tcase \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\":\r\n\t\t\tif obj == \"http://www.w3.org/2002/07/owl#Class\" {\r\n\t\t\t\tif _, exists := elements[subj]; !exists {\r\n\t\t\t\t\telements[subj] = \u0026models.OntologyElement{Name: subj}\r\n\t\t\t\t}\r\n\t\t\t} else if obj == \"http://www.w3.org/2002/07/owl#ObjectProperty\" {\r\n\t\t\t\tif _, exists := relations[subj]; !exists {\r\n\t\t\t\t\trelations[subj] = \u0026models.Relation{Type: subj}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#label\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Name = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#comment\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Description = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#domain\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Source = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#range\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Target = obj\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlog.Info(fmt.Sprintf(\"Parsed triple: %s -\u003e %s -\u003e %s\", subj, pred, obj))\r\n\t}\r\n\r\n\t// Convert maps to slices\r\n\telementSlice := make([]models.OntologyElement, 0, len(elements))\r\n\tfor _, elem := range elements {\r\n\t\telementSlice = append(elementSlice, *elem)\r\n\t}\r\n\trelationSlice := make([]models.Relation, 0, len(relations))\r\n\tfor _, rel := range relations {\r\n\t\trelationSlice = append(relationSlice, *rel)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing OWL file. Found %d elements and %d relations.\", len(elementSlice), len(relationSlice)))\r\n\treturn elementSlice, relationSlice, nil\r\n}\r\n",
    "size": 2455,
    "modTime": "2024-10-26T22:33:56.9707733+02:00",
    "path": "internal\\parser\\owl.go"
  },
  {
    "name": "owl_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestParseOWL(t *testing.T) {\r\n\t// Créer un fichier OWL temporaire pour le test\r\n\tcontent := `\u003c?xml version=\"1.0\"?\u003e\r\n\u003crdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n         xmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\r\n         xmlns:owl=\"http://www.w3.org/2002/07/owl#\"\u003e\r\n    \u003cowl:Class rdf:about=\"http://example.org/Element1\"\u003e\r\n        \u003crdfs:label\u003eElement1\u003c/rdfs:label\u003e\r\n        \u003crdfs:comment\u003eDescription1\u003c/rdfs:comment\u003e\r\n    \u003c/owl:Class\u003e\r\n    \u003cowl:ObjectProperty rdf:about=\"http://example.org/Relation1\"\u003e\r\n        \u003crdfs:domain rdf:resource=\"http://example.org/Element1\"/\u003e\r\n        \u003crdfs:range rdf:resource=\"http://example.org/Element2\"/\u003e\r\n    \u003c/owl:ObjectProperty\u003e\r\n\u003c/rdf:RDF\u003e`\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.owl\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Tester la fonction ParseOWL\r\n\telements, relations, err := ParseOWL(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseOWL returned an error: %v\", err)\r\n\t}\r\n\t// Vérifier les éléments\r\n\tif len(elements) != 1 {\r\n\t\tt.Errorf(\"Expected 1 element, got %d\", len(elements))\r\n\t} else if elements[0].Name != \"Element1\" || elements[0].Description != \"Description1\" {\r\n\t\tt.Errorf(\"Unexpected element: %v\", elements[0])\r\n\t}\r\n\r\n\t// Vérifier les relations\r\n\tif len(relations) != 1 {\r\n\t\tt.Errorf(\"Expected 1 relation, got %d\", len(relations))\r\n\t} else if relations[0].Type != \"http://example.org/Relation1\" ||\r\n\t\trelations[0].Source != \"http://example.org/Element1\" ||\r\n\t\trelations[0].Target != \"http://example.org/Element2\" {\r\n\t\tt.Errorf(\"Unexpected relation: %v\", relations[0])\r\n\t}\r\n}\r\n",
    "size": 1949,
    "modTime": "2024-10-26T22:31:57.8912047+02:00",
    "path": "internal\\parser\\owl_test.go"
  },
  {
    "name": "rdf.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/knakk/rdf\"\r\n)\r\n\r\n// ParseRDF parses an RDF file and returns slices of OntologyElement and Relation\r\nfunc ParseRDF(filename string) ([]models.OntologyElement, []models.Relation, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse RDF file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tdecoder := rdf.NewTripleDecoder(file, rdf.RDFXML)\r\n\r\n\telements := make(map[string]*models.OntologyElement)\r\n\trelations := make(map[string]*models.Relation)\r\n\r\n\tfor triple, err := decoder.Decode(); err == nil; triple, err = decoder.Decode() {\r\n\t\tsubj := triple.Subj.String()\r\n\t\tpred := triple.Pred.String()\r\n\t\tobj := triple.Obj.String()\r\n\r\n\t\tswitch pred {\r\n\t\tcase \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\":\r\n\t\t\tif obj != \"http://www.w3.org/1999/02/22-rdf-syntax-ns#Property\" {\r\n\t\t\t\tif _, exists := elements[subj]; !exists {\r\n\t\t\t\t\telements[subj] = \u0026models.OntologyElement{Name: subj, Type: obj}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif _, exists := relations[subj]; !exists {\r\n\t\t\t\t\trelations[subj] = \u0026models.Relation{Type: subj}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#label\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Name = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#comment\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Description = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#domain\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Source = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#range\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Target = obj\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlog.Info(fmt.Sprintf(\"Parsed triple: %s -\u003e %s -\u003e %s\", subj, pred, obj))\r\n\t}\r\n\r\n\t// Convert maps to slices\r\n\telementSlice := make([]models.OntologyElement, 0, len(elements))\r\n\tfor _, elem := range elements {\r\n\t\telementSlice = append(elementSlice, *elem)\r\n\t}\r\n\trelationSlice := make([]models.Relation, 0, len(relations))\r\n\tfor _, rel := range relations {\r\n\t\trelationSlice = append(relationSlice, *rel)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing RDF file. Found %d elements and %d relations.\", len(elementSlice), len(relationSlice)))\r\n\treturn elementSlice, relationSlice, nil\r\n}\r\n",
    "size": 2425,
    "modTime": "2024-10-26T22:34:02.4098171+02:00",
    "path": "internal\\parser\\rdf.go"
  },
  {
    "name": "rdf_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestParseRDF(t *testing.T) {\r\n\t// Créer un fichier RDF temporaire pour le test\r\n\tcontent := `\u003c?xml version=\"1.0\"?\u003e\r\n\u003crdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n         xmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\u003e\r\n    \u003crdf:Description rdf:about=\"http://example.org/Element1\"\u003e\r\n        \u003crdf:type rdf:resource=\"http://example.org/Type1\"/\u003e\r\n        \u003crdfs:label\u003eElement1\u003c/rdfs:label\u003e\r\n        \u003crdfs:comment\u003eDescription1\u003c/rdfs:comment\u003e\r\n    \u003c/rdf:Description\u003e\r\n    \u003crdf:Description rdf:about=\"http://example.org/Relation1\"\u003e\r\n        \u003crdf:type rdf:resource=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#Property\"/\u003e\r\n        \u003crdfs:domain rdf:resource=\"http://example.org/Element1\"/\u003e\r\n        \u003crdfs:range rdf:resource=\"http://example.org/Element2\"/\u003e\r\n    \u003c/rdf:Description\u003e\r\n\u003c/rdf:RDF\u003e`\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.rdf\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Tester la fonction ParseRDF\r\n\telements, relations, err := ParseRDF(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseRDF returned an error: %v\", err)\r\n\t}\r\n\r\n\t// Vérifier les éléments\r\n\tif len(elements) != 1 {\r\n\t\tt.Errorf(\"Expected 1 element, got %d\", len(elements))\r\n\t} else if elements[0].Name != \"Element1\" || elements[0].Description != \"Description1\" {\r\n\t\tt.Errorf(\"Unexpected element: %v\", elements[0])\r\n\t}\r\n\r\n\t// Vérifier les relations\r\n\tif len(relations) != 1 {\r\n\t\tt.Errorf(\"Expected 1 relation, got %d\", len(relations))\r\n\t} else if relations[0].Type != \"http://example.org/Relation1\" ||\r\n\t\trelations[0].Source != \"http://example.org/Element1\" ||\r\n\t\trelations[0].Target != \"http://example.org/Element2\" {\r\n\t\tt.Errorf(\"Unexpected relation: %v\", relations[0])\r\n\t}\r\n}\r\n",
    "size": 2053,
    "modTime": "2024-10-26T22:31:46.7297009+02:00",
    "path": "internal\\parser\\rdf_test.go"
  },
  {
    "name": "tsv.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"encoding/csv\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nvar log *logger.Logger\r\n\r\nfunc init() {\r\n\tvar err error\r\n\tlogDir := filepath.Join(\".\", \"logs\") // Use a relative path\r\n\tlog, err = logger.NewLogger(logger.INFO, logDir)\r\n\tif err != nil {\r\n\t\tpanic(fmt.Sprintf(\"Failed to initialize logger: %v\", err))\r\n\t}\r\n}\r\n\r\n// ParseTSV parses a TSV file and returns a slice of Element structures\r\nfunc ParseTSV(filename string) ([]models.OntologyElement, []models.Relation, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse TSV file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\treader := csv.NewReader(bufio.NewReader(file))\r\n\treader.Comma = '\\t'         // Use tab as delimiter\r\n\treader.LazyQuotes = true    // Allow quotes within fields\r\n\treader.FieldsPerRecord = -1 // Allow variable number of fields\r\n\r\n\tvar elements []models.OntologyElement\r\n\tvar relations []models.Relation\r\n\r\n\tlineNumber := 0\r\n\tfor {\r\n\t\trecord, err := reader.Read()\r\n\t\tif err == io.EOF {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error reading TSV record: %v\", err))\r\n\t\t\treturn nil, nil, fmt.Errorf(\"error reading TSV record: %w\", err)\r\n\t\t}\r\n\r\n\t\tlineNumber++\r\n\r\n\t\tif len(record) \u003c 4 {\r\n\t\t\tlog.Warning(fmt.Sprintf(\"Skipping invalid record on line %d: %v\", lineNumber, record))\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\t// Les deux premiers champs sont toujours le nom et le type\r\n\t\tname := strings.TrimSpace(record[0])\r\n\t\telemType := strings.TrimSpace(record[1])\r\n\r\n\t\t// Le dernier champ est toujours les positions\r\n\t\tpositionsStr := record[len(record)-1]\r\n\r\n\t\t// Tout ce qui se trouve entre est la description (peut contenir des tabulations)\r\n\t\tdescription := strings.Join(record[2:len(record)-1], \"\\t\")\r\n\r\n\t\t// Parse positions\r\n\t\tvar positions []int\r\n\t\tfor _, pos := range strings.Split(positionsStr, \",\") {\r\n\t\t\tif p, err := strconv.Atoi(strings.TrimSpace(pos)); err == nil {\r\n\t\t\t\tpositions = append(positions, p)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Create an OntologyElement\r\n\t\telement := models.OntologyElement{\r\n\t\t\tName:        name,\r\n\t\t\tType:        elemType,\r\n\t\t\tDescription: strings.TrimSpace(description),\r\n\t\t\tPositions:   positions,\r\n\t\t}\r\n\t\telements = append(elements, element)\r\n\r\n\t\t// Create a Relation\r\n\t\t// Note: Nous supposons que le champ Type de la relation est le même que le Type de l'élément\r\n\t\t// Si ce n'est pas le cas, vous devrez ajuster cette logique\r\n\t\trelation := models.Relation{\r\n\t\t\tSource:      name,\r\n\t\t\tType:        elemType,\r\n\t\t\tTarget:      strings.TrimSpace(record[2]), // Supposons que le troisième champ est la cible\r\n\t\t\tDescription: strings.TrimSpace(description),\r\n\t\t}\r\n\t\trelations = append(relations, relation)\r\n\r\n\t\tlog.Info(fmt.Sprintf(\"Parsed line %d: Element: %s, Type: %s, Description: %s\",\r\n\t\t\tlineNumber, element.Name, element.Type, element.Description))\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing TSV file. Found %d elements and %d relations.\", len(elements), len(relations)))\r\n\treturn elements, relations, nil\r\n}\r\n\r\nfunc parsePositions(positionsStr string) ([]int, error) {\r\n\tpositionsStr = strings.TrimSpace(positionsStr)\r\n\tif positionsStr == \"\" {\r\n\t\treturn []int{}, nil\r\n\t}\r\n\r\n\tpositionStrs := strings.Split(positionsStr, \",\")\r\n\tpositions := make([]int, 0, len(positionStrs))\r\n\r\n\tfor _, pos := range positionStrs {\r\n\t\tpos = strings.TrimSpace(pos)\r\n\t\tif pos == \"\" {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tposition, err := strconv.Atoi(pos)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, fmt.Errorf(\"invalid position: %s\", pos)\r\n\t\t}\r\n\t\tpositions = append(positions, position)\r\n\t}\r\n\r\n\treturn positions, nil\r\n}\r\n",
    "size": 3840,
    "modTime": "2024-10-27T16:53:05.5993747+01:00",
    "path": "internal\\parser\\tsv.go"
  },
  {
    "name": "tsv_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseTSV(t *testing.T) {\r\n\t// Créer un fichier TSV temporaire pour le test\r\n\tcontent := `Element1\tType1\tTarget1\tDescription1\r\nElement2\tType2\tTarget2\tDescription2\r\nElement3\tType3\tTarget3\tDescription3`\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.tsv\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Tester la fonction ParseTSV\r\n\telements, relations, err := ParseTSV(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseTSV returned an error: %v\", err)\r\n\t}\r\n\r\n\t// Vérifier les éléments\r\n\texpectedElements := []models.OntologyElement{\r\n\t\t{Name: \"Element1\", Type: \"Type1\", Description: \"Description1\"},\r\n\t\t{Name: \"Element2\", Type: \"Type2\", Description: \"Description2\"},\r\n\t\t{Name: \"Element3\", Type: \"Type3\", Description: \"Description3\"},\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(elements, expectedElements) {\r\n\t\tt.Errorf(\"ParseTSV returned unexpected elements. Got %v, want %v\", elements, expectedElements)\r\n\t}\r\n\r\n\t// Vérifier les relations\r\n\texpectedRelations := []models.Relation{\r\n\t\t{Source: \"Element1\", Type: \"Type1\", Target: \"Target1\", Description: \"Description1\"},\r\n\t\t{Source: \"Element2\", Type: \"Type2\", Target: \"Target2\", Description: \"Description2\"},\r\n\t\t{Source: \"Element3\", Type: \"Type3\", Target: \"Target3\", Description: \"Description3\"},\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(relations, expectedRelations) {\r\n\t\tt.Errorf(\"ParseTSV returned unexpected relations. Got %v, want %v\", relations, expectedRelations)\r\n\t}\r\n}\r\n",
    "size": 1849,
    "modTime": "2024-10-26T22:29:30.8821966+02:00",
    "path": "internal\\parser\\tsv_test.go"
  },
  {
    "name": "engine.go",
    "content": "package search\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"sort\"\r\n\t\"strings\"\r\n\t\"sync\"\r\n\r\n\t\"github.com/agnivade/levenshtein\"\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n)\r\n\r\n// SearchEngine représente le moteur de recherche\r\ntype SearchEngine struct {\r\n\tStorage *storage.MemoryStorage\r\n\tLogger  *logger.Logger\r\n}\r\n\r\n// NewSearchEngine crée une nouvelle instance de SearchEngine\r\nfunc NewSearchEngine(storage *storage.MemoryStorage, logger *logger.Logger) *SearchEngine {\r\n\treturn \u0026SearchEngine{\r\n\t\tStorage: storage,\r\n\t\tLogger:  logger,\r\n\t}\r\n}\r\n\r\n// SearchResult représente un résultat de recherche\r\ntype SearchResult struct {\r\n\tOntologyID  string\r\n\tElementName string\r\n\tElementType string\r\n\tDescription string\r\n\tContext     string\r\n\tPosition    int\r\n\tRelevance   float64\r\n\tContexts    []models.JSONContext\r\n}\r\n\r\n// Search effectue une recherche dans les ontologies\r\nfunc (se *SearchEngine) Search(query string, ontologyID string, elementType string, contextSize int) ([]SearchResult, error) {\r\n\tse.Logger.Info(\"Starting search with query: \" + query)\r\n\tquery = strings.ToLower(query)\r\n\tvar results []SearchResult\r\n\tvar wg sync.WaitGroup\r\n\tresultChan := make(chan SearchResult)\r\n\r\n\tontologies := se.Storage.ListOntologies()\r\n\tse.Logger.Info(fmt.Sprintf(\"Searching through %d ontologies\", len(ontologies)))\r\n\r\n\tfor _, ontology := range ontologies {\r\n\t\tif ontologyID != \"\" \u0026\u0026 ontology.ID != ontologyID {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\twg.Add(1)\r\n\t\tgo func(onto *models.Ontology) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\tse.Logger.Info(fmt.Sprintf(\"Searching in ontology: %s (Elements: %d)\", onto.ID, len(onto.Elements)))\r\n\t\t\tfor _, element := range onto.Elements {\r\n\t\t\t\tse.Logger.Info(fmt.Sprintf(\"Examining element: %s (Type: %s, Contexts: %d)\",\r\n\t\t\t\t\telement.Name, element.Type, len(element.Contexts)))\r\n\r\n\t\t\t\tif elementType != \"\" \u0026\u0026 element.Type != elementType {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\r\n\t\t\t\trelevance := calculateRelevance(query, element)\r\n\t\t\t\tif relevance \u003e 0.3 {\r\n\t\t\t\t\tcontext := extractContext(element, contextSize)\r\n\t\t\t\t\tposition := 0\r\n\t\t\t\t\tif len(element.Positions) \u003e 0 {\r\n\t\t\t\t\t\tposition = element.Positions[0]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult := SearchResult{\r\n\t\t\t\t\t\tOntologyID:  onto.ID,\r\n\t\t\t\t\t\tElementName: element.Name,\r\n\t\t\t\t\t\tElementType: element.Type,\r\n\t\t\t\t\t\tDescription: element.Description,\r\n\t\t\t\t\t\tContext:     context,\r\n\t\t\t\t\t\tPosition:    position,\r\n\t\t\t\t\t\tRelevance:   relevance,\r\n\t\t\t\t\t\tContexts:    element.Contexts,\r\n\t\t\t\t\t}\r\n\t\t\t\t\tse.Logger.Info(fmt.Sprintf(\"Found relevant result: %s (Relevance: %.2f, Contexts: %d)\",\r\n\t\t\t\t\t\tresult.ElementName, result.Relevance, len(result.Contexts)))\r\n\t\t\t\t\tresultChan \u003c- result\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}(ontology)\r\n\t}\r\n\r\n\tgo func() {\r\n\t\twg.Wait()\r\n\t\tclose(resultChan)\r\n\t}()\r\n\r\n\tfor result := range resultChan {\r\n\t\tresults = append(results, result)\r\n\t}\r\n\r\n\tsortSearchResults(results)\r\n\r\n\tse.Logger.Info(fmt.Sprintf(\"Search completed. Found %d results.\", len(results)))\r\n\tfor _, result := range results {\r\n\t\tse.Logger.Info(fmt.Sprintf(\"Result: %s (Contexts: %d)\", result.ElementName, len(result.Contexts)))\r\n\t}\r\n\treturn results, nil\r\n}\r\n\r\n// sortSearchResults trie les résultats de recherche par pertinence décroissante\r\nfunc sortSearchResults(results []SearchResult) {\r\n\tsort.Slice(results, func(i, j int) bool {\r\n\t\treturn results[i].Relevance \u003e results[j].Relevance\r\n\t})\r\n}\r\n\r\n// calculateRelevance calcule la pertinence d'un élément par rapport à la requête\r\nfunc calculateRelevance(query string, element *models.OntologyElement) float64 {\r\n\trelevance := 0.0\r\n\r\n\tnameRelevance := fuzzyMatch(query, element.Name)\r\n\trelevance += nameRelevance * 0.6\r\n\r\n\ttypeRelevance := fuzzyMatch(query, element.Type)\r\n\trelevance += typeRelevance * 0.3\r\n\r\n\tdescRelevance := fuzzyMatch(query, element.Description)\r\n\trelevance += descRelevance * 0.1\r\n\r\n\treturn math.Min(relevance, 1.0)\r\n}\r\n\r\n// fuzzyMatch calcule la similarité entre deux chaînes\r\nfunc fuzzyMatch(s1, s2 string) float64 {\r\n\ts1 = strings.ToLower(s1)\r\n\ts2 = strings.ToLower(s2)\r\n\r\n\tif strings.Contains(s2, s1) {\r\n\t\treturn 1.0\r\n\t}\r\n\r\n\tdistance := levenshtein.ComputeDistance(s1, s2)\r\n\tmaxLen := float64(max(len(s1), len(s2)))\r\n\r\n\tif maxLen == 0 {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tsimilarity := 1 - float64(distance)/maxLen\r\n\tif similarity \u003c 0.3 {\r\n\t\treturn 0\r\n\t}\r\n\treturn math.Round(similarity*100) / 100 // Arrondir à deux décimales\r\n}\r\n\r\n// extractContext extrait le contexte d'un élément\r\nfunc extractContext(element *models.OntologyElement, contextSize int) string {\r\n\tif len(element.Contexts) \u003e 0 {\r\n\t\tcontext := element.Contexts[0] // Prendre le premier contexte\r\n\t\tbefore := strings.Join(context.Before, \" \")\r\n\t\tafter := strings.Join(context.After, \" \")\r\n\t\treturn fmt.Sprintf(\"%s [%s] %s\", before, context.Element, after)\r\n\t}\r\n\t// Si pas de contexte disponible, retourner une chaîne vide\r\n\treturn \"\"\r\n}\r\n\r\nfunc max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n",
    "size": 4952,
    "modTime": "2024-10-27T09:09:12.7991365+01:00",
    "path": "internal\\search\\engine.go"
  },
  {
    "name": "engine_test.go",
    "content": "package search\r\n\r\nimport (\r\n\t\"math\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n)\r\n\r\nfunc TestSearch(t *testing.T) {\r\n\t// Créer un stockage en mémoire mock\r\n\tmockStorage := storage.NewMemoryStorage()\r\n\r\n\t// Créer un logger mock\r\n\tmockLogger, _ := logger.NewLogger(logger.INFO, \"test_logs\")\r\n\r\n\t// Ajouter quelques ontologies de test\r\n\tontology1 := \u0026models.Ontology{\r\n\t\tID:   \"onto1\",\r\n\t\tName: \"Test Ontology 1\",\r\n\t\tElements: []*models.OntologyElement{\r\n\t\t\t{Name: \"Apple\", Type: \"Fruit\", Description: \"A sweet fruit\", Positions: []int{1}},\r\n\t\t\t{Name: \"Banana\", Type: \"Fruit\", Description: \"A yellow fruit\", Positions: []int{2}},\r\n\t\t},\r\n\t}\r\n\tontology2 := \u0026models.Ontology{\r\n\t\tID:   \"onto2\",\r\n\t\tName: \"Test Ontology 2\",\r\n\t\tElements: []*models.OntologyElement{\r\n\t\t\t{Name: \"Car\", Type: \"Vehicle\", Description: \"A road vehicle\", Positions: []int{1}},\r\n\t\t\t{Name: \"Bicycle\", Type: \"Vehicle\", Description: \"A two-wheeled vehicle\", Positions: []int{2}},\r\n\t\t},\r\n\t}\r\n\tmockStorage.AddOntology(ontology1)\r\n\tmockStorage.AddOntology(ontology2)\r\n\r\n\t// Créer le moteur de recherche\r\n\tsearchEngine := NewSearchEngine(mockStorage, mockLogger)\r\n\t// Test 1: Recherche générale\r\n\tresults, err := searchEngine.Search(\"fruit\", \"\", \"\", 5)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Unexpected error: %v\", err)\r\n\t}\r\n\tif len(results) != 2 {\r\n\t\tt.Errorf(\"Expected 2 results, got %d\", len(results))\r\n\t}\r\n\r\n\t// Test 2: Recherche dans une ontologie spécifique\r\n\tresults, err = searchEngine.Search(\"vehicle\", \"onto2\", \"\", 5)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Unexpected error: %v\", err)\r\n\t}\r\n\tif len(results) != 2 {\r\n\t\tt.Errorf(\"Expected 2 results, got %d\", len(results))\r\n\t}\r\n\r\n\t// Test 3: Recherche avec résultats partiels\r\n\tresults, err = searchEngine.Search(\"airplane\", \"\", \"\", 5)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Unexpected error: %v\", err)\r\n\t}\r\n\tif len(results) \u003e 1 {\r\n\t\tt.Errorf(\"Expected 0 or 1 results, got %d\", len(results))\r\n\t}\r\n\r\n\t// ... (le reste du code reste inchangé)\r\n}\r\n\r\nfunc TestFuzzyMatch(t *testing.T) {\r\n\ttests := []struct {\r\n\t\ts1       string\r\n\t\ts2       string\r\n\t\texpected float64\r\n\t}{\r\n\t\t{\"apple\", \"apple\", 1.0},\r\n\t\t{\"apple\", \"appl\", 0.8},\r\n\t\t{\"apple\", \"aple\", 0.8}, // Changé de 0.75 à 0.8 pour correspondre à l'arrondi\r\n\t\t{\"apple\", \"banana\", 0.0},\r\n\t}\r\n\r\n\tfor _, test := range tests {\r\n\t\tresult := fuzzyMatch(test.s1, test.s2)\r\n\t\tif math.Abs(result-test.expected) \u003e 0.01 {\r\n\t\t\tt.Errorf(\"For '%s' and '%s', expected %f, got %f\", test.s1, test.s2, test.expected, result)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestCalculateRelevance(t *testing.T) {\r\n\telement := \u0026models.OntologyElement{\r\n\t\tName:        \"Apple\",\r\n\t\tType:        \"Fruit\",\r\n\t\tDescription: \"A sweet red fruit\",\r\n\t}\r\n\r\n\ttests := []struct {\r\n\t\tquery       string\r\n\t\tminExpected float64\r\n\t\tmaxExpected float64\r\n\t}{\r\n\t\t{\"apple\", 0.5, 0.7},\r\n\t\t{\"fruit\", 0.2, 0.4},\r\n\t\t{\"sweet\", 0.0, 0.2},\r\n\t\t{\"red\", 0.0, 0.2},\r\n\t\t{\"banana\", 0.0, 0.1},\r\n\t}\r\n\r\n\tfor _, test := range tests {\r\n\t\trelevance := calculateRelevance(test.query, element)\r\n\t\tif relevance \u003c test.minExpected || relevance \u003e test.maxExpected {\r\n\t\t\tt.Errorf(\"For query '%s', expected relevance between %f and %f, got %f\",\r\n\t\t\t\ttest.query, test.minExpected, test.maxExpected, relevance)\r\n\t\t}\r\n\t}\r\n}\r\n",
    "size": 3319,
    "modTime": "2024-10-26T15:46:17.5691739+02:00",
    "path": "internal\\search\\engine_test.go"
  },
  {
    "name": "memory.go",
    "content": "package storage\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"path/filepath\"\r\n\t\"regexp\"\r\n\t\"sort\"\r\n\t\"strings\"\r\n\t\"sync\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/parser\"\r\n)\r\n\r\nvar log *logger.Logger\r\n\r\nfunc init() {\r\n\tvar err error\r\n\tlog, err = logger.NewLogger(logger.INFO, \"logs\")\r\n\tif err != nil {\r\n\t\tpanic(fmt.Sprintf(\"Failed to initialize logger: %v\", err))\r\n\t}\r\n}\r\n\r\n// MemoryStorage represents an in-memory storage for ontologies\r\ntype MemoryStorage struct {\r\n\tontologies map[string]*models.Ontology\r\n\tmutex      sync.RWMutex\r\n}\r\n\r\n// NewMemoryStorage initializes and returns a new MemoryStorage\r\nfunc NewMemoryStorage() *MemoryStorage {\r\n\treturn \u0026MemoryStorage{\r\n\t\tontologies: make(map[string]*models.Ontology),\r\n\t}\r\n}\r\n\r\n// AddOntology adds a new ontology to the storage\r\nfunc (ms *MemoryStorage) AddOntology(ontology *models.Ontology) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[ontology.ID]; exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s already exists\", ontology.ID)\r\n\t}\r\n\r\n\tms.ontologies[ontology.ID] = ontology\r\n\tlog.Info(fmt.Sprintf(\"Added ontology with ID: %s\", ontology.ID))\r\n\treturn nil\r\n}\r\n\r\n// GetOntology retrieves an ontology by its ID\r\nfunc (ms *MemoryStorage) GetOntology(id string) (*models.Ontology, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tontology, exists := ms.ontologies[id]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"ontology with ID %s not found\", id)\r\n\t}\r\n\r\n\treturn ontology, nil\r\n}\r\n\r\n// UpdateOntology updates an existing ontology\r\nfunc (ms *MemoryStorage) UpdateOntology(ontology *models.Ontology) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[ontology.ID]; !exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s not found\", ontology.ID)\r\n\t}\r\n\r\n\tms.ontologies[ontology.ID] = ontology\r\n\tlog.Info(fmt.Sprintf(\"Updated ontology with ID: %s\", ontology.ID))\r\n\treturn nil\r\n}\r\n\r\n// DeleteOntology removes an ontology by its ID\r\nfunc (ms *MemoryStorage) DeleteOntology(id string) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[id]; !exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s not found\", id)\r\n\t}\r\n\r\n\tdelete(ms.ontologies, id)\r\n\tlog.Info(fmt.Sprintf(\"Deleted ontology with ID: %s\", id))\r\n\treturn nil\r\n}\r\n\r\n// ListOntologies returns a list of all stored ontologies\r\nfunc (ms *MemoryStorage) ListOntologies() []*models.Ontology {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tontologies := make([]*models.Ontology, 0, len(ms.ontologies))\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tontologies = append(ontologies, ontology)\r\n\t}\r\n\r\n\treturn ontologies\r\n}\r\n\r\nfunc (ms *MemoryStorage) GetElement(elementName string) (*models.OntologyElement, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tfor _, element := range ontology.Elements {\r\n\t\t\tif element.Name == elementName {\r\n\t\t\t\tlog.Info(fmt.Sprintf(\"Found element %s with %d contexts\", elementName, len(element.Contexts)))\r\n\t\t\t\treturn element, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn nil, fmt.Errorf(\"element not found\")\r\n}\r\n\r\n// GetElementRelations récupère toutes les relations d'un élément spécifique\r\nfunc (ms *MemoryStorage) GetElementRelations(elementName string) ([]*models.Relation, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tvar relations []*models.Relation\r\n\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tfor _, relation := range ontology.Relations {\r\n\t\t\tif relation.Source == elementName || relation.Target == elementName {\r\n\t\t\t\trelations = append(relations, relation)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif len(relations) == 0 {\r\n\t\treturn nil, fmt.Errorf(\"no relations found for element: %s\", elementName)\r\n\t}\r\n\r\n\treturn relations, nil\r\n}\r\n\r\nfunc (ms *MemoryStorage) LoadOntologyFromFile(ontologyFile, contextFile string) error {\r\n\tlog.Info(fmt.Sprintf(\"Loading ontology from file: %s\", ontologyFile))\r\n\r\n\tvar elements []*models.OntologyElement\r\n\tvar relations []*models.Relation\r\n\tvar err error\r\n\r\n\t// Charger l'ontologie principale\r\n\tswitch {\r\n\tcase strings.HasSuffix(ontologyFile, \".tsv\"):\r\n\t\telementsSlice, relationsSlice, err := parser.ParseTSV(ontologyFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing TSV file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing TSV file: %w\", err)\r\n\t\t}\r\n\t\telements = make([]*models.OntologyElement, len(elementsSlice))\r\n\t\trelations = make([]*models.Relation, len(relationsSlice))\r\n\t\tfor i := range elementsSlice {\r\n\t\t\telements[i] = \u0026elementsSlice[i]\r\n\t\t}\r\n\t\tfor i := range relationsSlice {\r\n\t\t\trelations[i] = \u0026relationsSlice[i]\r\n\t\t}\r\n\tcase strings.HasSuffix(ontologyFile, \".owl\"):\r\n\t\telementsSlice, relationsSlice, err := parser.ParseOWL(ontologyFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing OWL file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing OWL file: %w\", err)\r\n\t\t}\r\n\t\telements = make([]*models.OntologyElement, len(elementsSlice))\r\n\t\trelations = make([]*models.Relation, len(relationsSlice))\r\n\t\tfor i := range elementsSlice {\r\n\t\t\telements[i] = \u0026elementsSlice[i]\r\n\t\t}\r\n\t\tfor i := range relationsSlice {\r\n\t\t\trelations[i] = \u0026relationsSlice[i]\r\n\t\t}\r\n\tcase strings.HasSuffix(ontologyFile, \".rdf\"):\r\n\t\telementsSlice, relationsSlice, err := parser.ParseRDF(ontologyFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing RDF file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing RDF file: %w\", err)\r\n\t\t}\r\n\t\telements = make([]*models.OntologyElement, len(elementsSlice))\r\n\t\trelations = make([]*models.Relation, len(relationsSlice))\r\n\t\tfor i := range elementsSlice {\r\n\t\t\telements[i] = \u0026elementsSlice[i]\r\n\t\t}\r\n\t\tfor i := range relationsSlice {\r\n\t\t\trelations[i] = \u0026relationsSlice[i]\r\n\t\t}\r\n\tdefault:\r\n\t\treturn fmt.Errorf(\"unsupported ontology file format\")\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Loaded %d elements and %d relations from ontology file\", len(elements), len(relations)))\r\n\r\n\t// Normaliser et fusionner les éléments\r\n\tnormalizedElements := make(map[string]*models.OntologyElement)\r\n\tfor _, elem := range elements {\r\n\t\tnormalizedName := normalizeElementName(elem.Name)\r\n\t\tif existingElem, exists := normalizedElements[normalizedName]; exists {\r\n\t\t\t// Fusionner les éléments\r\n\t\t\texistingElem.Positions = append(existingElem.Positions, elem.Positions...)\r\n\t\t\tif len(elem.Description) \u003e len(existingElem.Description) {\r\n\t\t\t\texistingElem.Description = elem.Description\r\n\t\t\t}\r\n\t\t\t// Fusionner et dédupliquer les types\r\n\t\t\tcombinedTypes := existingElem.Type + \"/\" + elem.Type\r\n\t\t\texistingElem.Type = deduplicateTypes(combinedTypes)\r\n\t\t} else {\r\n\t\t\t// Dédupliquer les types pour les nouveaux éléments aussi\r\n\t\t\telem.Type = deduplicateTypes(elem.Type)\r\n\t\t\tnormalizedElements[normalizedName] = elem\r\n\t\t\t// Conserver le nom original\r\n\t\t\telem.OriginalName = elem.Name\r\n\t\t\t// Utiliser le nom normalisé comme nouveau nom\r\n\t\t\telem.Name = normalizedName\r\n\t\t}\r\n\t}\r\n\r\n\t// Convertir la map en slice\r\n\telements = make([]*models.OntologyElement, 0, len(normalizedElements))\r\n\tfor _, elem := range normalizedElements {\r\n\t\telements = append(elements, elem)\r\n\t}\r\n\r\n\t// Charger le fichier de contexte JSON si fourni\r\n\tvar contexts []models.JSONContext\r\n\tif contextFile != \"\" {\r\n\t\tcontexts, err = parser.ParseJSON(contextFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing context file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing context file: %w\", err)\r\n\t\t}\r\n\t\tlog.Info(fmt.Sprintf(\"Loaded %d contexts from JSON file\", len(contexts)))\r\n\t}\r\n\r\n\t// Associer les contextes aux éléments\r\n\ttotalAssociations := 0\r\n\tfor _, elem := range elements {\r\n\t\tcontextMap := make(map[int]models.JSONContext)\r\n\t\tnormalizedElemName := normalizeElementName(elem.Name)\r\n\t\tfor _, ctx := range contexts {\r\n\t\t\tif elementInContext(normalizedElemName, ctx) {\r\n\t\t\t\t// Vérifier si au moins une position de l'élément est dans la plage du contexte\r\n\t\t\t\tfor _, pos := range elem.Positions {\r\n\t\t\t\t\tif pos \u003e= ctx.StartOffset \u0026\u0026 pos \u003c= ctx.EndOffset {\r\n\t\t\t\t\t\tif _, exists := contextMap[ctx.Position]; !exists {\r\n\t\t\t\t\t\t\tcontextMap[ctx.Position] = ctx\r\n\t\t\t\t\t\t\ttotalAssociations++\r\n\t\t\t\t\t\t\tlog.Info(fmt.Sprintf(\"Associated new context (position %d) to element %s\", ctx.Position, elem.Name))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Convertir la map en slice pour l'élément\r\n\t\telem.Contexts = make([]models.JSONContext, 0, len(contextMap))\r\n\t\tfor _, ctx := range contextMap {\r\n\t\t\telem.Contexts = append(elem.Contexts, ctx)\r\n\t\t}\r\n\t\tlog.Info(fmt.Sprintf(\"Element %s has %d unique contexts after association\", elem.Name, len(elem.Contexts)))\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Associated a total of %d unique contexts to elements\", totalAssociations))\r\n\r\n\t// Créer une nouvelle ontologie avec les éléments et relations parsés\r\n\tontology := \u0026models.Ontology{\r\n\t\tID:         fmt.Sprintf(\"onto_%d\", time.Now().UnixNano()),\r\n\t\tName:       filepath.Base(ontologyFile),\r\n\t\tFilename:   ontologyFile,\r\n\t\tFormat:     filepath.Ext(ontologyFile)[1:],\r\n\t\tSize:       0,\r\n\t\tSHA256:     \"\",\r\n\t\tImportedAt: time.Now(),\r\n\t\tElements:   elements,\r\n\t\tRelations:  relations,\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Created new ontology with ID: %s\", ontology.ID))\r\n\tlog.Info(fmt.Sprintf(\"Number of elements in ontology: %d\", len(ontology.Elements)))\r\n\tlog.Info(fmt.Sprintf(\"Number of relations in ontology: %d\", len(ontology.Relations)))\r\n\r\n\t// Vérification finale des contextes\r\n\tfor _, elem := range ontology.Elements {\r\n\t\tlog.Info(fmt.Sprintf(\"Element %s has %d unique contexts after ontology creation\", elem.Name, len(elem.Contexts)))\r\n\t}\r\n\r\n\t// Ajouter l'ontologie au stockage\r\n\terr = ms.AddOntology(ontology)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Error adding ontology to storage: %v\", err))\r\n\t\treturn fmt.Errorf(\"error adding ontology to storage: %w\", err)\r\n\t}\r\n\r\n\tlog.Info(\"Ontology successfully loaded and added to storage\")\r\n\treturn nil\r\n}\r\n\r\n// Fonction helper pour normaliser les noms d'éléments\r\nfunc normalizeElementName(name string) string {\r\n\t// Remplacer les underscores par des espaces, sauf pour certains préfixes\r\n\tparts := strings.SplitN(name, \"_\", 2)\r\n\tif len(parts) == 2 \u0026\u0026 (parts[0] == \"est\" || parts[0] == \"a\") {\r\n\t\treturn parts[0] + \" \" + strings.ReplaceAll(parts[1], \"_\", \" \")\r\n\t}\r\n\r\n\t// Remplacer les underscores par des espaces pour les autres cas\r\n\tname = strings.ReplaceAll(name, \"_\", \" \")\r\n\r\n\t// Liste des préfixes qui peuvent être suivis d'une apostrophe en français\r\n\tprefixes := []string{\r\n\t\t\"l\", \"d\", \"j\", \"m\", \"t\", \"s\", \"c\", \"n\", \"qu\",\r\n\t\t\"jusqu\", \"lorsqu\", \"puisqu\", \"quoiqu\", \"quelqu\",\r\n\t}\r\n\r\n\t// Remplacer les espaces par des apostrophes pour ces préfixes\r\n\tfor _, prefix := range prefixes {\r\n\t\tpattern := fmt.Sprintf(`\\b%s \\b`, prefix)\r\n\t\treplacement := fmt.Sprintf(\"%s'\", prefix)\r\n\t\tname = regexp.MustCompile(pattern).ReplaceAllString(name, replacement)\r\n\t}\r\n\r\n\t// Gestion spéciale pour \"aujourd hui\"\r\n\tname = strings.ReplaceAll(name, \"aujourd hui\", \"aujourd'hui\")\r\n\r\n\t// Supprimer les espaces multiples\r\n\tname = strings.Join(strings.Fields(name), \" \")\r\n\r\n\t// Ne pas mettre en minuscules pour préserver la casse originale\r\n\treturn name\r\n}\r\nfunc deduplicateTypes(types string) string {\r\n\ttypeSlice := strings.Split(types, \"/\")\r\n\ttypeMap := make(map[string]string)\r\n\tfor _, t := range typeSlice {\r\n\t\tt = strings.TrimSpace(t)\r\n\t\tnormalizedType := normalizeType(t)\r\n\t\tif existingType, exists := typeMap[normalizedType]; exists {\r\n\t\t\t// Garder la version la plus longue du type\r\n\t\t\tif len(t) \u003e len(existingType) {\r\n\t\t\t\ttypeMap[normalizedType] = t\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttypeMap[normalizedType] = t\r\n\t\t}\r\n\t}\r\n\r\n\tvar uniqueTypes []string\r\n\tfor _, t := range typeMap {\r\n\t\tuniqueTypes = append(uniqueTypes, t)\r\n\t}\r\n\r\n\tsort.Strings(uniqueTypes)\r\n\treturn strings.Join(uniqueTypes, \"/\")\r\n}\r\n\r\nfunc normalizeType(t string) string {\r\n\t// Remplacer les underscores par des espaces\r\n\tt = strings.ReplaceAll(t, \"_\", \" \")\r\n\t// Supprimer les espaces multiples\r\n\tt = strings.Join(strings.Fields(t), \" \")\r\n\t// Mettre en minuscules\r\n\treturn strings.ToLower(t)\r\n}\r\n\r\n// Fonction helper pour vérifier si un élément est présent dans un contexte\r\nfunc elementInContext(elem string, ctx models.JSONContext) bool {\r\n\telemLower := strings.ToLower(elem)\r\n\tcontextText := strings.ToLower(strings.Join(append(ctx.Before, ctx.Element), \" \") + \" \" + strings.Join(ctx.After, \" \"))\r\n\r\n\t// Vérification de la correspondance exacte\r\n\tif strings.Contains(contextText, elemLower) {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Vérification avec les underscores remplacés par des espaces\r\n\telemWithoutUnderscore := strings.ReplaceAll(elemLower, \"_\", \" \")\r\n\tif strings.Contains(contextText, elemWithoutUnderscore) {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Vérification des parties individuelles du nom de l'élément\r\n\telemParts := strings.FieldsFunc(elemLower, func(r rune) bool {\r\n\t\treturn r == '_' || r == ' '\r\n\t})\r\n\r\n\tmatchCount := 0\r\n\tfor _, part := range elemParts {\r\n\t\tif strings.Contains(contextText, part) {\r\n\t\t\tmatchCount++\r\n\t\t}\r\n\t}\r\n\r\n\t// Si plus de la moitié des parties correspondent, considérez-le comme une correspondance\r\n\tif float64(matchCount)/float64(len(elemParts)) \u003e 0.5 {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Vérification spéciale pour les éléments contenant \"est\" ou \"a\"\r\n\tif strings.Contains(elemLower, \"est_\") || strings.Contains(elemLower, \"a_\") {\r\n\t\tparts := strings.SplitN(elemLower, \"_\", 2)\r\n\t\tif len(parts) == 2 \u0026\u0026 strings.Contains(contextText, parts[1]) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\nfunc (ms *MemoryStorage) GetElementContexts(elementName string) ([]models.JSONContext, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tlog.Info(\"GetElementContext Called for: \" + elementName)\r\n\tnormalizedName := normalizeElementName(elementName)\r\n\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tfor _, elem := range ontology.Elements {\r\n\t\t\tif normalizeElementName(elem.Name) == normalizedName {\r\n\t\t\t\tlog.Info(fmt.Sprintf(\"GetElementContext found for %s with %d contexts\", elem.Name, len(elem.Contexts)))\r\n\t\t\t\treturn elem.Contexts, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil, fmt.Errorf(\"element not found: %s\", elementName)\r\n}\r\n",
    "size": 14067,
    "modTime": "2024-10-27T16:55:51.4144424+01:00",
    "path": "internal\\storage\\memory.go"
  },
  {
    "name": "memory_test.go",
    "content": "package storage\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"testing\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestNewMemoryStorage(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tif ms == nil {\r\n\t\tt.Error(\"NewMemoryStorage returned nil\")\r\n\t}\r\n\tif ms.ontologies == nil {\r\n\t\tt.Error(\"ontologies map is not initialized\")\r\n\t}\r\n}\r\n\r\nfunc TestAddOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\r\n\terr := ms.AddOntology(ontology)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to add ontology: %v\", err)\r\n\t}\r\n\r\n\t// Try to add the same ontology again\r\n\terr = ms.AddOntology(ontology)\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when adding duplicate ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestGetOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\tretrieved, err := ms.GetOntology(\"test1\")\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to get ontology: %v\", err)\r\n\t}\r\n\tif retrieved.ID != ontology.ID || retrieved.Name != ontology.Name {\r\n\t\tt.Error(\"Retrieved ontology does not match the original\")\r\n\t}\r\n\r\n\t_, err = ms.GetOntology(\"nonexistent\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when getting nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestUpdateOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\tupdatedOntology := \u0026models.Ontology{ID: \"test1\", Name: \"Updated Test Ontology\"}\r\n\terr := ms.UpdateOntology(updatedOntology)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to update ontology: %v\", err)\r\n\t}\r\n\r\n\tretrieved, _ := ms.GetOntology(\"test1\")\r\n\tif retrieved.Name != \"Updated Test Ontology\" {\r\n\t\tt.Error(\"Ontology was not updated correctly\")\r\n\t}\r\n\r\n\tnonexistentOntology := \u0026models.Ontology{ID: \"nonexistent\", Name: \"Nonexistent\"}\r\n\terr = ms.UpdateOntology(nonexistentOntology)\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when updating nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestDeleteOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\terr := ms.DeleteOntology(\"test1\")\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to delete ontology: %v\", err)\r\n\t}\r\n\r\n\t_, err = ms.GetOntology(\"test1\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when getting deleted ontology, got nil\")\r\n\t}\r\n\r\n\terr = ms.DeleteOntology(\"nonexistent\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when deleting nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestListOntologies(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology1 := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology 1\"}\r\n\tontology2 := \u0026models.Ontology{ID: \"test2\", Name: \"Test Ontology 2\"}\r\n\tms.AddOntology(ontology1)\r\n\tms.AddOntology(ontology2)\r\n\r\n\tontologies := ms.ListOntologies()\r\n\tif len(ontologies) != 2 {\r\n\t\tt.Errorf(\"Expected 2 ontologies, got %d\", len(ontologies))\r\n\t}\r\n\r\n\tfoundOntology1 := false\r\n\tfoundOntology2 := false\r\n\tfor _, o := range ontologies {\r\n\t\tif o.ID == \"test1\" {\r\n\t\t\tfoundOntology1 = true\r\n\t\t}\r\n\t\tif o.ID == \"test2\" {\r\n\t\t\tfoundOntology2 = true\r\n\t\t}\r\n\t}\r\n\r\n\tif !foundOntology1 || !foundOntology2 {\r\n\t\tt.Error(\"ListOntologies did not return all added ontologies\")\r\n\t}\r\n}\r\n\r\nfunc TestConcurrency(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tconcurrentOperations := 1000\r\n\r\n\t// Concurrent additions\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tgo func(id int) {\r\n\t\t\tontology := \u0026models.Ontology{ID: fmt.Sprintf(\"test%d\", id), Name: fmt.Sprintf(\"Test Ontology %d\", id)}\r\n\t\t\tms.AddOntology(ontology)\r\n\t\t}(i)\r\n\t}\r\n\r\n\ttime.Sleep(time.Second) // Give time for goroutines to complete\r\n\r\n\t// Verify all ontologies were added\r\n\tontologies := ms.ListOntologies()\r\n\tif len(ontologies) != concurrentOperations {\r\n\t\tt.Errorf(\"Expected %d ontologies, got %d\", concurrentOperations, len(ontologies))\r\n\t}\r\n\r\n\t// Concurrent reads and updates\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tgo func(id int) {\r\n\t\t\tontologyID := fmt.Sprintf(\"test%d\", id)\r\n\t\t\tms.GetOntology(ontologyID)\r\n\t\t\tupdatedOntology := \u0026models.Ontology{ID: ontologyID, Name: fmt.Sprintf(\"Updated Test Ontology %d\", id)}\r\n\t\t\tms.UpdateOntology(updatedOntology)\r\n\t\t}(i)\r\n\t}\r\n\r\n\ttime.Sleep(time.Second) // Give time for goroutines to complete\r\n\r\n\t// Verify all ontologies were updated\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tontology, _ := ms.GetOntology(fmt.Sprintf(\"test%d\", i))\r\n\t\tif ontology.Name != fmt.Sprintf(\"Updated Test Ontology %d\", i) {\r\n\t\t\tt.Errorf(\"Ontology %d was not updated correctly\", i)\r\n\t\t}\r\n\t}\r\n}\r\n",
    "size": 4603,
    "modTime": "2024-10-26T14:49:58.7993994+02:00",
    "path": "internal\\storage\\memory_test.go"
  },
  {
    "name": "api.js",
    "content": "// api.js\r\nconst API_BASE_URL = '/api';\r\n\r\n// Charger la liste des ontologies\r\nexport async function loadOntologies() {\r\n    const response = await fetch(`${API_BASE_URL}/ontologies`);\r\n    if (!response.ok) throw new Error('Erreur lors du chargement des ontologies');\r\n    return await response.json();\r\n}\r\n\r\n// Charger les types d'éléments (à implémenter côté serveur)\r\nexport async function loadElementTypes() {\r\n    // TODO: Implémenter l'appel API réel\r\n    return ['Concept', 'Relation', 'Instance'];\r\n}\r\n\r\n// Rechercher dans les ontologies\r\nexport async function searchOntologies(query, ontologyId, elementType) {\r\n    let url = `${API_BASE_URL}/search?q=${encodeURIComponent(query)}`;\r\n    if (ontologyId) url += `\u0026ontology_id=${encodeURIComponent(ontologyId)}`;\r\n    if (elementType) url += `\u0026element_type=${encodeURIComponent(elementType)}`;\r\n\r\n    const response = await fetch(url);\r\n    if (!response.ok) throw new Error('Erreur lors de la recherche');\r\n    const data = await response.json();\r\n    \r\n    return Array.isArray(data) ? data : [];\r\n}\r\n\r\n// api.js\r\nexport async function getElementDetails(elementName) {\r\n    const url = `${API_BASE_URL}/elements/details/${encodeURIComponent(elementName)}`;\r\n    console.log('Fetching element details from:', url);\r\n    try {\r\n        const response = await fetch(url);\r\n        console.log('Response status:', response.status);\r\n        if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        const data = await response.json();\r\n        console.log('Received element details:', data);\r\n        \r\n        // Assurez-vous que toutes les propriétés attendues sont présentes\r\n        return {\r\n            Name: data.Name || '',\r\n            Type: data.Type || '',\r\n            Description: data.Description || '',\r\n            Positions: data.Positions || [],\r\n            Relations: data.Relations || [],\r\n            Contexts: data.Contexts || []\r\n        };\r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des détails de l\\'élément:', error);\r\n        throw new Error('Erreur lors de la récupération des détails de l\\'élément');\r\n    }\r\n}\r\n\r\n// Charger une ontologie\r\nexport async function uploadOntology(formData) {\r\n    const response = await fetch(`${API_BASE_URL}/ontologies/load`, {\r\n        method: 'POST',\r\n        body: formData\r\n    });\r\n    if (!response.ok) throw new Error('Erreur lors du chargement de l\\'ontologie');\r\n    return await response.json();\r\n}\r\n\r\n// api.js\r\n\r\nexport async function getElementRelations(elementName) {\r\n    const url = `${API_BASE_URL}/elements/relations/${encodeURIComponent(elementName)}`;\r\n    try {\r\n        const response = await fetch(url);\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return []; // Retourne un tableau vide si aucune relation n'est trouvée\r\n            }\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        const data = await response.json();\r\n        return data;\r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des relations de l\\'élément:', error);\r\n        return []; // Retourne un tableau vide en cas d'erreur\r\n    }\r\n}",
    "size": 3277,
    "modTime": "2024-10-27T23:34:58.8179586+01:00",
    "path": "web\\api.js"
  },
  {
    "name": "graph.js",
    "content": "import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';\r\n\r\nexport function createRelationsGraph(element, relations) {\r\n    const graphContainer = document.getElementById('element-relations-graph');\r\n    graphContainer.innerHTML = ''; // Clear previous content\r\n\r\n    const width = graphContainer.clientWidth;\r\n    const height = graphContainer.clientHeight;\r\n    \r\n    const svg = d3.select(graphContainer)\r\n        .append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n    // Créer un ensemble unique de noms de nœuds\r\n    const nodeNames = new Set([element.Name, ...relations.flatMap(r =\u003e [r.Source, r.Target])]);\r\n\r\n    // Créer les nœuds en tant qu'objets\r\n    const nodes = Array.from(nodeNames).map(name =\u003e ({\r\n        id: name,\r\n        group: name === element.Name ? 1 : 2\r\n    }));\r\n\r\n    // Créer les liens\r\n    const links = relations.map(r =\u003e ({\r\n        source: r.Source,\r\n        target: r.Target,\r\n        type: r.Type\r\n    }));\r\n\r\n    const simulation = d3.forceSimulation(nodes)\r\n        .force(\"link\", d3.forceLink(links).id(d =\u003e d.id).distance(100))\r\n        .force(\"charge\", d3.forceManyBody().strength(-300))\r\n        .force(\"center\", d3.forceCenter(width / 2, height / 2));\r\n\r\n    const link = svg.append(\"g\")\r\n        .selectAll(\"line\")\r\n        .data(links)\r\n        .enter().append(\"line\")\r\n        .attr(\"stroke\", \"#999\")\r\n        .attr(\"stroke-width\", 2);\r\n\r\n    const node = svg.append(\"g\")\r\n        .selectAll(\"g\")\r\n        .data(nodes)\r\n        .enter().append(\"g\");\r\n\r\n    node.append(\"circle\")\r\n        .attr(\"r\", 20)\r\n        .attr(\"fill\", d =\u003e d.group === 1 ? \"#ff9900\" : \"#66b3ff\");\r\n\r\n    node.append(\"text\")\r\n        .text(d =\u003e d.id)\r\n        .attr(\"text-anchor\", \"middle\")\r\n        .attr(\"dy\", \".35em\")\r\n        .attr(\"font-size\", \"12px\");\r\n\r\n    simulation.on(\"tick\", () =\u003e {\r\n        link\r\n            .attr(\"x1\", d =\u003e d.source.x)\r\n            .attr(\"y1\", d =\u003e d.source.y)\r\n            .attr(\"x2\", d =\u003e d.target.x)\r\n            .attr(\"y2\", d =\u003e d.target.y);\r\n\r\n        node\r\n            .attr(\"transform\", d =\u003e `translate(${d.x},${d.y})`);\r\n    });\r\n}",
    "size": 2131,
    "modTime": "2024-10-27T23:22:41.0416865+01:00",
    "path": "web\\graph.js"
  },
  {
    "name": "index.html",
    "content": "\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"fr\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\r\n    \u003ctitle\u003eOntology Explorer\u003c/title\u003e\r\n    \u003clink href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700\u0026display=swap\" rel=\"stylesheet\"\u003e\r\n    \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cheader\u003e\r\n        \u003cnav\u003e\r\n            \u003cdiv class=\"logo\"\u003eOntology Explorer\u003c/div\u003e\r\n            \u003cdiv class=\"menu\"\u003e\r\n                \u003cbutton id=\"upload-button\"\u003eCharger des fichiers\u003c/button\u003e\r\n                \u003cbutton id=\"about-button\"\u003eÀ propos\u003c/button\u003e\r\n            \u003c/div\u003e\r\n        \u003c/nav\u003e\r\n    \u003c/header\u003e\r\n\r\n    \u003cmain\u003e\r\n        \u003csection id=\"search-section\"\u003e\r\n            \u003cinput type=\"text\" id=\"search-input\" placeholder=\"Rechercher...\"\u003e\r\n            \u003cbutton id=\"search-button\"\u003eRechercher\u003c/button\u003e\r\n            \u003cselect id=\"ontology-select\"\u003e\r\n                \u003coption value=\"\"\u003eToutes les ontologies\u003c/option\u003e\r\n            \u003c/select\u003e\r\n            \u003cselect id=\"element-type-select\"\u003e\r\n                \u003coption value=\"\"\u003eTous les types\u003c/option\u003e\r\n            \u003c/select\u003e\r\n        \u003c/section\u003e\r\n\r\n        \u003cdiv class=\"content-wrapper\"\u003e\r\n            \u003cdiv class=\"left-column\"\u003e\r\n                \u003csection id=\"results-section\"\u003e\r\n                    \u003ch2\u003eRésultats\u003c/h2\u003e\r\n                    \u003cdiv id=\"results-list\"\u003e\u003c/div\u003e\r\n                \u003c/section\u003e\r\n            \u003c/div\u003e\r\n            \u003cdiv class=\"right-column\"\u003e\r\n                \u003csection id=\"details-section\"\u003e\r\n                    \u003cdiv id=\"element-details\"\u003e\u003c/div\u003e\r\n                    \u003cdiv id=\"element-contexts\"\u003e\u003c/div\u003e\r\n                \u003c/section\u003e\r\n            \u003c/div\u003e\r\n        \u003c/div\u003e\r\n        \u003csection id=\"relations-section\"\u003e\r\n            \u003ch2\u003eRelations\u003c/h2\u003e\r\n            \u003cdiv class=\"relations-content\"\u003e\r\n                \u003cdiv id=\"element-relations-graph\"\u003e\u003c/div\u003e\r\n                \u003cdiv id=\"element-relations-list\"\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n        \u003c/section\u003e\r\n    \u003c/main\u003e\r\n\r\n    \u003cdiv id=\"upload-modal\" class=\"modal\"\u003e\r\n        \u003cdiv class=\"modal-content\"\u003e\r\n            \u003cspan class=\"close\"\u003e\u0026times;\u003c/span\u003e\r\n            \u003ch2\u003eCharger des fichiers\u003c/h2\u003e\r\n            \u003cform id=\"upload-form\"\u003e\r\n                \u003cdiv\u003e\r\n                    \u003clabel for=\"ontology-file\"\u003eFichier d'ontologie (TSV, OWL, RDF):\u003c/label\u003e\r\n                    \u003cinput type=\"file\" id=\"ontology-file\" name=\"ontologyFile\" accept=\".tsv,.owl,.rdf\" required\u003e\r\n                \u003c/div\u003e\r\n                \u003cdiv\u003e\r\n                    \u003clabel for=\"context-file\"\u003eFichier de contexte JSON (optionnel):\u003c/label\u003e\r\n                    \u003cinput type=\"file\" id=\"context-file\" name=\"contextFile\" accept=\".json\"\u003e\r\n                \u003c/div\u003e\r\n                \u003cbutton type=\"submit\"\u003eCharger\u003c/button\u003e\r\n            \u003c/form\u003e\r\n            \u003cdiv id=\"upload-progress\" class=\"hidden\"\u003e\r\n                \u003cdiv class=\"spinner\"\u003e\u003c/div\u003e\r\n                \u003cp\u003eChargement en cours...\u003c/p\u003e\r\n            \u003c/div\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cdiv id=\"loading-spinner\" class=\"loading-spinner hidden\"\u003e\r\n        \u003cdiv class=\"spinner\"\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003cscript src=\"https://d3js.org/d3.v7.min.js\"\u003e\u003c/script\u003e\r\n    \u003cscript type=\"module\" src=\"main.js\"\u003e\u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e",
    "size": 3162,
    "modTime": "2024-10-27T23:32:52.8885258+01:00",
    "path": "web\\index.html"
  },
  {
    "name": "main.js",
    "content": "// main.js\r\nimport { initUI } from './ui.js';\r\nimport { initSearch, handleSearch } from './search.js';\r\nimport { initOntologyLoader } from './ontologyLoader.js';\r\nimport './results.js';\r\n\r\n// Fonction utilitaire pour afficher les messages d'erreur\r\nexport function showErrorMessage(message) {\r\n    alert(message);\r\n}\r\n\r\n// Initialisation de l'application\r\ndocument.addEventListener('DOMContentLoaded', async () =\u003e {\r\n    try {\r\n        await initUI();\r\n        initSearch();\r\n        initOntologyLoader();\r\n\r\n        // Ajouter un écouteur pour l'événement personnalisé\r\n        document.addEventListener('performSearch', (event) =\u003e {\r\n            const searchQuery = event.detail.query;\r\n            document.getElementById('search-input').value = searchQuery;\r\n            handleSearch();\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Erreur lors de l\\'initialisation:', error);\r\n        showErrorMessage('Une erreur est survenue lors de l\\'initialisation de l\\'application.');\r\n    }\r\n});\r\n\r\nwindow.addEventListener('resize', () =\u003e {\r\n    const selectedElement = document.querySelector('.result-item.selected');\r\n    if (selectedElement) {\r\n        const elementName = selectedElement.querySelector('h3').textContent;\r\n        showElementDetails(elementName);\r\n    }\r\n});",
    "size": 1294,
    "modTime": "2024-10-27T23:13:29.1342197+01:00",
    "path": "web\\main.js"
  },
  {
    "name": "ontologyLoader.js",
    "content": "// ontologyLoader.js\r\nimport { uploadOntology } from './api.js';\r\nimport { showErrorMessage } from './main.js';\r\n\r\n// Initialisation du chargeur d'ontologie\r\nexport function initOntologyLoader() {\r\n    const uploadButton = document.getElementById('upload-button');\r\n    const uploadModal = document.getElementById('upload-modal');\r\n    const closeButton = uploadModal ? uploadModal.querySelector('.close') : null;\r\n    const uploadForm = document.getElementById('upload-form');\r\n    const uploadProgress = document.getElementById('upload-progress');\r\n\r\n    if (!uploadButton || !uploadModal || !closeButton || !uploadForm || !uploadProgress) {\r\n        console.error(\"One or more required elements are missing\");\r\n        return;\r\n    }\r\n\r\n    uploadButton.addEventListener('click', () =\u003e {\r\n        uploadModal.style.display = 'block';\r\n    });\r\n\r\n    closeButton.addEventListener('click', () =\u003e {\r\n        uploadModal.style.display = 'none';\r\n    });\r\n\r\n    uploadForm.addEventListener('submit', async (event) =\u003e {\r\n        event.preventDefault();\r\n        \r\n        try {\r\n            uploadForm.classList.add('hidden');\r\n            uploadProgress.classList.remove('hidden');\r\n            \r\n            const formData = new FormData(uploadForm);\r\n            const response = await uploadOntology(formData);\r\n            console.log('Ontologie chargée avec succès:', response);\r\n            \r\n            // Fermer le modal après un court délai\r\n            setTimeout(() =\u003e {\r\n                uploadModal.style.display = 'none';\r\n                // TODO: Mettre à jour l'interface utilisateur après le chargement réussi\r\n            }, 1000);\r\n        } catch (error) {\r\n            console.error('Erreur lors du chargement de l\\'ontologie:', error);\r\n            showErrorMessage('Une erreur est survenue lors du chargement de l\\'ontologie.');\r\n        } finally {\r\n            uploadForm.classList.remove('hidden');\r\n            uploadProgress.classList.add('hidden');\r\n        }\r\n    });\r\n}",
    "size": 2005,
    "modTime": "2024-10-27T23:31:20.429163+01:00",
    "path": "web\\ontologyLoader.js"
  },
  {
    "name": "results.js",
    "content": "// results.js\r\nimport { getElementDetails, getElementRelations } from './api.js';\r\nimport { createRelationsGraph } from './graph.js';\r\nimport { showErrorMessage } from './main.js';\r\n\r\nconst resultsList = document.getElementById('results-list');\r\nconst elementDetails = document.getElementById('element-details');\r\nconst elementContexts = document.getElementById('element-contexts');\r\nconst elementRelations = document.getElementById('element-relations');\r\n\r\nexport function displayResults(results) {\r\n    const resultsList = document.getElementById('results-list');\r\n    resultsList.innerHTML = '';\r\n    \r\n    results.forEach(result =\u003e {\r\n        const resultItem = document.createElement('div');\r\n        resultItem.className = 'result-item';\r\n        resultItem.innerHTML = `\r\n            \u003ch3\u003e${escapeHtml(result.ElementName)}\u003c/h3\u003e\r\n            \u003cp\u003e${escapeHtml(result.Description)}\u003c/p\u003e\r\n        `;\r\n        resultItem.addEventListener('click', () =\u003e {\r\n            // Supprimer la classe 'selected' de tous les éléments\r\n            document.querySelectorAll('.result-item').forEach(item =\u003e item.classList.remove('selected'));\r\n            // Ajouter la classe 'selected' à l'élément cliqué\r\n            resultItem.classList.add('selected');\r\n            showElementDetails(result.ElementName);\r\n        });\r\n        resultsList.appendChild(resultItem);\r\n    });\r\n}\r\n\r\nasync function showElementDetails(elementName) {\r\n    const loadingSpinner = document.getElementById('loading-spinner');\r\n    if (loadingSpinner) loadingSpinner.classList.remove('hidden');\r\n\r\n    try {\r\n        const element = await getElementDetails(elementName);\r\n        console.log(\"Détails de l'élément reçus:\", element);\r\n\r\n        displayElementInfo(element);\r\n        displayElementContexts(element);\r\n        \r\n        const relations = await getElementRelations(elementName);\r\n        console.log(\"Relations de l'élément reçues:\", relations);\r\n\r\n        if (relations \u0026\u0026 relations.length \u003e 0) {\r\n            displayElementRelations(relations);\r\n            createRelationsGraph(element, relations);\r\n        } else {\r\n            displayElementRelations([]);\r\n            // Vous pouvez également choisir de cacher ou effacer le graphique ici\r\n        }\r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des détails ou des relations de l\\'élément:', error);\r\n        showErrorMessage('Impossible de charger les détails ou les relations de l\\'élément.');\r\n    } finally {\r\n        if (loadingSpinner) loadingSpinner.classList.add('hidden');\r\n    }\r\n}\r\n\r\nfunction displayElementRelations(relations) {\r\n    const relationsList = document.getElementById('element-relations-list');\r\n    if (!relationsList) {\r\n        console.error(\"Element 'element-relations-list' not found\");\r\n        return;\r\n    }\r\n\r\n    relationsList.innerHTML = '';\r\n    if (relations \u0026\u0026 relations.length \u003e 0) {\r\n        const ul = document.createElement('ul');\r\n        relations.forEach(relation =\u003e {\r\n            const li = document.createElement('li');\r\n            li.textContent = `${relation.Source} ${relation.Type} ${relation.Target}`;\r\n            ul.appendChild(li);\r\n        });\r\n        relationsList.appendChild(ul);\r\n    } else {\r\n        relationsList.innerHTML = '\u003cp\u003eAucune relation disponible pour cet élément.\u003c/p\u003e';\r\n    }\r\n}\r\n\r\nfunction displayElementInfo(element) {\r\n    const positions = element.Positions \u0026\u0026 Array.isArray(element.Positions) \r\n        ? element.Positions.join(', ') \r\n        : 'Non spécifié';\r\n\r\n    elementDetails.innerHTML = `\r\n        \u003ch2\u003e${escapeHtml(element.Name)}\u003c/h2\u003e\r\n        \u003cp\u003e\u003cstrong\u003eType:\u003c/strong\u003e ${escapeHtml(element.Type)}\u003c/p\u003e\r\n        \u003cp\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e ${escapeHtml(element.Description)}\u003c/p\u003e\r\n        \u003cp\u003e\u003cstrong\u003ePositions:\u003c/strong\u003e ${positions}\u003c/p\u003e\r\n    `;\r\n}\r\n\r\nfunction displayElementContexts(element) {\r\n    elementContexts.innerHTML = '\u003ch3\u003eContextes\u003c/h3\u003e';\r\n    if (element.Contexts \u0026\u0026 element.Contexts.length \u003e 0) {\r\n        element.Contexts.forEach((ctx, index) =\u003e {\r\n            const highlightedBefore = highlightElement(ctx.before.join(' '), element.Name);\r\n            const highlightedAfter = highlightElement(ctx.after.join(' '), element.Name);\r\n            \r\n            elementContexts.innerHTML += `\r\n                \u003cdiv class=\"context\"\u003e\r\n                    \u003ch4\u003eContexte ${index + 1}\u003c/h4\u003e\r\n                    \u003cp\u003e\u003cstrong\u003eAvant:\u003c/strong\u003e ${highlightedBefore}\u003c/p\u003e\r\n                    \u003cp\u003e\u003cstrong\u003eÉlément du contexte:\u003c/strong\u003e \u003cmark\u003e${escapeHtml(ctx.element)}\u003c/mark\u003e\u003c/p\u003e\r\n                    \u003cp\u003e\u003cstrong\u003eAprès:\u003c/strong\u003e ${highlightedAfter}\u003c/p\u003e\r\n                    \u003cp\u003e\u003cstrong\u003ePosition:\u003c/strong\u003e ${ctx.position}\u003c/p\u003e\r\n                \u003c/div\u003e\r\n            `;\r\n        });\r\n\r\n        // Ajouter des écouteurs d'événements pour les éléments surlignés\r\n        const highlightedElements = elementContexts.querySelectorAll('mark');\r\n        highlightedElements.forEach(el =\u003e {\r\n            el.style.cursor = 'pointer';\r\n            el.addEventListener('click', () =\u003e {\r\n                // Déclencher un événement personnalisé\r\n                const event = new CustomEvent('performSearch', {\r\n                    detail: { query: el.textContent }\r\n                });\r\n                document.dispatchEvent(event);\r\n            });\r\n        });\r\n    } else {\r\n        elementContexts.innerHTML += '\u003cp\u003eAucun contexte disponible\u003c/p\u003e';\r\n    }\r\n}\r\n\r\nfunction highlightElement(text, elementName) {\r\n    const regex = new RegExp(elementName, 'gi');\r\n    return text.replace(regex, match =\u003e `\u003cmark\u003e${match}\u003c/mark\u003e`);\r\n}\r\n\r\nfunction escapeHtml(unsafe) {\r\n    return unsafe\r\n         .replace(/\u0026/g, \"\u0026amp;\")\r\n         .replace(/\u003c/g, \"\u0026lt;\")\r\n         .replace(/\u003e/g, \"\u0026gt;\")\r\n         .replace(/\"/g, \"\u0026quot;\")\r\n         .replace(/'/g, \"\u0026#039;\");\r\n}\r\n\r\nfunction displayRelationsList(relations) {\r\n    const relationsList = document.getElementById('element-relations-list');\r\n    relationsList.innerHTML = '';\r\n    relations.forEach(relation =\u003e {\r\n        const relationItem = document.createElement('div');\r\n        relationItem.className = 'relation-item';\r\n        relationItem.textContent = `${relation.Source} ${relation.Type} ${relation.Target}`;\r\n        relationsList.appendChild(relationItem);\r\n    });\r\n}",
    "size": 6296,
    "modTime": "2024-10-27T23:34:38.660917+01:00",
    "path": "web\\results.js"
  },
  {
    "name": "search.js",
    "content": "// search.js\r\nimport { searchOntologies } from './api.js';\r\nimport { displayResults } from './results.js';\r\nimport { showErrorMessage } from './main.js';\r\n\r\nconst searchInput = document.getElementById('search-input');\r\nconst searchButton = document.getElementById('search-button');\r\nconst ontologySelect = document.getElementById('ontology-select');\r\nconst elementTypeSelect = document.getElementById('element-type-select');\r\n\r\n// Initialisation de la recherche\r\nexport function initSearch() {\r\n    searchButton.addEventListener('click', handleSearch);\r\n    searchInput.addEventListener('input', debounce(handleSearch, 300));\r\n}\r\n\r\n// Gestion de la recherche\r\n\r\nexport async function handleSearch(event) {\r\n    if (event) event.preventDefault();\r\n    const query = searchInput.value;\r\n    const ontologyId = ontologySelect.value;\r\n    const elementType = elementTypeSelect.value;\r\n\r\n    try {\r\n        const results = await searchOntologies(query, ontologyId, elementType);\r\n        displayResults(results);\r\n        \r\n        if (results.length === 0) {\r\n            console.log('Aucun résultat trouvé pour la recherche.');\r\n        }\r\n    } catch (error) {\r\n        console.error('Erreur lors de la recherche:', error);\r\n        showErrorMessage('Une erreur est survenue lors de la recherche.');\r\n        displayResults([]); // Afficher un message \"Aucun résultat\" en cas d'erreur\r\n    }\r\n}\r\n\r\n// Fonction utilitaire pour le debounce\r\nfunction debounce(func, wait) {\r\n    let timeout;\r\n    return function executedFunction(...args) {\r\n        const later = () =\u003e {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}",
    "size": 1732,
    "modTime": "2024-10-27T11:13:12.0538921+01:00",
    "path": "web\\search.js"
  },
  {
    "name": "style.css",
    "content": ":root {\r\n    --primary-color: #3498db;\r\n    --secondary-color: #2c3e50;\r\n    --background-color: #ecf0f1;\r\n    --text-color: #34495e;\r\n}\r\n\r\n* {\r\n    box-sizing: border-box;\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\n\r\nbody {\r\n    font-family: 'Roboto', sans-serif;\r\n    line-height: 1.6;\r\n    color: var(--text-color);\r\n    background-color: var(--background-color);\r\n    height: 100vh;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\nheader {\r\n    background-color: var(--primary-color);\r\n    color: white;\r\n    padding: 1rem;\r\n}\r\n\r\nnav {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    max-width: 1400px;\r\n    margin: 0 auto;\r\n}\r\n\r\n.logo {\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n}\r\n\r\n.menu button {\r\n    background: none;\r\n    border: 1px solid white;\r\n    color: white;\r\n    cursor: pointer;\r\n    margin-left: 1rem;\r\n    padding: 0.5rem 1rem;\r\n    border-radius: 4px;\r\n}\r\n\r\nmain {\r\n    flex-grow: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    overflow: hidden;\r\n}\r\n\r\n#search-section {\r\n    padding: 1rem;\r\n    display: flex;\r\n    gap: 1rem;\r\n    background-color: white;\r\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n}\r\n\r\n#search-input, #ontology-select, #element-type-select {\r\n    flex-grow: 1;\r\n    padding: 0.5rem;\r\n    font-size: 1rem;\r\n    border: 1px solid #ccc;\r\n    border-radius: 4px;\r\n}\r\n\r\n#search-button {\r\n    padding: 0.5rem 1rem;\r\n    background-color: var(--primary-color);\r\n    color: white;\r\n    border: none;\r\n    cursor: pointer;\r\n    border-radius: 4px;\r\n}\r\n\r\n.content-wrapper {\r\n    display: flex;\r\n    height: 50vh;\r\n}\r\n\r\n.left-column, .right-column {\r\n    flex: 1;\r\n    overflow: hidden;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n#results-section, #details-section {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    padding: 1rem;\r\n    background-color: white;\r\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n    margin: 0.5rem;\r\n    border-radius: 4px;\r\n}\r\n\r\n#relations-section {\r\n    height: calc(50vh - 2rem);\r\n    padding: 1rem;\r\n    background-color: white;\r\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n    margin: 0.5rem;\r\n    border-radius: 4px;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n#relations-section h2 {\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.relations-content {\r\n    display: flex;\r\n    flex: 1;\r\n    overflow: hidden;\r\n}\r\n\r\n#element-relations-graph {\r\n    flex: 1;\r\n    height: 100%;\r\n    border-right: 1px solid #eee;\r\n    overflow: hidden;\r\n}\r\n\r\n#element-relations-list {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    padding-left: 1rem;\r\n    height: 100%;\r\n}\r\n\r\n#element-relations-graph svg {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.relation-item {\r\n    padding: 0.5rem 0;\r\n    border-bottom: 1px solid #eee;\r\n}\r\n\r\n.result-item {\r\n    cursor: pointer;\r\n    padding: 1rem;\r\n    border-bottom: 1px solid #eee;\r\n    transition: background-color 0.3s ease;\r\n}\r\n\r\n.result-item:hover {\r\n    background-color: #f5f5f5;\r\n}\r\n\r\n.result-item.selected {\r\n    background-color: #e6f3ff;\r\n    border-left: 4px solid #3498db;\r\n}\r\n\r\n.modal {\r\n    display: none;\r\n    position: fixed;\r\n    z-index: 1000;\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n}\r\n\r\n.modal-content {\r\n    background-color: #fefefe;\r\n    margin: 15% auto;\r\n    padding: 20px;\r\n    border: 1px solid #888;\r\n    width: 80%;\r\n    max-width: 500px;\r\n    border-radius: 5px;\r\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.close {\r\n    color: #aaa;\r\n    float: right;\r\n    font-size: 28px;\r\n    font-weight: bold;\r\n    cursor: pointer;\r\n}\r\n\r\n.close:hover,\r\n.close:focus {\r\n    color: #000;\r\n    text-decoration: none;\r\n    cursor: pointer;\r\n}\r\n\r\n#upload-form {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 15px;\r\n}\r\n\r\n#upload-form input[type=\"file\"] {\r\n    margin-top: 5px;\r\n}\r\n\r\n#upload-form button {\r\n    align-self: flex-start;\r\n    padding: 10px 20px;\r\n    background-color: #4CAF50;\r\n    color: white;\r\n    border: none;\r\n    border-radius: 4px;\r\n    cursor: pointer;\r\n}\r\n\r\n#upload-form button:hover {\r\n    background-color: #45a049;\r\n}\r\n\r\n#upload-progress {\r\n    text-align: center;\r\n    margin-top: 20px;\r\n}\r\n\r\n.spinner {\r\n    border: 4px solid #f3f3f3;\r\n    border-top: 4px solid #3498db;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n    margin: 0 auto;\r\n}\r\n\r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n.hidden {\r\n    display: none;\r\n}\r\n\r\nmark {\r\n    background-color: yellow;\r\n    cursor: pointer;\r\n    transition: background-color 0.3s ease;\r\n}\r\n\r\nmark:hover {\r\n    background-color: #ffff00;\r\n}",
    "size": 4673,
    "modTime": "2024-10-27T23:27:43.2756432+01:00",
    "path": "web\\style.css"
  },
  {
    "name": "ui.js",
    "content": "// ui.js\r\nimport { loadOntologies, loadElementTypes } from './api.js';\r\n\r\n// Éléments du DOM\r\nconst ontologySelect = document.getElementById('ontology-select');\r\nconst elementTypeSelect = document.getElementById('element-type-select');\r\nconst uploadButton = document.getElementById('upload-button');\r\nconst uploadModal = document.getElementById('upload-modal');\r\nconst closeModal = document.querySelector('.close');\r\n\r\n// Initialisation de l'interface utilisateur\r\nexport async function initUI() {\r\n    await populateOntologySelect();\r\n    await populateElementTypeSelect();\r\n    await updateOntologySelect();\r\n    setupModalListeners();\r\n\r\n    document.addEventListener('ontologyLoaded', updateOntologySelect);\r\n\r\n}\r\n\r\n// Remplir le sélecteur d'ontologies\r\nasync function populateOntologySelect() {\r\n    try {\r\n        const ontologies = await loadOntologies();\r\n        ontologySelect.innerHTML = '\u003coption value=\"\"\u003eToutes les ontologies\u003c/option\u003e';\r\n        ontologies.forEach(ontology =\u003e {\r\n            const option = document.createElement('option');\r\n            option.value = ontology.id;\r\n            option.textContent = ontology.name;\r\n            ontologySelect.appendChild(option);\r\n        });\r\n    } catch (error) {\r\n        console.error('Erreur lors du chargement des ontologies:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Remplir le sélecteur de types d'éléments\r\nasync function populateElementTypeSelect() {\r\n    try {\r\n        const types = await loadElementTypes();\r\n        elementTypeSelect.innerHTML = '\u003coption value=\"\"\u003eTous les types\u003c/option\u003e';\r\n        types.forEach(type =\u003e {\r\n            const option = document.createElement('option');\r\n            option.value = type;\r\n            option.textContent = type;\r\n            elementTypeSelect.appendChild(option);\r\n        });\r\n    } catch (error) {\r\n        console.error('Erreur lors du chargement des types d\\'éléments:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Configuration des écouteurs d'événements pour le modal\r\nfunction setupModalListeners() {\r\n    uploadButton.addEventListener('click', () =\u003e uploadModal.style.display = 'block');\r\n    closeModal.addEventListener('click', () =\u003e uploadModal.style.display = 'none');\r\n    window.addEventListener('click', (event) =\u003e {\r\n        if (event.target === uploadModal) {\r\n            uploadModal.style.display = 'none';\r\n        }\r\n    });\r\n}\r\n\r\nexport async function updateOntologySelect() {\r\n    try {\r\n        const ontologies = await loadOntologies();\r\n        ontologySelect.innerHTML = '\u003coption value=\"\"\u003eToutes les ontologies\u003c/option\u003e';\r\n        ontologies.forEach(ontology =\u003e {\r\n            const option = document.createElement('option');\r\n            option.value = ontology.id;\r\n            option.textContent = ontology.name;\r\n            ontologySelect.appendChild(option);\r\n        });\r\n    } catch (error) {\r\n        console.error('Erreur lors de la mise à jour des ontologies:', error);\r\n        showErrorMessage('Erreur lors de la mise à jour de la liste des ontologies.');\r\n    }\r\n}",
    "size": 3050,
    "modTime": "2024-10-27T19:16:02.549253+01:00",
    "path": "web\\ui.js"
  }
]