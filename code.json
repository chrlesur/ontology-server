[
  {
    "name": "main.go",
    "content": "package main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/api\"\r\n\t\"github.com/chrlesur/ontology-server/internal/config\"\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-contrib/cors\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc main() {\r\n\t// Load configuration\r\n\tcfg, err := config.LoadConfig(\"config.yaml\")\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Failed to load configuration: %v\", err)\r\n\t}\r\n\r\n\t// Initialize logger\r\n\tlogLevel := logger.INFO // You might want to parse this from the config\r\n\tl, err := logger.NewLogger(logLevel, cfg.Logging.Directory)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Failed to initialize logger: %v\", err)\r\n\t}\r\n\r\n\t// Set Gin mode based on config\r\n\tif cfg.Server.Mode == \"release\" {\r\n\t\tgin.SetMode(gin.ReleaseMode)\r\n\t} else {\r\n\t\tgin.SetMode(gin.DebugMode)\r\n\t}\r\n\r\n\t// Initialize Gin router\r\n\trouter := gin.New()\r\n\r\n\t// Use Gin's logger and recovery middleware\r\n\trouter.Use(gin.Logger())\r\n\trouter.Use(gin.Recovery())\r\n\r\n\t// Initialize storage\r\n\tmemoryStorage := storage.NewMemoryStorage()\r\n\r\n\t// Setup API routes\r\n\tapiGroup := router.Group(\"/api\")\r\n\tapi.SetupRoutes(apiGroup, memoryStorage, l)\r\n\r\n\t// Serve static files\r\n\trouter.NoRoute(gin.WrapH(http.FileServer(http.Dir(\"./web\"))))\r\n\r\n\t// Dans votre fonction main ou de configuration du routeur\r\n\trouter.Use(cors.Default())\r\n\r\n\t// Prepare HTTP server\r\n\taddr := fmt.Sprintf(\"%s:%d\", cfg.Server.Host, cfg.Server.Port)\r\n\tl.Info(fmt.Sprintf(\"Server listening on %s\", addr))\r\n\r\n\t// Start the server\r\n\terr = router.Run(addr)\r\n\tif err != nil {\r\n\t\tl.Error(fmt.Sprintf(\"Server failed to start: %v\", err))\r\n\t}\r\n}\r\n",
    "size": 1687,
    "modTime": "2024-10-30T22:47:03.7541603+01:00",
    "path": "cmd\\server\\main.go"
  },
  {
    "name": "config.yaml",
    "content": "server:\r\n  port: 8080\r\n  host: localhost\r\n  mode: debug  # Peut être \"debug\" ou \"release\"\r\nlogging:\r\n  level: info\r\n  directory: ./logs\r\nstorage:\r\n  temp_directory: ./temp",
    "size": 172,
    "modTime": "2024-10-30T22:47:03.7571609+01:00",
    "path": "config.yaml"
  },
  {
    "name": "errors.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n)\r\n\r\n// APIError représente une erreur de l'API\r\ntype APIError struct {\r\n\tCode    int    `json:\"code\"`\r\n\tMessage string `json:\"message\"`\r\n}\r\n\r\nfunc (e APIError) Error() string {\r\n\treturn fmt.Sprintf(\"API Error %d: %s\", e.Code, e.Message)\r\n}\r\n\r\n// Constantes pour les codes d'erreur\r\nconst (\r\n\tErrBadRequest          = 400\r\n\tErrNotFound            = 404\r\n\tErrInternalServerError = 500\r\n)\r\n\r\n// Constantes pour les messages d'erreur communs\r\nconst (\r\n\tMsgInvalidInput        = \"Invalid input provided\"\r\n\tMsgResourceNotFound    = \"Requested resource not found\"\r\n\tMsgInternalServerError = \"An internal server error occurred\"\r\n)\r\n\r\n// NewAPIError crée une nouvelle instance de APIError\r\nfunc NewAPIError(code int, message string) APIError {\r\n\treturn APIError{Code: code, Message: message}\r\n}\r\n\r\n// WriteJSONError écrit une réponse d'erreur JSON\r\nfunc WriteJSONError(w http.ResponseWriter, err APIError) {\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tw.WriteHeader(err.Code)\r\n\tjson.NewEncoder(w).Encode(err)\r\n}\r\n",
    "size": 1084,
    "modTime": "2024-10-30T22:47:03.7801611+01:00",
    "path": "internal\\api\\errors.go"
  },
  {
    "name": "handlers.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strings\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\n// Handler encapsule les dépendances nécessaires pour gérer les requêtes API\r\ntype Handler struct {\r\n\tStorage *storage.MemoryStorage\r\n\tLogger  *logger.Logger\r\n\tSearch  *search.SearchEngine\r\n}\r\n\r\n// NewHandler crée une nouvelle instance de Handler avec le stockage, le logger et le moteur de recherche fournis\r\nfunc NewHandler(storage *storage.MemoryStorage, logger *logger.Logger, search *search.SearchEngine) *Handler {\r\n\treturn \u0026Handler{Storage: storage, Logger: logger, Search: search}\r\n}\r\n\r\n// GetOntology récupère une ontologie par son ID\r\nfunc (h *Handler) GetOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting ontology with ID: %s\", id))\r\n\r\n\tontology, err := h.Storage.GetOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting ontology: %v\", err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": MsgResourceNotFound})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology)\r\n}\r\n\r\n// AddOntology ajoute une nouvelle ontologie\r\nfunc (h *Handler) AddOntology(c *gin.Context) {\r\n\tvar ontology models.Ontology\r\n\tif err := c.ShouldBindJSON(\u0026ontology); err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": MsgInvalidInput})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Générer un ID unique\r\n\tontology.ID = fmt.Sprintf(\"onto_%d\", time.Now().UnixNano())\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Adding new ontology: %s with ID: %s\", ontology.Name, ontology.ID))\r\n\r\n\terr := h.Storage.AddOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error adding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusCreated, ontology)\r\n}\r\n\r\n// UpdateOntology met à jour une ontologie existante\r\nfunc (h *Handler) UpdateOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\tvar ontology models.Ontology\r\n\tif err := c.ShouldBindJSON(\u0026ontology); err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": MsgInvalidInput})\r\n\t\treturn\r\n\t}\r\n\r\n\tontology.ID = id\r\n\th.Logger.Info(fmt.Sprintf(\"Updating ontology: %s\", id))\r\n\r\n\terr := h.Storage.UpdateOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error updating ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology)\r\n}\r\n\r\n// DeleteOntology supprime une ontologie par son ID\r\nfunc (h *Handler) DeleteOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Deleting ontology: %s\", id))\r\n\r\n\terr := h.Storage.DeleteOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error deleting ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.Status(http.StatusNoContent)\r\n}\r\n\r\n// ListOntologies récupère la liste de toutes les ontologies\r\nfunc (h *Handler) ListOntologies(c *gin.Context) {\r\n\th.Logger.Info(\"Listing all ontologies\")\r\n\r\n\tontologies := h.Storage.ListOntologies()\r\n\r\n\t// Créer une structure pour l'affichage\r\n\ttype OntologyInfo struct {\r\n\t\tID           string `json:\"id\"`\r\n\t\tName         string `json:\"name\"`\r\n\t\tElementCount int    `json:\"elementCount\"`\r\n\t\tContextCount int    `json:\"contextCount\"`\r\n\t}\r\n\r\n\tvar ontologyInfos []OntologyInfo\r\n\r\n\tfor _, onto := range ontologies {\r\n\t\tcontextCount := 0\r\n\t\tfor _, elem := range onto.Elements {\r\n\t\t\tcontextCount += len(elem.Contexts)\r\n\t\t}\r\n\r\n\t\tontologyInfos = append(ontologyInfos, OntologyInfo{\r\n\t\t\tID:           onto.ID,\r\n\t\t\tName:         onto.Name,\r\n\t\t\tElementCount: len(onto.Elements),\r\n\t\t\tContextCount: contextCount,\r\n\t\t})\r\n\t}\r\n\r\n\t// Assurez-vous de toujours renvoyer un tableau, même s'il est vide\r\n\tif ontologyInfos == nil {\r\n\t\tontologyInfos = []OntologyInfo{}\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontologyInfos)\r\n}\r\n\r\n// SearchOntologies effectue une recherche dans les ontologies\r\nfunc (h *Handler) SearchOntologies(c *gin.Context) {\r\n\tquery := c.Query(\"q\")\r\n\tfileID := c.Query(\"file_id\") // Ajoutez cette ligne\r\n\tontologyID := c.Query(\"ontology_id\")\r\n\telementType := c.Query(\"type\")\r\n\tcontextSize := 5 // Valeur par défaut, vous pouvez la rendre configurable si nécessaire\r\n\r\n\tif query == \"\" {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Query parameter 'q' is required\"})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Searching ontologies with query: %s, fileID: %s\", query, fileID))\r\n\r\n\tresults, err := h.Search.Search(query, ontologyID, elementType, contextSize, fileID)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error during search: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"An error occurred during the search\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Log des résultats côté serveur\r\n\th.Logger.Info(fmt.Sprintf(\"Search results: %+v\", results))\r\n\r\n\t// Enrichir les résultats avec les métadonnées\r\n\tenrichedResults := make([]gin.H, len(results))\r\n\tfor i, result := range results {\r\n\t\telement, err := h.Storage.GetElement(result.ElementName)\r\n\t\tif err == nil \u0026\u0026 element != nil {\r\n\t\t\tontology, _ := h.Storage.GetOntology(result.OntologyID)\r\n\t\t\tvar sourceFile string\r\n\t\t\tvar resultFileID string\r\n\t\t\tvar sourceMetadata *models.SourceMetadata\r\n\t\t\tif ontology != nil \u0026\u0026 ontology.Source != nil {\r\n\t\t\t\tsourceMetadata = ontology.Source\r\n\t\t\t\t// Utiliser le fileID de la requête s'il est fourni, sinon chercher dans les contextes\r\n\t\t\t\tif fileID != \"\" {\r\n\t\t\t\t\tif fileInfo, exists := sourceMetadata.Files[fileID]; exists {\r\n\t\t\t\t\t\tresultFileID = fileID\r\n\t\t\t\t\t\tsourceFile = fileInfo.SourceFile\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Logique existante pour trouver le FileID\r\n\t\t\t\t\tfor _, context := range element.Contexts {\r\n\t\t\t\t\t\tif fileInfo, exists := sourceMetadata.Files[context.FileID]; exists {\r\n\t\t\t\t\t\t\tresultFileID = context.FileID\r\n\t\t\t\t\t\t\tsourceFile = fileInfo.SourceFile\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\th.Logger.Info(fmt.Sprintf(\"File info for %s: ID=%s, SourceFile=%s\", result.ElementName, resultFileID, sourceFile))\r\n\t\t\t}\r\n\t\t\tenrichedResults[i] = gin.H{\r\n\t\t\t\t\"ElementName\": result.ElementName,\r\n\t\t\t\t\"ElementType\": result.ElementType,\r\n\t\t\t\t\"Description\": result.Description,\r\n\t\t\t\t\"OntologyID\":  result.OntologyID,\r\n\t\t\t\t\"Contexts\":    element.Contexts,\r\n\t\t\t\t\"FileID\":      resultFileID,\r\n\t\t\t\t\"SourceFile\":  sourceFile,\r\n\t\t\t\t\"SourceMetadata\": gin.H{\r\n\t\t\t\t\t\"ontology_file\":   sourceMetadata.OntologyFile,\r\n\t\t\t\t\t\"processing_date\": sourceMetadata.ProcessingDate,\r\n\t\t\t\t\t\"files\":           sourceMetadata.Files,\r\n\t\t\t\t},\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tc.JSON(http.StatusOK, enrichedResults)\r\n}\r\n\r\n// ElementDetailsHandler récupère les détails d'un élément spécifique\r\nfunc (h *Handler) ElementDetailsHandler(c *gin.Context) {\r\n\telementName := c.Param(\"element_id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting details for element: %s\", elementName))\r\n\r\n\telement, err := h.Storage.GetElement(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting element details: %v\", err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": MsgResourceNotFound})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Si les contextes sont nuls, essayez de les récupérer séparément\r\n\tif element.Contexts == nil {\r\n\t\tcontexts, err := h.Storage.GetElementContexts(elementName)\r\n\t\tif err == nil {\r\n\t\t\telement.Contexts = contexts\r\n\t\t}\r\n\t}\r\n\tc.JSON(http.StatusOK, element)\r\n}\r\n\r\nfunc (h *Handler) LoadOntology(c *gin.Context) {\r\n\t// Fichier d'ontologie principal\r\n\tontologyFile, err := c.FormFile(\"ontologyFile\")\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No ontology file uploaded\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Fichier de métadonnées (obligatoire)\r\n\tmetadataFile, err := c.FormFile(\"metadataFile\")\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No metadata file uploaded\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Fichier de contexte (optionnel)\r\n\tvar contextTempFile string\r\n\tcontextFile, err := c.FormFile(\"contextFile\")\r\n\r\n\t// Sauvegarder temporairement les fichiers\r\n\tontologyTempFile := filepath.Join(os.TempDir(), ontologyFile.Filename)\r\n\tif err := c.SaveUploadedFile(ontologyFile, ontologyTempFile); err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save ontology file\"})\r\n\t\treturn\r\n\t}\r\n\tdefer os.Remove(ontologyTempFile)\r\n\r\n\tmetadataTempFile := filepath.Join(os.TempDir(), metadataFile.Filename)\r\n\tif err := c.SaveUploadedFile(metadataFile, metadataTempFile); err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save metadata file\"})\r\n\t\treturn\r\n\t}\r\n\tdefer os.Remove(metadataTempFile)\r\n\r\n\tif contextFile != nil {\r\n\t\tcontextTempFile = filepath.Join(os.TempDir(), contextFile.Filename)\r\n\t\tif err := c.SaveUploadedFile(contextFile, contextTempFile); err != nil {\r\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save context file\"})\r\n\t\t\treturn\r\n\t\t}\r\n\t\tdefer os.Remove(contextTempFile)\r\n\t}\r\n\r\n\t// Charger l'ontologie avec les métadonnées\r\n\terr = h.Storage.LoadOntologyFromFile(ontologyTempFile, contextTempFile, metadataTempFile)\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": fmt.Sprintf(\"Failed to load ontology: %v\", err)})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Ontology loaded successfully\"})\r\n}\r\n\r\n// GetElementRelations récupère les relations d'un élément spécifique\r\nfunc (h *Handler) GetElementRelations(c *gin.Context) {\r\n\th.Logger.Info(\"GetElementRelations endpoint called\")\r\n\r\n\t// Décoder le nom de l'élément depuis l'URL\r\n\tencodedElementName := c.Param(\"element_name\")\r\n\telementName, err := url.QueryUnescape(encodedElementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding element name: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid element name\"})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting relations for element: %s\", elementName))\r\n\r\n\trelations, err := h.Storage.GetElementRelations(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting element relations: %v\", err))\r\n\t\t// Retourner un tableau vide avec status 200 si aucune relation n'est trouvée\r\n\t\tc.JSON(http.StatusOK, []models.Relation{})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Found %d relations for element: %s\", len(relations), elementName))\r\n\tc.JSON(http.StatusOK, relations)\r\n}\r\n\r\nfunc (h *Handler) GetElementContexts(c *gin.Context) {\r\n\telementName := c.Param(\"element_name\")\r\n\tcontexts, err := h.Storage.GetElementContexts(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting contexts for element %s: %v\", elementName, err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Element not found\"})\r\n\t\treturn\r\n\t}\r\n\tc.JSON(http.StatusOK, contexts)\r\n}\r\n\r\n// Ajouter un endpoint pour récupérer les métadonnées d'une ontologie\r\nfunc (h *Handler) GetOntologyMetadata(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\tontology, err := h.Storage.GetOntology(id)\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Ontology not found\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tif ontology.Source == nil {\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"No metadata available for this ontology\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology.Source)\r\n}\r\n\r\n// ViewSourceFile gère l'affichage des fichiers source\r\nfunc (h *Handler) ViewSourceFile(c *gin.Context) {\r\n\t// Récupérer le chemin du fichier depuis les query params\r\n\tfilePath := c.Query(\"path\")\r\n\tif filePath == \"\" {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No file path provided\"}) // gin.H pour format JSON cohérent\r\n\t\treturn\r\n\t}\r\n\r\n\t// Vérifier que le fichier existe\r\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"File not found\"}) // gin.H pour format JSON cohérent\r\n\t\treturn\r\n\t}\r\n\r\n\t// Déterminer le type MIME\r\n\text := strings.ToLower(filepath.Ext(filePath))\r\n\tvar contentType string\r\n\tswitch ext {\r\n\tcase \".pdf\":\r\n\t\tcontentType = \"application/pdf\"\r\n\tcase \".md\":\r\n\t\tcontentType = \"text/markdown\"\r\n\tcase \".txt\":\r\n\t\tcontentType = \"text/plain\"\r\n\tcase \".html\":\r\n\t\tcontentType = \"text/html\"\r\n\tdefault:\r\n\t\tcontentType = \"application/octet-stream\"\r\n\t}\r\n\r\n\t// Pour les fichiers markdown, convertir en HTML si nécessaire\r\n\tif ext == \".md\" {\r\n\t\tfile, err := os.ReadFile(filePath)\r\n\t\tif err != nil {\r\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to read file\"})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Si vous voulez ajouter une conversion Markdown vers HTML ici\r\n\t\t// Vous pouvez utiliser une bibliothèque comme blackfriday\r\n\r\n\t\tc.Header(\"Content-Type\", \"text/html\")\r\n\t\tc.Header(\"Content-Disposition\", \"inline; filename=\"+filepath.Base(filePath))\r\n\t\tc.String(http.StatusOK, `\r\n            \u003c!DOCTYPE html\u003e\r\n            \u003chtml\u003e\r\n            \u003chead\u003e\r\n                \u003cmeta charset=\"UTF-8\"\u003e\r\n                \u003cstyle\u003e\r\n                    body { \r\n                        font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\r\n                        line-height: 1.6;\r\n                        max-width: 800px;\r\n                        margin: 0 auto;\r\n                        padding: 20px;\r\n                    }\r\n                    pre {\r\n                        background: #f5f5f5;\r\n                        padding: 15px;\r\n                        border-radius: 5px;\r\n                    }\r\n                \u003c/style\u003e\r\n            \u003c/head\u003e\r\n            \u003cbody\u003e\r\n                \u003cpre\u003e%s\u003c/pre\u003e\r\n            \u003c/body\u003e\r\n            \u003c/html\u003e\r\n        `, string(file))\r\n\t\treturn\r\n\t}\r\n\r\n\t// Pour tous les autres types de fichiers\r\n\tc.Header(\"Content-Type\", contentType)\r\n\tc.Header(\"Content-Disposition\", \"inline; filename=\"+filepath.Base(filePath))\r\n\tc.File(filePath)\r\n}\r\n\r\n// GetOntologyFiles récupère la liste des fichiers de toutes les ontologies\r\nfunc (h *Handler) GetOntologyFiles(c *gin.Context) {\r\n\th.Logger.Info(\"Getting list of ontology files\")\r\n\r\n\tontologies := h.Storage.ListOntologies()\r\n\tfileList := make(map[string]string)\r\n\r\n\tfor _, onto := range ontologies {\r\n\t\tif onto.Source != nil {\r\n\t\t\tfor fileID, fileInfo := range onto.Source.Files {\r\n\t\t\t\tfileList[fileID] = fileInfo.SourceFile\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, fileList)\r\n}\r\n",
    "size": 14449,
    "modTime": "2024-11-18T12:56:13.1476629+01:00",
    "path": "internal\\api\\handlers.go"
  },
  {
    "name": "handlers_test.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"net/http/httptest\"\r\n\t\"net/url\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc setupTestHandler() (*Handler, *gin.Engine) {\r\n\tstorage := storage.NewMemoryStorage()\r\n\tlogger, _ := logger.NewLogger(logger.INFO, \"test_logs\")\r\n\tsearchEngine := search.NewSearchEngine(storage, logger)\r\n\thandler := NewHandler(storage, logger, searchEngine)\r\n\r\n\tgin.SetMode(gin.TestMode)\r\n\trouter := gin.New()\r\n\treturn handler, router\r\n}\r\n\r\nfunc TestGetOntology(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Add a test ontology\r\n\ttestOntology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\t// Test successful retrieval\r\n\trouter.GET(\"/ontologies/:id\", h.GetOntology)\r\n\treq, _ := http.NewRequest(\"GET\", \"/ontologies/test1\", nil)\r\n\tw := httptest.NewRecorder()\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedOntology)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedOntology.ID != testOntology.ID {\r\n\t\tt.Errorf(\"Expected ontology ID %s, got %s\", testOntology.ID, returnedOntology.ID)\r\n\t}\r\n\r\n\t// Test non-existent ontology\r\n\treq, _ = http.NewRequest(\"GET\", \"/ontologies/nonexistent\", nil)\r\n\tw = httptest.NewRecorder()\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusNotFound {\r\n\t\tt.Errorf(\"Expected status 404, got %d\", w.Code)\r\n\t}\r\n}\r\n\r\nfunc TestAddOntology(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\trouter.POST(\"/ontologies\", h.AddOntology)\r\n\r\n\tnewOntology := models.Ontology{Name: \"New Test Ontology\"}\r\n\tbody, _ := json.Marshal(newOntology)\r\n\treq, _ := http.NewRequest(\"POST\", \"/ontologies\", bytes.NewBuffer(body))\r\n\treq.Header.Set(\"Content-Type\", \"application/json\")\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusCreated {\r\n\t\tt.Errorf(\"Expected status 201, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedOntology)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedOntology.Name != newOntology.Name {\r\n\t\tt.Errorf(\"Expected ontology name %s, got %s\", newOntology.Name, returnedOntology.Name)\r\n\t}\r\n}\r\n\r\nfunc TestSearchOntologies(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\trouter.GET(\"/search\", h.SearchOntologies)\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/search?q=Test\", nil)\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar results []search.SearchResult\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026results)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\r\n\t// Add more specific assertions based on your expected search results\r\n}\r\n\r\nfunc TestElementDetailsHandler(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Add a test ontology with an element\r\n\ttestElement := \u0026models.OntologyElement{\r\n\t\tName:        \"Test Element\",\r\n\t\tType:        \"TestType\",\r\n\t\tDescription: \"This is a test element\",\r\n\t}\r\n\ttestOntology := \u0026models.Ontology{\r\n\t\tID:       \"test1\",\r\n\t\tName:     \"Test Ontology\",\r\n\t\tElements: []*models.OntologyElement{testElement},\r\n\t}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\trouter.GET(\"/elements/:element_id\", h.ElementDetailsHandler)\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/elements/Test Element\", nil)\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedElement models.OntologyElement\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedElement)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedElement.Name != \"Test Element\" {\r\n\t\tt.Errorf(\"Expected element name 'Test Element', got '%s'\", returnedElement.Name)\r\n\t}\r\n}\r\n\r\n// Ajouter après les tests existants...\r\n\r\nfunc TestViewSourceFile(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Configurer la route pour le test\r\n\trouter.GET(\"/view-source\", h.ViewSourceFile)\r\n\r\n\t// Créer quelques fichiers de test temporaires\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// Fichier texte\r\n\ttxtContent := \"Test content\"\r\n\ttxtPath := filepath.Join(tmpDir, \"test.txt\")\r\n\tif err := os.WriteFile(txtPath, []byte(txtContent), 0644); err != nil {\r\n\t\tt.Fatalf(\"Failed to create test text file: %v\", err)\r\n\t}\r\n\r\n\t// Fichier Markdown\r\n\tmdContent := \"# Test Title\\nTest content\"\r\n\tmdPath := filepath.Join(tmpDir, \"test.md\")\r\n\tif err := os.WriteFile(mdPath, []byte(mdContent), 0644); err != nil {\r\n\t\tt.Fatalf(\"Failed to create test markdown file: %v\", err)\r\n\t}\r\n\r\n\ttests := []struct {\r\n\t\tname         string\r\n\t\tpath         string\r\n\t\texpectedCode int\r\n\t\texpectedType string\r\n\t\texpectedBody map[string]string // Changé pour correspondre à gin.H\r\n\t}{\r\n\t\t{\r\n\t\t\tname:         \"View Text File\",\r\n\t\t\tpath:         txtPath,\r\n\t\t\texpectedCode: http.StatusOK,\r\n\t\t\texpectedType: \"text/plain\",\r\n\t\t\texpectedBody: nil, // pas de body JSON pour les fichiers\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:         \"View Markdown File\",\r\n\t\t\tpath:         mdPath,\r\n\t\t\texpectedCode: http.StatusOK,\r\n\t\t\texpectedType: \"text/html\",\r\n\t\t\texpectedBody: nil, // pas de body JSON pour les fichiers\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:         \"File Not Found\",\r\n\t\t\tpath:         filepath.Join(tmpDir, \"nonexistent.txt\"),\r\n\t\t\texpectedCode: http.StatusNotFound,\r\n\t\t\texpectedType: \"application/json\",\r\n\t\t\texpectedBody: map[string]string{\"error\": \"File not found\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:         \"No Path Provided\",\r\n\t\t\tpath:         \"\",\r\n\t\t\texpectedCode: http.StatusBadRequest,\r\n\t\t\texpectedType: \"application/json\",\r\n\t\t\texpectedBody: map[string]string{\"error\": \"No file path provided\"},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\t// Construire la requête\r\n\t\t\turlPath := \"/view-source\"\r\n\t\t\tif tt.path != \"\" {\r\n\t\t\t\turlPath = fmt.Sprintf(\"/view-source?path=%s\", url.QueryEscape(tt.path)) // Correction ici\r\n\t\t\t}\r\n\r\n\t\t\treq, _ := http.NewRequest(\"GET\", urlPath, nil)\r\n\t\t\tw := httptest.NewRecorder()\r\n\r\n\t\t\trouter.ServeHTTP(w, req)\r\n\r\n\t\t\t// Vérifier le code de statut\r\n\t\t\tif w.Code != tt.expectedCode {\r\n\t\t\t\tt.Errorf(\"Expected status %d, got %d\", tt.expectedCode, w.Code)\r\n\t\t\t}\r\n\r\n\t\t\t// Vérifier le type de contenu\r\n\t\t\tcontentType := w.Header().Get(\"Content-Type\")\r\n\t\t\tif !strings.Contains(contentType, tt.expectedType) {\r\n\t\t\t\tt.Errorf(\"Expected content type %s, got %s\", tt.expectedType, contentType)\r\n\t\t\t}\r\n\r\n\t\t\t// Vérifier le contenu selon le type de réponse\r\n\t\t\tswitch tt.expectedType {\r\n\t\t\tcase \"application/json\":\r\n\t\t\t\tvar response map[string]string\r\n\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), \u0026response); err != nil {\r\n\t\t\t\t\tt.Fatalf(\"Failed to unmarshal error response: %v\", err)\r\n\t\t\t\t}\r\n\t\t\t\tif response[\"error\"] != tt.expectedBody[\"error\"] {\r\n\t\t\t\t\tt.Errorf(\"Expected error message %v, got %v\", tt.expectedBody[\"error\"], response[\"error\"])\r\n\t\t\t\t}\r\n\t\t\tcase \"text/html\":\r\n\t\t\t\t// Pour le markdown, vérifier que le contenu HTML est non vide\r\n\t\t\t\tif w.Body.Len() == 0 {\r\n\t\t\t\t\tt.Error(\"Expected non-empty HTML content\")\r\n\t\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t// Pour les autres types, vérifier que le contenu n'est pas vide\r\n\t\t\t\tif w.Body.Len() == 0 {\r\n\t\t\t\t\tt.Error(\"Expected non-empty content\")\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Vérifier l'en-tête Content-Disposition pour les fichiers\r\n\t\t\tif tt.expectedCode == http.StatusOK {\r\n\t\t\t\tcontentDisposition := w.Header().Get(\"Content-Disposition\")\r\n\t\t\t\texpectedFilename := filepath.Base(tt.path)\r\n\t\t\t\texpected := fmt.Sprintf(\"inline; filename=%s\", expectedFilename)\r\n\t\t\t\tif contentDisposition != expected {\r\n\t\t\t\t\tt.Errorf(\"Expected Content-Disposition %s, got %s\", expected, contentDisposition)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n",
    "size": 8088,
    "modTime": "2024-10-30T22:47:03.7831628+01:00",
    "path": "internal\\api\\handlers_test.go"
  },
  {
    "name": "router.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc SetupRoutes(router *gin.RouterGroup, storage *storage.MemoryStorage, logger *logger.Logger) {\r\n\tsearchEngine := search.NewSearchEngine(storage, logger)\r\n\thandler := NewHandler(storage, logger, searchEngine)\r\n\r\n\trouter.GET(\"/ontologies\", handler.ListOntologies)\r\n\trouter.POST(\"/ontologies\", handler.AddOntology)\r\n\trouter.GET(\"/ontologies/:id\", handler.GetOntology)\r\n\trouter.PUT(\"/ontologies/:id\", handler.UpdateOntology)\r\n\trouter.DELETE(\"/ontologies/:id\", handler.DeleteOntology)\r\n\trouter.POST(\"/ontologies/load\", handler.LoadOntology)\r\n\trouter.GET(\"/ontologies/files\", handler.GetOntologyFiles)\r\n\trouter.GET(\"/ontologies/:id/metadata\", handler.GetOntologyMetadata)\r\n\r\n\trouter.GET(\"/search\", handler.SearchOntologies)\r\n\r\n\trouter.GET(\"/elements/details/:element_id\", handler.ElementDetailsHandler)\r\n\trouter.GET(\"/elements/relations/:element_name\", handler.GetElementRelations)\r\n\r\n\trouter.GET(\"/view-source\", handler.ViewSourceFile)\r\n\r\n}\r\n",
    "size": 1169,
    "modTime": "2024-11-18T12:10:23.9418905+01:00",
    "path": "internal\\api\\router.go"
  },
  {
    "name": "config.go",
    "content": "package config\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"gopkg.in/yaml.v2\"\r\n)\r\n\r\n// Config holds the application configuration\r\ntype Config struct {\r\n\tServer struct {\r\n\t\tPort int    `yaml:\"port\"`\r\n\t\tHost string `yaml:\"host\"`\r\n\t\tMode string `yaml:\"mode\"` // Ajout du champ Mode\r\n\t} `yaml:\"server\"`\r\n\tLogging struct {\r\n\t\tLevel     string `yaml:\"level\"`\r\n\t\tDirectory string `yaml:\"directory\"`\r\n\t} `yaml:\"logging\"`\r\n\tStorage struct {\r\n\t\tTempDirectory string `yaml:\"temp_directory\"`\r\n\t} `yaml:\"storage\"`\r\n}\r\n\r\n// LoadConfig reads the config file and returns a Config struct\r\nfunc LoadConfig(filename string) (*Config, error) {\r\n\tconfig := \u0026Config{}\r\n\r\n\t// Read the config file\r\n\tdata, err := os.ReadFile(filename)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error reading config file: %w\", err)\r\n\t}\r\n\r\n\t// Parse the YAML\r\n\terr = yaml.Unmarshal(data, config)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error parsing config YAML: %w\", err)\r\n\t}\r\n\r\n\treturn config, nil\r\n}\r\n",
    "size": 957,
    "modTime": "2024-10-30T22:47:03.7896749+01:00",
    "path": "internal\\config\\config.go"
  },
  {
    "name": "logger.go",
    "content": "package logger\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"runtime\"\r\n\t\"time\"\r\n)\r\n\r\n// LogLevel represents the severity of a log message\r\ntype LogLevel int\r\n\r\nconst (\r\n\t// DEBUG level\r\n\tDEBUG LogLevel = iota\r\n\t// INFO level\r\n\tINFO\r\n\t// WARNING level\r\n\tWARNING\r\n\t// ERROR level\r\n\tERROR\r\n)\r\n\r\nvar levelStrings = map[LogLevel]string{\r\n\tDEBUG:   \"DEBUG\",\r\n\tINFO:    \"INFO\",\r\n\tWARNING: \"WARNING\",\r\n\tERROR:   \"ERROR\",\r\n}\r\n\r\n// Logger represents a custom logger\r\ntype Logger struct {\r\n\tlevel     LogLevel\r\n\tlogFile   *os.File\r\n\tlogger    *log.Logger\r\n\tdirectory string\r\n}\r\n\r\n// NewLogger creates a new Logger instance\r\nfunc NewLogger(level LogLevel, directory string) (*Logger, error) {\r\n\tlogger := \u0026Logger{\r\n\t\tlevel:     level,\r\n\t\tdirectory: directory,\r\n\t}\r\n\r\n\t// Ensure the log directory exists\r\n\tif err := os.MkdirAll(directory, 0755); err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to create log directory: %w\", err)\r\n\t}\r\n\r\n\terr := logger.rotate()\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error creating logger: %w\", err)\r\n\t}\r\n\treturn logger, nil\r\n}\r\n\r\n// rotate creates a new log file for the current day\r\nfunc (l *Logger) rotate() error {\r\n\tif l.logFile != nil {\r\n\t\tl.logFile.Close()\r\n\t}\r\n\r\n\tnow := time.Now()\r\n\tfilename := filepath.Join(l.directory, fmt.Sprintf(\"%s.log\", now.Format(\"2006-01-02\")))\r\n\r\n\tfile, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"error opening log file: %w\", err)\r\n\t}\r\n\r\n\tl.logFile = file\r\n\tl.logger = log.New(file, \"\", 0)\r\n\treturn nil\r\n}\r\n\r\n// log writes a log message with the given level\r\nfunc (l *Logger) log(level LogLevel, message string) {\r\n\tif level \u003c l.level {\r\n\t\treturn\r\n\t}\r\n\r\n\tnow := time.Now()\r\n\tif now.Day() != time.Now().Day() {\r\n\t\terr := l.rotate()\r\n\t\tif err != nil {\r\n\t\t\tfmt.Printf(\"Error rotating log file: %v\\n\", err)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\r\n\t_, file, line, _ := runtime.Caller(2)\r\n\tlogMessage := fmt.Sprintf(\"[%s] [%s] [%s:%d] %s\",\r\n\t\tlevelStrings[level],\r\n\t\tnow.Format(\"2006-01-02 15:04:05\"),\r\n\t\tfilepath.Base(file),\r\n\t\tline,\r\n\t\tmessage)\r\n\r\n\tl.logger.Println(logMessage)\r\n\tfmt.Printf(\"\\n%s\", logMessage)\r\n}\r\n\r\n// Debug logs a debug message\r\nfunc (l *Logger) Debug(message string) {\r\n\tl.log(DEBUG, message)\r\n}\r\n\r\n// Info logs an info message\r\nfunc (l *Logger) Info(message string) {\r\n\tl.log(INFO, message)\r\n}\r\n\r\n// Warning logs a warning message\r\nfunc (l *Logger) Warning(message string) {\r\n\tl.log(WARNING, message)\r\n}\r\n\r\n// Error logs an error message\r\nfunc (l *Logger) Error(message string) {\r\n\tl.log(ERROR, message)\r\n}\r\n",
    "size": 2547,
    "modTime": "2024-10-30T22:47:03.7916747+01:00",
    "path": "internal\\logger\\logger.go"
  },
  {
    "name": "element.go",
    "content": "package models\r\n\r\n// JSONContext représente le contexte d'un élément\r\ntype JSONContext struct {\r\n\tPosition     int      `json:\"position\"`\r\n\tFileID       string   `json:\"file_id\"`\r\n\tFilePosition int      `json:\"file_position\"`\r\n\tBefore       []string `json:\"before\"`\r\n\tAfter        []string `json:\"after\"`\r\n\tElement      string   `json:\"element\"`\r\n\tLength       int      `json:\"length\"`\r\n\tStartOffset  int      `json:\"-\"`\r\n\tEndOffset    int      `json:\"-\"`\r\n}\r\n",
    "size": 463,
    "modTime": "2024-11-17T23:35:12.7839033+01:00",
    "path": "internal\\models\\element.go"
  },
  {
    "name": "ontology.go",
    "content": "package models\r\n\r\nimport (\r\n\t\"time\"\r\n)\r\n\r\n// OntologyElement représente un élément individuel dans l'ontologie\r\ntype OntologyElement struct {\r\n\tName         string\r\n\tOriginalName string\r\n\tType         string\r\n\tPositions    []int\r\n\tDescription  string\r\n\tContexts     []JSONContext\r\n}\r\n\r\n// Relation représente une relation entre deux éléments de l'ontologie\r\ntype Relation struct {\r\n\tSource      string\r\n\tType        string\r\n\tTarget      string\r\n\tDescription string\r\n}\r\n\r\n// SourceMetadata représente les métadonnées du fichier source\r\ntype SourceMetadata struct {\r\n\tOntologyFile   string              `json:\"ontology_file\"`\r\n\tProcessingDate time.Time           `json:\"processing_date\"`\r\n\tFiles          map[string]FileInfo `json:\"files\"`\r\n}\r\n\r\ntype FileInfo struct {\r\n\tID         string    `json:\"id\"`\r\n\tSourceFile string    `json:\"source_file\"`\r\n\tDirectory  string    `json:\"directory\"`\r\n\tFileDate   time.Time `json:\"file_date\"`\r\n\tSHA256Hash string    `json:\"sha256_hash\"`\r\n}\r\n\r\n// Ontology représente une ontologie complète\r\ntype Ontology struct {\r\n\tID         string\r\n\tName       string\r\n\tFilename   string\r\n\tFormat     string\r\n\tSize       int64\r\n\tSHA256     string\r\n\tImportedAt time.Time\r\n\tElements   []*OntologyElement\r\n\tRelations  []*Relation\r\n\tSource     *SourceMetadata\r\n}\r\n",
    "size": 1293,
    "modTime": "2024-11-17T23:35:24.1124149+01:00",
    "path": "internal\\models\\ontology.go"
  },
  {
    "name": "ontology_test.go",
    "content": "package models\r\n\r\nimport (\r\n\t\"testing\"\r\n\t\"time\"\r\n)\r\n\r\nfunc TestOntologyStructure(t *testing.T) {\r\n\t// Créer une nouvelle ontologie\r\n\tontology := Ontology{\r\n\t\tID:         \"test-ontology\",\r\n\t\tName:       \"Test Ontology\",\r\n\t\tFilename:   \"test.tsv\",\r\n\t\tFormat:     \"TSV\",\r\n\t\tSize:       1024,\r\n\t\tSHA256:     \"abcdef1234567890\",\r\n\t\tImportedAt: time.Now(),\r\n\t\tElements: []*OntologyElement{\r\n\t\t\t{\r\n\t\t\t\tName:        \"TestElement\",\r\n\t\t\t\tType:        \"Concept\",\r\n\t\t\t\tPositions:   []int{1, 2, 3},\r\n\t\t\t\tDescription: \"This is a test element\",\r\n\t\t\t},\r\n\t\t},\r\n\t\tRelations: []*Relation{\r\n\t\t\t{\r\n\t\t\t\tSource:      \"TestElement\",\r\n\t\t\t\tType:        \"isA\",\r\n\t\t\t\tTarget:      \"ParentElement\",\r\n\t\t\t\tDescription: \"Test relation\",\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\t// Vérifier que les champs sont correctement définis\r\n\tif ontology.ID != \"test-ontology\" {\r\n\t\tt.Errorf(\"Expected ID to be 'test-ontology', got '%s'\", ontology.ID)\r\n\t}\r\n\r\n\tif len(ontology.Elements) != 1 {\r\n\t\tt.Errorf(\"Expected 1 element, got %d\", len(ontology.Elements))\r\n\t}\r\n\r\n\tif len(ontology.Relations) != 1 {\r\n\t\tt.Errorf(\"Expected 1 relation, got %d\", len(ontology.Relations))\r\n\t}\r\n}\r\n\r\nfunc TestJSONContextStructure(t *testing.T) {\r\n\t// Tester la structure JSONContext\r\n\tcontext := JSONContext{\r\n\t\tPosition: 1,\r\n\t\tBefore:   []string{\"before\"},\r\n\t\tAfter:    []string{\"after\"},\r\n\t\tElement:  \"TestElement\",\r\n\t\tLength:   1,\r\n\t}\r\n\r\n\tif context.Element != \"TestElement\" {\r\n\t\tt.Errorf(\"Expected Element to be 'TestElement', got '%s'\", context.Element)\r\n\t}\r\n}\r\n",
    "size": 1485,
    "modTime": "2024-10-30T22:47:03.796675+01:00",
    "path": "internal\\models\\ontology_test.go"
  },
  {
    "name": "json.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n\t\"sort\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\n// ParseJSON parses a JSON file and returns a slice of JSONContext structures\r\nfunc ParseJSON(filename string) ([]models.JSONContext, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse JSON file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tvar contexts []models.JSONContext\r\n\tdecoder := json.NewDecoder(file)\r\n\r\n\terr = decoder.Decode(\u0026contexts)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to decode JSON: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to decode JSON: %w\", err)\r\n\t}\r\n\r\n\t// Trier les contextes par position\r\n\tsort.Slice(contexts, func(i, j int) bool {\r\n\t\treturn contexts[i].Position \u003c contexts[j].Position\r\n\t})\r\n\r\n\t// Reconstruire les contextes complets\r\n\tfor i := range contexts {\r\n\t\tctx := \u0026contexts[i]\r\n\t\tctx.StartOffset = ctx.FilePosition - len(ctx.Before)\r\n\t\tctx.EndOffset = ctx.FilePosition + ctx.Length + len(ctx.After) - 1\r\n\r\n\t\t// Compléter le contexte avec les éléments adjacents si nécessaire\r\n\t\tif i \u003e 0 {\r\n\t\t\tprevCtx := contexts[i-1]\r\n\t\t\tmissingBefore := prevCtx.EndOffset + 1 - ctx.StartOffset\r\n\t\t\tif missingBefore \u003e 0 \u0026\u0026 prevCtx.FileID == ctx.FileID {\r\n\t\t\t\tctx.Before = append(prevCtx.After[len(prevCtx.After)-missingBefore:], ctx.Before...)\r\n\t\t\t\tctx.StartOffset = prevCtx.EndOffset + 1\r\n\t\t\t}\r\n\t\t}\r\n\t\tif i \u003c len(contexts)-1 {\r\n\t\t\tnextCtx := contexts[i+1]\r\n\t\t\tmissingAfter := nextCtx.StartOffset - ctx.EndOffset - 1\r\n\t\t\tif missingAfter \u003e 0 \u0026\u0026 nextCtx.FileID == ctx.FileID {\r\n\t\t\t\tctx.After = append(ctx.After, nextCtx.Before[:missingAfter]...)\r\n\t\t\t\tctx.EndOffset = nextCtx.StartOffset - 1\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlog.Info(fmt.Sprintf(\"Context for '%s': FileID=%s, FilePosition=%d, StartOffset=%d, EndOffset=%d\",\r\n\t\t\tctx.Element, ctx.FileID, ctx.FilePosition, ctx.StartOffset, ctx.EndOffset))\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Parsed %d contexts from JSON file\", len(contexts)))\r\n\tfor i, ctx := range contexts {\r\n\t\tlog.Info(fmt.Sprintf(\"Context %d: Element=%s, FileID=%s, FilePosition=%d, StartOffset=%d, EndOffset=%d\",\r\n\t\t\ti, ctx.Element, ctx.FileID, ctx.FilePosition, ctx.StartOffset, ctx.EndOffset))\r\n\t}\r\n\r\n\treturn contexts, nil\r\n}\r\n",
    "size": 2362,
    "modTime": "2024-11-17T23:38:09.6780534+01:00",
    "path": "internal\\parser\\json.go"
  },
  {
    "name": "json_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseJSON(t *testing.T) {\r\n\t// Create a temporary JSON file for testing\r\n\ttestContexts := []models.JSONContext{\r\n\t\t{\r\n\t\t\tPosition: 1,\r\n\t\t\tBefore:   []string{\"La\"},\r\n\t\t\tAfter:    []string{\"juridique\", \"sert\", \"de\", \"premier\", \"plan.\"},\r\n\t\t\tElement:  \"Qualification_Juridique\",\r\n\t\t\tLength:   1,\r\n\t\t},\r\n\t\t{\r\n\t\t\tPosition: 8,\r\n\t\t\tBefore:   []string{\"La\", \"qualification\", \"juridique\", \"sert\", \"de\", \"premier\", \"plan.\", \"Dans\"},\r\n\t\t\tAfter:    []string{\"cas\", \"des\", \"internationales,\", \"le\", \"Conseil\"},\r\n\t\t\tElement:  \"Joueuse_Internationale\",\r\n\t\t\tLength:   1,\r\n\t\t},\r\n\t}\r\n\r\n\tcontent, err := json.Marshal(testContexts)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to marshal test data: %v\", err)\r\n\t}\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.json\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write(content); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Test the ParseJSON function\r\n\tcontexts, err := ParseJSON(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseJSON returned an error: %v\", err)\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(contexts, testContexts) {\r\n\t\tt.Errorf(\"ParseJSON returned unexpected result. Got %v, want %v\", contexts, testContexts)\r\n\t}\r\n}\r\n",
    "size": 1538,
    "modTime": "2024-10-30T22:47:03.7996749+01:00",
    "path": "internal\\parser\\json_test.go"
  },
  {
    "name": "owl.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/knakk/rdf\"\r\n)\r\n\r\n// ParseOWL parses an OWL file and returns slices of OntologyElement and Relation\r\nfunc ParseOWL(filename string) ([]models.OntologyElement, []models.Relation, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse OWL file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tdecoder := rdf.NewTripleDecoder(file, rdf.RDFXML)\r\n\r\n\telements := make(map[string]*models.OntologyElement)\r\n\trelations := make(map[string]*models.Relation)\r\n\r\n\tfor triple, err := decoder.Decode(); err == nil; triple, err = decoder.Decode() {\r\n\t\tsubj := triple.Subj.String()\r\n\t\tpred := triple.Pred.String()\r\n\t\tobj := triple.Obj.String()\r\n\r\n\t\tswitch pred {\r\n\t\tcase \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\":\r\n\t\t\tif obj == \"http://www.w3.org/2002/07/owl#Class\" {\r\n\t\t\t\tif _, exists := elements[subj]; !exists {\r\n\t\t\t\t\telements[subj] = \u0026models.OntologyElement{Name: subj}\r\n\t\t\t\t}\r\n\t\t\t} else if obj == \"http://www.w3.org/2002/07/owl#ObjectProperty\" {\r\n\t\t\t\tif _, exists := relations[subj]; !exists {\r\n\t\t\t\t\trelations[subj] = \u0026models.Relation{Type: subj}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#label\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Name = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#comment\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Description = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#domain\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Source = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#range\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Target = obj\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlog.Info(fmt.Sprintf(\"Parsed triple: %s -\u003e %s -\u003e %s\", subj, pred, obj))\r\n\t}\r\n\r\n\t// Convert maps to slices\r\n\telementSlice := make([]models.OntologyElement, 0, len(elements))\r\n\tfor _, elem := range elements {\r\n\t\telementSlice = append(elementSlice, *elem)\r\n\t}\r\n\trelationSlice := make([]models.Relation, 0, len(relations))\r\n\tfor _, rel := range relations {\r\n\t\trelationSlice = append(relationSlice, *rel)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing OWL file. Found %d elements and %d relations.\", len(elementSlice), len(relationSlice)))\r\n\treturn elementSlice, relationSlice, nil\r\n}\r\n",
    "size": 2455,
    "modTime": "2024-10-30T22:47:03.8026745+01:00",
    "path": "internal\\parser\\owl.go"
  },
  {
    "name": "owl_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestParseOWL(t *testing.T) {\r\n\t// Créer un fichier OWL temporaire pour le test\r\n\tcontent := `\u003c?xml version=\"1.0\"?\u003e\r\n\u003crdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n         xmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\r\n         xmlns:owl=\"http://www.w3.org/2002/07/owl#\"\u003e\r\n    \u003cowl:Class rdf:about=\"http://example.org/Element1\"\u003e\r\n        \u003crdfs:label\u003eElement1\u003c/rdfs:label\u003e\r\n        \u003crdfs:comment\u003eDescription1\u003c/rdfs:comment\u003e\r\n    \u003c/owl:Class\u003e\r\n    \u003cowl:ObjectProperty rdf:about=\"http://example.org/Relation1\"\u003e\r\n        \u003crdfs:domain rdf:resource=\"http://example.org/Element1\"/\u003e\r\n        \u003crdfs:range rdf:resource=\"http://example.org/Element2\"/\u003e\r\n    \u003c/owl:ObjectProperty\u003e\r\n\u003c/rdf:RDF\u003e`\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.owl\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Tester la fonction ParseOWL\r\n\telements, relations, err := ParseOWL(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseOWL returned an error: %v\", err)\r\n\t}\r\n\t// Vérifier les éléments\r\n\tif len(elements) != 1 {\r\n\t\tt.Errorf(\"Expected 1 element, got %d\", len(elements))\r\n\t} else if elements[0].Name != \"Element1\" || elements[0].Description != \"Description1\" {\r\n\t\tt.Errorf(\"Unexpected element: %v\", elements[0])\r\n\t}\r\n\r\n\t// Vérifier les relations\r\n\tif len(relations) != 1 {\r\n\t\tt.Errorf(\"Expected 1 relation, got %d\", len(relations))\r\n\t} else if relations[0].Type != \"http://example.org/Relation1\" ||\r\n\t\trelations[0].Source != \"http://example.org/Element1\" ||\r\n\t\trelations[0].Target != \"http://example.org/Element2\" {\r\n\t\tt.Errorf(\"Unexpected relation: %v\", relations[0])\r\n\t}\r\n}\r\n",
    "size": 1949,
    "modTime": "2024-10-30T22:47:03.8036745+01:00",
    "path": "internal\\parser\\owl_test.go"
  },
  {
    "name": "rdf.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/knakk/rdf\"\r\n)\r\n\r\n// ParseRDF parses an RDF file and returns slices of OntologyElement and Relation\r\nfunc ParseRDF(filename string) ([]models.OntologyElement, []models.Relation, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse RDF file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tdecoder := rdf.NewTripleDecoder(file, rdf.RDFXML)\r\n\r\n\telements := make(map[string]*models.OntologyElement)\r\n\trelations := make(map[string]*models.Relation)\r\n\r\n\tfor triple, err := decoder.Decode(); err == nil; triple, err = decoder.Decode() {\r\n\t\tsubj := triple.Subj.String()\r\n\t\tpred := triple.Pred.String()\r\n\t\tobj := triple.Obj.String()\r\n\r\n\t\tswitch pred {\r\n\t\tcase \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\":\r\n\t\t\tif obj != \"http://www.w3.org/1999/02/22-rdf-syntax-ns#Property\" {\r\n\t\t\t\tif _, exists := elements[subj]; !exists {\r\n\t\t\t\t\telements[subj] = \u0026models.OntologyElement{Name: subj, Type: obj}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif _, exists := relations[subj]; !exists {\r\n\t\t\t\t\trelations[subj] = \u0026models.Relation{Type: subj}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#label\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Name = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#comment\":\r\n\t\t\tif elem, exists := elements[subj]; exists {\r\n\t\t\t\telem.Description = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#domain\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Source = obj\r\n\t\t\t}\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#range\":\r\n\t\t\tif rel, exists := relations[subj]; exists {\r\n\t\t\t\trel.Target = obj\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlog.Info(fmt.Sprintf(\"Parsed triple: %s -\u003e %s -\u003e %s\", subj, pred, obj))\r\n\t}\r\n\r\n\t// Convert maps to slices\r\n\telementSlice := make([]models.OntologyElement, 0, len(elements))\r\n\tfor _, elem := range elements {\r\n\t\telementSlice = append(elementSlice, *elem)\r\n\t}\r\n\trelationSlice := make([]models.Relation, 0, len(relations))\r\n\tfor _, rel := range relations {\r\n\t\trelationSlice = append(relationSlice, *rel)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing RDF file. Found %d elements and %d relations.\", len(elementSlice), len(relationSlice)))\r\n\treturn elementSlice, relationSlice, nil\r\n}\r\n",
    "size": 2425,
    "modTime": "2024-10-30T22:47:03.8046746+01:00",
    "path": "internal\\parser\\rdf.go"
  },
  {
    "name": "rdf_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestParseRDF(t *testing.T) {\r\n\t// Créer un fichier RDF temporaire pour le test\r\n\tcontent := `\u003c?xml version=\"1.0\"?\u003e\r\n\u003crdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n         xmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\u003e\r\n    \u003crdf:Description rdf:about=\"http://example.org/Element1\"\u003e\r\n        \u003crdf:type rdf:resource=\"http://example.org/Type1\"/\u003e\r\n        \u003crdfs:label\u003eElement1\u003c/rdfs:label\u003e\r\n        \u003crdfs:comment\u003eDescription1\u003c/rdfs:comment\u003e\r\n    \u003c/rdf:Description\u003e\r\n    \u003crdf:Description rdf:about=\"http://example.org/Relation1\"\u003e\r\n        \u003crdf:type rdf:resource=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#Property\"/\u003e\r\n        \u003crdfs:domain rdf:resource=\"http://example.org/Element1\"/\u003e\r\n        \u003crdfs:range rdf:resource=\"http://example.org/Element2\"/\u003e\r\n    \u003c/rdf:Description\u003e\r\n\u003c/rdf:RDF\u003e`\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.rdf\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Tester la fonction ParseRDF\r\n\telements, relations, err := ParseRDF(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseRDF returned an error: %v\", err)\r\n\t}\r\n\r\n\t// Vérifier les éléments\r\n\tif len(elements) != 1 {\r\n\t\tt.Errorf(\"Expected 1 element, got %d\", len(elements))\r\n\t} else if elements[0].Name != \"Element1\" || elements[0].Description != \"Description1\" {\r\n\t\tt.Errorf(\"Unexpected element: %v\", elements[0])\r\n\t}\r\n\r\n\t// Vérifier les relations\r\n\tif len(relations) != 1 {\r\n\t\tt.Errorf(\"Expected 1 relation, got %d\", len(relations))\r\n\t} else if relations[0].Type != \"http://example.org/Relation1\" ||\r\n\t\trelations[0].Source != \"http://example.org/Element1\" ||\r\n\t\trelations[0].Target != \"http://example.org/Element2\" {\r\n\t\tt.Errorf(\"Unexpected relation: %v\", relations[0])\r\n\t}\r\n}\r\n",
    "size": 2053,
    "modTime": "2024-10-30T22:47:03.8066741+01:00",
    "path": "internal\\parser\\rdf_test.go"
  },
  {
    "name": "tsv.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"encoding/csv\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\t\"unicode\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nvar log *logger.Logger\r\n\r\nfunc init() {\r\n\tvar err error\r\n\tlogDir := filepath.Join(\".\", \"logs\") // Use a relative path\r\n\tlog, err = logger.NewLogger(logger.INFO, logDir)\r\n\tif err != nil {\r\n\t\tpanic(fmt.Sprintf(\"Failed to initialize logger: %v\", err))\r\n\t}\r\n}\r\n\r\n// ParseTSV parses a TSV file and returns a slice of Element structures\r\nfunc ParseTSV(filename string) ([]models.OntologyElement, []models.Relation, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse TSV file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\treader := csv.NewReader(bufio.NewReader(file))\r\n\treader.Comma = '\\t'\r\n\treader.LazyQuotes = true\r\n\treader.FieldsPerRecord = -1\r\n\r\n\tvar elements []models.OntologyElement\r\n\trelationMap := make(map[string]models.Relation)\r\n\r\n\tlineNumber := 0\r\n\tfor {\r\n\t\trecord, err := reader.Read()\r\n\t\tif err == io.EOF {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error reading TSV record: %v\", err))\r\n\t\t\treturn nil, nil, fmt.Errorf(\"error reading TSV record: %w\", err)\r\n\t\t}\r\n\r\n\t\tlineNumber++\r\n\r\n\t\tif len(record) \u003c 4 {\r\n\t\t\tlog.Warning(fmt.Sprintf(\"Skipping invalid record on line %d: %v\", lineNumber, record))\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tname := strings.TrimSpace(record[0])\r\n\t\telemType := strings.TrimSpace(record[1])\r\n\t\tpositionsStr := record[len(record)-1]\r\n\t\tdescription := strings.Join(record[2:len(record)-1], \"\\t\")\r\n\r\n\t\tpositions, err := parsePositions(positionsStr)\r\n\t\tif err != nil {\r\n\t\t\tlog.Warning(fmt.Sprintf(\"Error parsing positions on line %d: %v\", lineNumber, err))\r\n\t\t}\r\n\r\n\t\telement := models.OntologyElement{\r\n\t\t\tName:        name,\r\n\t\t\tType:        elemType,\r\n\t\t\tDescription: strings.TrimSpace(description),\r\n\t\t\tPositions:   positions,\r\n\t\t}\r\n\t\telements = append(elements, element)\r\n\r\n\t\t// Dédupliquer les relations\r\n\t\trelationKey := fmt.Sprintf(\"%s|%s|%s\", name, elemType, strings.TrimSpace(record[2]))\r\n\t\tif _, exists := relationMap[relationKey]; !exists {\r\n\t\t\trelationMap[relationKey] = models.Relation{\r\n\t\t\t\tSource:      name,\r\n\t\t\t\tType:        elemType,\r\n\t\t\t\tTarget:      strings.TrimSpace(record[2]),\r\n\t\t\t\tDescription: strings.TrimSpace(description),\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlog.Info(fmt.Sprintf(\"Parsed line %d: Element: %s, Type: %s, Description: %s\",\r\n\t\t\tlineNumber, element.Name, element.Type, element.Description))\r\n\t}\r\n\r\n\t// Convertir la map de relations en slice\r\n\trelations := make([]models.Relation, 0, len(relationMap))\r\n\tfor _, relation := range relationMap {\r\n\t\trelations = append(relations, relation)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing TSV file. Found %d elements and %d unique relations.\", len(elements), len(relations)))\r\n\treturn elements, relations, nil\r\n}\r\n\r\nfunc parsePositions(positionsStr string) ([]int, error) {\r\n\tpositionsStr = strings.TrimSpace(positionsStr)\r\n\tif positionsStr == \"\" {\r\n\t\treturn []int{}, nil\r\n\t}\r\n\r\n\t// Vérifier si la chaîne contient des caractères non numériques (à l'exception des virgules et des espaces)\r\n\tif strings.IndexFunc(positionsStr, func(r rune) bool {\r\n\t\treturn !unicode.IsDigit(r) \u0026\u0026 r != ',' \u0026\u0026 r != ' '\r\n\t}) != -1 {\r\n\t\t// Si c'est le cas, retourner un slice vide sans erreur\r\n\t\treturn []int{}, nil\r\n\t}\r\n\r\n\tpositionStrs := strings.Split(positionsStr, \",\")\r\n\tpositions := make([]int, 0, len(positionStrs))\r\n\r\n\tfor _, pos := range positionStrs {\r\n\t\tpos = strings.TrimSpace(pos)\r\n\t\tif pos == \"\" {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tposition, err := strconv.Atoi(pos)\r\n\t\tif err != nil {\r\n\t\t\t// Ignorer les erreurs de conversion et continuer\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tpositions = append(positions, position)\r\n\t}\r\n\r\n\treturn positions, nil\r\n}\r\n",
    "size": 3936,
    "modTime": "2024-10-30T22:47:03.8076746+01:00",
    "path": "internal\\parser\\tsv.go"
  },
  {
    "name": "tsv_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseTSV(t *testing.T) {\r\n\t// Créer un fichier TSV temporaire pour le test\r\n\tcontent := `Element1\tType1\tTarget1\tDescription1\r\nElement2\tType2\tTarget2\tDescription2\r\nElement3\tType3\tTarget3\tDescription3`\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.tsv\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Tester la fonction ParseTSV\r\n\telements, relations, err := ParseTSV(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseTSV returned an error: %v\", err)\r\n\t}\r\n\r\n\t// Vérifier les éléments\r\n\texpectedElements := []models.OntologyElement{\r\n\t\t{Name: \"Element1\", Type: \"Type1\", Description: \"Description1\"},\r\n\t\t{Name: \"Element2\", Type: \"Type2\", Description: \"Description2\"},\r\n\t\t{Name: \"Element3\", Type: \"Type3\", Description: \"Description3\"},\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(elements, expectedElements) {\r\n\t\tt.Errorf(\"ParseTSV returned unexpected elements. Got %v, want %v\", elements, expectedElements)\r\n\t}\r\n\r\n\t// Vérifier les relations\r\n\texpectedRelations := []models.Relation{\r\n\t\t{Source: \"Element1\", Type: \"Type1\", Target: \"Target1\", Description: \"Description1\"},\r\n\t\t{Source: \"Element2\", Type: \"Type2\", Target: \"Target2\", Description: \"Description2\"},\r\n\t\t{Source: \"Element3\", Type: \"Type3\", Target: \"Target3\", Description: \"Description3\"},\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(relations, expectedRelations) {\r\n\t\tt.Errorf(\"ParseTSV returned unexpected relations. Got %v, want %v\", relations, expectedRelations)\r\n\t}\r\n}\r\n",
    "size": 1849,
    "modTime": "2024-10-30T22:47:03.8096741+01:00",
    "path": "internal\\parser\\tsv_test.go"
  },
  {
    "name": "engine.go",
    "content": "package search\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"sort\"\r\n\t\"strings\"\r\n\t\"sync\"\r\n\r\n\t\"github.com/agnivade/levenshtein\"\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n)\r\n\r\n// SearchEngine représente le moteur de recherche\r\ntype SearchEngine struct {\r\n\tStorage *storage.MemoryStorage\r\n\tLogger  *logger.Logger\r\n}\r\n\r\n// NewSearchEngine crée une nouvelle instance de SearchEngine\r\nfunc NewSearchEngine(storage *storage.MemoryStorage, logger *logger.Logger) *SearchEngine {\r\n\treturn \u0026SearchEngine{\r\n\t\tStorage: storage,\r\n\t\tLogger:  logger,\r\n\t}\r\n}\r\n\r\n// SearchResult représente un résultat de recherche\r\ntype SearchResult struct {\r\n\tOntologyID  string\r\n\tElementName string\r\n\tElementType string\r\n\tDescription string\r\n\tContext     string\r\n\tPosition    int\r\n\tRelevance   float64\r\n\tContexts    []models.JSONContext\r\n\tSource      *models.SourceMetadata\r\n}\r\n\r\n// Search effectue une recherche dans les ontologies\r\nfunc (se *SearchEngine) Search(query string, ontologyID string, elementType string, contextSize int, fileID string) ([]SearchResult, error) {\r\n\tse.Logger.Info(fmt.Sprintf(\"Starting search with query: %s, ontologyID: %s, elementType: %s, fileID: %s\", query, ontologyID, elementType, fileID))\r\n\tquery = strings.ToLower(query)\r\n\tvar results []SearchResult\r\n\tvar wg sync.WaitGroup\r\n\tresultChan := make(chan SearchResult)\r\n\r\n\tontologies := se.Storage.ListOntologies()\r\n\tse.Logger.Info(fmt.Sprintf(\"Searching through %d ontologies\", len(ontologies)))\r\n\r\n\tfor _, ontology := range ontologies {\r\n\t\tif ontologyID != \"\" \u0026\u0026 ontology.ID != ontologyID {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\twg.Add(1)\r\n\t\tgo func(onto *models.Ontology) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\tse.Logger.Info(fmt.Sprintf(\"Searching in ontology: %s (Elements: %d)\", onto.ID, len(onto.Elements)))\r\n\t\t\tfor _, element := range onto.Elements {\r\n\t\t\t\tse.Logger.Info(fmt.Sprintf(\"Examining element: %s (Type: %s, Contexts: %d)\", element.Name, element.Type, len(element.Contexts)))\r\n\r\n\t\t\t\tif elementType != \"\" \u0026\u0026 element.Type != elementType {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Vérification du fileID\r\n\t\t\t\tif fileID != \"\" {\r\n\t\t\t\t\tmatchesFileID := false\r\n\t\t\t\t\tfor _, context := range element.Contexts {\r\n\t\t\t\t\t\tif context.FileID == fileID {\r\n\t\t\t\t\t\t\tmatchesFileID = true\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif !matchesFileID {\r\n\t\t\t\t\t\tse.Logger.Info(fmt.Sprintf(\"Element %s skipped: does not match fileID %s\", element.Name, fileID))\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\trelevance := calculateRelevance(query, element)\r\n\t\t\t\tif relevance \u003e 0.3 {\r\n\t\t\t\t\tcontext := extractContext(element, contextSize)\r\n\t\t\t\t\tposition := 0\r\n\t\t\t\t\tif len(element.Positions) \u003e 0 {\r\n\t\t\t\t\t\tposition = element.Positions[0]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult := SearchResult{\r\n\t\t\t\t\t\tOntologyID:  onto.ID,\r\n\t\t\t\t\t\tElementName: element.Name,\r\n\t\t\t\t\t\tElementType: element.Type,\r\n\t\t\t\t\t\tDescription: element.Description,\r\n\t\t\t\t\t\tContext:     context,\r\n\t\t\t\t\t\tPosition:    position,\r\n\t\t\t\t\t\tRelevance:   relevance,\r\n\t\t\t\t\t\tContexts:    element.Contexts,\r\n\t\t\t\t\t\tSource:      onto.Source,\r\n\t\t\t\t\t}\r\n\t\t\t\t\tse.Logger.Info(fmt.Sprintf(\"Found relevant result: %s (Relevance: %.2f)\", result.ElementName, result.Relevance))\r\n\t\t\t\t\tresultChan \u003c- result\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}(ontology)\r\n\t}\r\n\r\n\tgo func() {\r\n\t\twg.Wait()\r\n\t\tclose(resultChan)\r\n\t}()\r\n\r\n\tfor result := range resultChan {\r\n\t\tresults = append(results, result)\r\n\t}\r\n\r\n\tsortSearchResults(results)\r\n\r\n\tse.Logger.Info(fmt.Sprintf(\"Search completed. Found %d results.\", len(results)))\r\n\treturn results, nil\r\n}\r\n\r\n// sortSearchResults trie les résultats de recherche par pertinence décroissante\r\nfunc sortSearchResults(results []SearchResult) {\r\n\tsort.Slice(results, func(i, j int) bool {\r\n\t\treturn results[i].Relevance \u003e results[j].Relevance\r\n\t})\r\n}\r\n\r\n// calculateRelevance calcule la pertinence d'un élément par rapport à la requête\r\nfunc calculateRelevance(query string, element *models.OntologyElement) float64 {\r\n\trelevance := 0.0\r\n\r\n\tnameRelevance := fuzzyMatch(query, element.Name)\r\n\trelevance += nameRelevance * 0.6\r\n\r\n\ttypeRelevance := fuzzyMatch(query, element.Type)\r\n\trelevance += typeRelevance * 0.3\r\n\r\n\tdescRelevance := fuzzyMatch(query, element.Description)\r\n\trelevance += descRelevance * 0.1\r\n\r\n\treturn math.Min(relevance, 1.0)\r\n}\r\n\r\n// fuzzyMatch calcule la similarité entre deux chaînes\r\nfunc fuzzyMatch(s1, s2 string) float64 {\r\n\ts1 = strings.ToLower(s1)\r\n\ts2 = strings.ToLower(s2)\r\n\r\n\tif strings.Contains(s2, s1) {\r\n\t\treturn 1.0\r\n\t}\r\n\r\n\tdistance := levenshtein.ComputeDistance(s1, s2)\r\n\tmaxLen := float64(max(len(s1), len(s2)))\r\n\r\n\tif maxLen == 0 {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tsimilarity := 1 - float64(distance)/maxLen\r\n\tif similarity \u003c 0.3 {\r\n\t\treturn 0\r\n\t}\r\n\treturn math.Round(similarity*100) / 100 // Arrondir à deux décimales\r\n}\r\n\r\n// extractContext extrait le contexte d'un élément\r\nfunc extractContext(element *models.OntologyElement, contextSize int) string {\r\n\tif len(element.Contexts) \u003e 0 {\r\n\t\tcontext := element.Contexts[0] // Prendre le premier contexte\r\n\t\tbefore := strings.Join(context.Before, \" \")\r\n\t\tafter := strings.Join(context.After, \" \")\r\n\t\treturn fmt.Sprintf(\"%s [%s] %s\", before, context.Element, after)\r\n\t}\r\n\t// Si pas de contexte disponible, retourner une chaîne vide\r\n\treturn \"\"\r\n}\r\n\r\nfunc max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n",
    "size": 5333,
    "modTime": "2024-11-18T12:59:17.4313752+01:00",
    "path": "internal\\search\\engine.go"
  },
  {
    "name": "loader.go",
    "content": "// internal/storage/loader.go\r\n\r\npackage storage\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strings\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/parser\"\r\n)\r\n\r\ntype OntologyLoader struct {\r\n\tstorage *MemoryStorage\r\n\tlogger  *logger.Logger\r\n}\r\n\r\nfunc NewOntologyLoader(storage *MemoryStorage, logger *logger.Logger) *OntologyLoader {\r\n\treturn \u0026OntologyLoader{\r\n\t\tstorage: storage,\r\n\t\tlogger:  logger,\r\n\t}\r\n}\r\n\r\n// LoadFiles charge une ontologie avec ses métadonnées et contextes\r\nfunc (l *OntologyLoader) LoadFiles(ontologyFile, contextFile, metadataFile string) error {\r\n\t// Charger les métadonnées\r\n\tmetadata, err := l.loadMetadata(metadataFile)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed to load metadata: %w\", err)\r\n\t}\r\n\r\n\t// Charger l'ontologie\r\n\telements, relations, err := l.loadOntologyFile(ontologyFile)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed to load ontology file: %w\", err)\r\n\t}\r\n\r\n\t// Charger les contextes si présents\r\n\tif contextFile != \"\" {\r\n\t\tif err := l.enrichWithContexts(elements, contextFile, metadata.Files); err != nil {\r\n\t\t\treturn fmt.Errorf(\"failed to load contexts: %w\", err)\r\n\t\t}\r\n\t}\r\n\r\n\t// Créer et stocker l'ontologie\r\n\tontology := \u0026models.Ontology{\r\n\t\tID:         fmt.Sprintf(\"onto_%d\", time.Now().UnixNano()),\r\n\t\tName:       metadata.OntologyFile,\r\n\t\tFilename:   ontologyFile,\r\n\t\tFormat:     filepath.Ext(ontologyFile)[1:],\r\n\t\tImportedAt: metadata.ProcessingDate,\r\n\t\tElements:   elements,\r\n\t\tRelations:  relations,\r\n\t\tSource:     metadata,\r\n\t}\r\n\r\n\tif err := l.storage.AddOntology(ontology); err != nil {\r\n\t\treturn fmt.Errorf(\"failed to add ontology to storage: %w\", err)\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\nfunc (l *OntologyLoader) loadMetadata(filename string) (*models.SourceMetadata, error) {\r\n\tdata, err := os.ReadFile(filename)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to read metadata file: %w\", err)\r\n\t}\r\n\r\n\tvar metadata models.SourceMetadata\r\n\tif err := json.Unmarshal(data, \u0026metadata); err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to parse metadata JSON: %w\", err)\r\n\t}\r\n\r\n\treturn \u0026metadata, nil\r\n}\r\n\r\nfunc (l *OntologyLoader) loadOntologyFile(filename string) ([]*models.OntologyElement, []*models.Relation, error) {\r\n\tswitch {\r\n\tcase strings.HasSuffix(filename, \".tsv\"):\r\n\t\telements, relations, err := parser.ParseTSV(filename)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, nil, fmt.Errorf(\"failed to parse TSV: %w\", err)\r\n\t\t}\r\n\r\n\t\t// Convertir les slices en slices de pointeurs\r\n\t\telementPtrs := make([]*models.OntologyElement, len(elements))\r\n\t\tfor i := range elements {\r\n\t\t\telementPtrs[i] = \u0026elements[i]\r\n\t\t}\r\n\r\n\t\trelationPtrs := make([]*models.Relation, len(relations))\r\n\t\tfor i := range relations {\r\n\t\t\trelationPtrs[i] = \u0026relations[i]\r\n\t\t}\r\n\r\n\t\treturn elementPtrs, relationPtrs, nil\r\n\r\n\tdefault:\r\n\t\treturn nil, nil, fmt.Errorf(\"unsupported file format: %s\", filepath.Ext(filename))\r\n\t}\r\n}\r\n\r\nfunc (l *OntologyLoader) enrichWithContexts(elements []*models.OntologyElement, contextFile string, fileInfos map[string]models.FileInfo) error {\r\n\tcontexts, err := parser.ParseJSON(contextFile)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed to parse context file: %w\", err)\r\n\t}\r\n\r\n\telementMap := make(map[string]*models.OntologyElement)\r\n\tfor _, elem := range elements {\r\n\t\telementMap[elem.Name] = elem\r\n\t}\r\n\r\n\tfor _, ctx := range contexts {\r\n\t\tif elem, exists := elementMap[ctx.Element]; exists {\r\n\t\t\t// Enrichir le contexte avec les informations du fichier\r\n\t\t\t//if fileInfo, ok := fileInfos[ctx.FileID]; ok {\r\n\t\t\t//\tlog.Info(fmt.Sprintf(\"Associating context for element '%s' with file: %s in directory: %s\",ctx.Element, fileInfo.SourceFile, fileInfo.Directory))\r\n\t\t\t//}\r\n\t\t\telem.Contexts = append(elem.Contexts, ctx)\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n",
    "size": 3842,
    "modTime": "2024-11-17T23:43:44.4794393+01:00",
    "path": "internal\\storage\\loader.go"
  },
  {
    "name": "memory.go",
    "content": "package storage\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"regexp\"\r\n\t\"sort\"\r\n\t\"strings\"\r\n\t\"sync\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/parser\"\r\n)\r\n\r\nvar log *logger.Logger\r\n\r\nfunc init() {\r\n\tvar err error\r\n\tlog, err = logger.NewLogger(logger.INFO, \"logs\")\r\n\tif err != nil {\r\n\t\tpanic(fmt.Sprintf(\"Failed to initialize logger: %v\", err))\r\n\t}\r\n}\r\n\r\n// MemoryStorage represents an in-memory storage for ontologies\r\ntype MemoryStorage struct {\r\n\tontologies map[string]*models.Ontology\r\n\tmutex      sync.RWMutex\r\n}\r\n\r\n// NewMemoryStorage initializes and returns a new MemoryStorage\r\nfunc NewMemoryStorage() *MemoryStorage {\r\n\treturn \u0026MemoryStorage{\r\n\t\tontologies: make(map[string]*models.Ontology),\r\n\t}\r\n}\r\n\r\n// AddOntology adds a new ontology to the storage\r\nfunc (ms *MemoryStorage) AddOntology(ontology *models.Ontology) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[ontology.ID]; exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s already exists\", ontology.ID)\r\n\t}\r\n\r\n\tms.ontologies[ontology.ID] = ontology\r\n\tlog.Info(fmt.Sprintf(\"Added ontology with ID: %s\", ontology.ID))\r\n\treturn nil\r\n}\r\n\r\n// GetOntology retrieves an ontology by its ID\r\nfunc (ms *MemoryStorage) GetOntology(id string) (*models.Ontology, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tontology, exists := ms.ontologies[id]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"ontology with ID %s not found\", id)\r\n\t}\r\n\r\n\treturn ontology, nil\r\n}\r\n\r\n// UpdateOntology updates an existing ontology\r\nfunc (ms *MemoryStorage) UpdateOntology(ontology *models.Ontology) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[ontology.ID]; !exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s not found\", ontology.ID)\r\n\t}\r\n\r\n\tms.ontologies[ontology.ID] = ontology\r\n\tlog.Info(fmt.Sprintf(\"Updated ontology with ID: %s\", ontology.ID))\r\n\treturn nil\r\n}\r\n\r\n// DeleteOntology removes an ontology by its ID\r\nfunc (ms *MemoryStorage) DeleteOntology(id string) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[id]; !exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s not found\", id)\r\n\t}\r\n\r\n\tdelete(ms.ontologies, id)\r\n\tlog.Info(fmt.Sprintf(\"Deleted ontology with ID: %s\", id))\r\n\treturn nil\r\n}\r\n\r\n// ListOntologies returns a list of all stored ontologies\r\nfunc (ms *MemoryStorage) ListOntologies() []*models.Ontology {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tontologies := make([]*models.Ontology, 0, len(ms.ontologies))\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tontologies = append(ontologies, ontology)\r\n\t}\r\n\r\n\treturn ontologies\r\n}\r\n\r\nfunc (ms *MemoryStorage) GetElement(elementName string) (*models.OntologyElement, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tfor _, element := range ontology.Elements {\r\n\t\t\tif element.Name == elementName {\r\n\t\t\t\tlog.Info(fmt.Sprintf(\"Found element %s with %d contexts\", elementName, len(element.Contexts)))\r\n\t\t\t\treturn element, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn nil, fmt.Errorf(\"element not found\")\r\n}\r\n\r\nfunc (ms *MemoryStorage) GetElementRelations(elementName string) ([]*models.Relation, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\t// Utiliser la même normalisation que partout ailleurs\r\n\tnormalizedName := normalizeElementName(elementName)\r\n\tlog.Info(fmt.Sprintf(\"Searching relations for normalized element name: %s\", normalizedName))\r\n\r\n\tvar relations []*models.Relation\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tfor _, relation := range ontology.Relations {\r\n\t\t\t// Utiliser la même normalisation pour la source et la cible\r\n\t\t\tif normalizeElementName(relation.Source) == normalizedName ||\r\n\t\t\t\tnormalizeElementName(relation.Target) == normalizedName {\r\n\t\t\t\t// Garder la relation originale (non normalisée) pour l'affichage\r\n\t\t\t\trelations = append(relations, relation)\r\n\t\t\t\tlog.Info(fmt.Sprintf(\"Found relation: %s -\u003e %s -\u003e %s\",\r\n\t\t\t\t\trelation.Source, relation.Type, relation.Target))\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif len(relations) == 0 {\r\n\t\treturn nil, fmt.Errorf(\"no relations found for element: %s\", elementName)\r\n\t}\r\n\r\n\treturn relations, nil\r\n}\r\n\r\n// LoadOntologyFromFile loads an ontology from files including metadata\r\nfunc (ms *MemoryStorage) LoadOntologyFromFile(ontologyFile, contextFile, metadataFile string) error {\r\n\tlog.Info(fmt.Sprintf(\"Loading ontology from file: %s with metadata: %s\", ontologyFile, metadataFile))\r\n\r\n\t// Charger les métadonnées\r\n\tmetadata, err := loadSourceMetadata(metadataFile)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Error loading metadata: %v\", err))\r\n\t\treturn fmt.Errorf(\"error loading metadata: %w\", err)\r\n\t}\r\n\r\n\tvar elements []*models.OntologyElement\r\n\tvar relations []*models.Relation\r\n\r\n\t// Charger l'ontologie principale\r\n\tswitch {\r\n\tcase strings.HasSuffix(ontologyFile, \".tsv\"):\r\n\t\telementsSlice, relationsSlice, err := parser.ParseTSV(ontologyFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing TSV file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing TSV file: %w\", err)\r\n\t\t}\r\n\t\telements = make([]*models.OntologyElement, len(elementsSlice))\r\n\t\trelations = make([]*models.Relation, len(relationsSlice))\r\n\t\tfor i := range elementsSlice {\r\n\t\t\telements[i] = \u0026elementsSlice[i]\r\n\t\t}\r\n\t\tfor i := range relationsSlice {\r\n\t\t\trelations[i] = \u0026relationsSlice[i]\r\n\t\t}\r\n\tcase strings.HasSuffix(ontologyFile, \".owl\"):\r\n\t\telementsSlice, relationsSlice, err := parser.ParseOWL(ontologyFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing OWL file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing OWL file: %w\", err)\r\n\t\t}\r\n\t\telements = make([]*models.OntologyElement, len(elementsSlice))\r\n\t\trelations = make([]*models.Relation, len(relationsSlice))\r\n\t\tfor i := range elementsSlice {\r\n\t\t\telements[i] = \u0026elementsSlice[i]\r\n\t\t}\r\n\t\tfor i := range relationsSlice {\r\n\t\t\trelations[i] = \u0026relationsSlice[i]\r\n\t\t}\r\n\tcase strings.HasSuffix(ontologyFile, \".rdf\"):\r\n\t\telementsSlice, relationsSlice, err := parser.ParseRDF(ontologyFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing RDF file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing RDF file: %w\", err)\r\n\t\t}\r\n\t\telements = make([]*models.OntologyElement, len(elementsSlice))\r\n\t\trelations = make([]*models.Relation, len(relationsSlice))\r\n\t\tfor i := range elementsSlice {\r\n\t\t\telements[i] = \u0026elementsSlice[i]\r\n\t\t}\r\n\t\tfor i := range relationsSlice {\r\n\t\t\trelations[i] = \u0026relationsSlice[i]\r\n\t\t}\r\n\tdefault:\r\n\t\treturn fmt.Errorf(\"unsupported ontology file format\")\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Loaded %d elements and %d relations from ontology file\", len(elements), len(relations)))\r\n\r\n\t// Normaliser et fusionner les éléments\r\n\tnormalizedElements := make(map[string]*models.OntologyElement)\r\n\tfor _, elem := range elements {\r\n\t\tnormalizedName := normalizeElementName(elem.Name)\r\n\t\tif existingElem, exists := normalizedElements[normalizedName]; exists {\r\n\t\t\t// Fusionner les éléments\r\n\t\t\texistingElem.Positions = append(existingElem.Positions, elem.Positions...)\r\n\t\t\tif len(elem.Description) \u003e len(existingElem.Description) {\r\n\t\t\t\texistingElem.Description = elem.Description\r\n\t\t\t}\r\n\t\t\tcombinedTypes := existingElem.Type + \"/\" + elem.Type\r\n\t\t\texistingElem.Type = deduplicateTypes(combinedTypes)\r\n\t\t} else {\r\n\t\t\telem.Type = deduplicateTypes(elem.Type)\r\n\t\t\tnormalizedElements[normalizedName] = elem\r\n\t\t\telem.OriginalName = elem.Name\r\n\t\t\telem.Name = normalizedName\r\n\t\t}\r\n\t}\r\n\r\n\telements = make([]*models.OntologyElement, 0, len(normalizedElements))\r\n\tfor _, elem := range normalizedElements {\r\n\t\telements = append(elements, elem)\r\n\t}\r\n\r\n\t// Charger le fichier de contexte JSON si fourni\r\n\tvar contexts []models.JSONContext\r\n\tif contextFile != \"\" {\r\n\t\tcontexts, err = parser.ParseJSON(contextFile)\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error parsing context file: %v\", err))\r\n\t\t\treturn fmt.Errorf(\"error parsing context file: %w\", err)\r\n\t\t}\r\n\t\tlog.Info(fmt.Sprintf(\"Loaded %d contexts from JSON file\", len(contexts)))\r\n\t}\r\n\r\n\t// Associer les contextes aux éléments\r\n\ttotalAssociations := 0\r\n\tfor _, elem := range elements {\r\n\t\tcontextMap := make(map[int]models.JSONContext)\r\n\t\tnormalizedElemName := normalizeElementName(elem.Name)\r\n\t\tfor _, ctx := range contexts {\r\n\t\t\tif elementInContext(normalizedElemName, ctx) {\r\n\t\t\t\tfor _, pos := range elem.Positions {\r\n\t\t\t\t\tif pos \u003e= ctx.StartOffset \u0026\u0026 pos \u003c= ctx.EndOffset {\r\n\t\t\t\t\t\tif _, exists := contextMap[ctx.Position]; !exists {\r\n\t\t\t\t\t\t\tcontextMap[ctx.Position] = ctx\r\n\t\t\t\t\t\t\ttotalAssociations++\r\n\t\t\t\t\t\t\tlog.Debug(fmt.Sprintf(\"Associated new context (position %d) to element %s\", ctx.Position, elem.Name))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telem.Contexts = make([]models.JSONContext, 0, len(contextMap))\r\n\t\tfor _, ctx := range contextMap {\r\n\t\t\telem.Contexts = append(elem.Contexts, ctx)\r\n\t\t}\r\n\t\tlog.Info(fmt.Sprintf(\"Element %s has %d unique contexts after association\", elem.Name, len(elem.Contexts)))\r\n\t}\r\n\r\n\t// Créer une nouvelle ontologie avec les métadonnées\r\n\tontology := \u0026models.Ontology{\r\n\t\tID:         fmt.Sprintf(\"onto_%d\", time.Now().UnixNano()),\r\n\t\tName:       metadata.OntologyFile, // Utilisons OntologyFile au lieu de SourceFile\r\n\t\tFilename:   ontologyFile,\r\n\t\tFormat:     filepath.Ext(ontologyFile)[1:],\r\n\t\tImportedAt: metadata.ProcessingDate,\r\n\t\tElements:   elements,\r\n\t\tRelations:  relations,\r\n\t\tSource:     metadata,\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Created new ontology with ID: %s\", ontology.ID))\r\n\terr = ms.AddOntology(ontology)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Error adding ontology to storage: %v\", err))\r\n\t\treturn fmt.Errorf(\"error adding ontology to storage: %w\", err)\r\n\t}\r\n\r\n\tfor _, fileInfo := range metadata.Files {\r\n\t\tif fileInfo.SourceFile == filepath.Base(ontologyFile) {\r\n\t\t\tontology.SHA256 = fileInfo.SHA256Hash\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tlog.Info(\"Ontology successfully loaded and added to storage\")\r\n\treturn nil\r\n}\r\n\r\n// loadSourceMetadata charge le fichier de métadonnées\r\nfunc loadSourceMetadata(filename string) (*models.SourceMetadata, error) {\r\n\tdata, err := os.ReadFile(filename)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to read metadata file: %w\", err)\r\n\t}\r\n\r\n\tvar metadata models.SourceMetadata\r\n\tif err := json.Unmarshal(data, \u0026metadata); err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to parse metadata JSON: %w\", err)\r\n\t}\r\n\r\n\treturn \u0026metadata, nil\r\n}\r\n\r\n// Fonction helper pour normaliser les noms d'éléments\r\nfunc normalizeElementName(name string) string {\r\n\t// Remplacer les underscores par des espaces, sauf pour certains préfixes\r\n\tparts := strings.SplitN(name, \"_\", 2)\r\n\tif len(parts) == 2 \u0026\u0026 (parts[0] == \"est\" || parts[0] == \"a\") {\r\n\t\treturn parts[0] + \" \" + strings.ReplaceAll(parts[1], \"_\", \" \")\r\n\t}\r\n\r\n\t// Remplacer les underscores par des espaces pour les autres cas\r\n\tname = strings.ReplaceAll(name, \"_\", \" \")\r\n\r\n\t// Liste des préfixes qui peuvent être suivis d'une apostrophe en français\r\n\tprefixes := []string{\r\n\t\t\"l\", \"d\", \"j\", \"m\", \"t\", \"s\", \"c\", \"n\", \"qu\",\r\n\t\t\"jusqu\", \"lorsqu\", \"puisqu\", \"quoiqu\", \"quelqu\",\r\n\t}\r\n\r\n\t// Remplacer les espaces par des apostrophes pour ces préfixes\r\n\tfor _, prefix := range prefixes {\r\n\t\tpattern := fmt.Sprintf(`\\b%s \\b`, prefix)\r\n\t\treplacement := fmt.Sprintf(\"%s'\", prefix)\r\n\t\tname = regexp.MustCompile(pattern).ReplaceAllString(name, replacement)\r\n\t}\r\n\r\n\t// Gestion spéciale pour \"aujourd hui\"\r\n\tname = strings.ReplaceAll(name, \"aujourd hui\", \"aujourd'hui\")\r\n\r\n\t// Supprimer les espaces multiples\r\n\tname = strings.Join(strings.Fields(name), \" \")\r\n\r\n\t// Ne pas mettre en minuscules pour préserver la casse originale\r\n\treturn name\r\n}\r\nfunc deduplicateTypes(types string) string {\r\n\ttypeSlice := strings.Split(types, \"/\")\r\n\ttypeMap := make(map[string]string)\r\n\tfor _, t := range typeSlice {\r\n\t\tt = strings.TrimSpace(t)\r\n\t\tnormalizedType := normalizeType(t)\r\n\t\tif existingType, exists := typeMap[normalizedType]; exists {\r\n\t\t\t// Garder la version la plus longue du type\r\n\t\t\tif len(t) \u003e len(existingType) {\r\n\t\t\t\ttypeMap[normalizedType] = t\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttypeMap[normalizedType] = t\r\n\t\t}\r\n\t}\r\n\r\n\tvar uniqueTypes []string\r\n\tfor _, t := range typeMap {\r\n\t\tuniqueTypes = append(uniqueTypes, t)\r\n\t}\r\n\r\n\tsort.Strings(uniqueTypes)\r\n\treturn strings.Join(uniqueTypes, \"/\")\r\n}\r\n\r\nfunc normalizeType(t string) string {\r\n\t// Remplacer les underscores par des espaces\r\n\tt = strings.ReplaceAll(t, \"_\", \" \")\r\n\t// Supprimer les espaces multiples\r\n\tt = strings.Join(strings.Fields(t), \" \")\r\n\t// Mettre en minuscules\r\n\treturn strings.ToLower(t)\r\n}\r\n\r\n// Fonction helper pour vérifier si un élément est présent dans un contexte\r\nfunc elementInContext(elem string, ctx models.JSONContext) bool {\r\n\telemLower := strings.ToLower(elem)\r\n\tcontextText := strings.ToLower(strings.Join(append(ctx.Before, ctx.Element), \" \") + \" \" + strings.Join(ctx.After, \" \"))\r\n\r\n\t// Vérification de la correspondance exacte\r\n\tif strings.Contains(contextText, elemLower) {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Vérification avec les underscores remplacés par des espaces\r\n\telemWithoutUnderscore := strings.ReplaceAll(elemLower, \"_\", \" \")\r\n\tif strings.Contains(contextText, elemWithoutUnderscore) {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Vérification des parties individuelles du nom de l'élément\r\n\telemParts := strings.FieldsFunc(elemLower, func(r rune) bool {\r\n\t\treturn r == '_' || r == ' '\r\n\t})\r\n\r\n\tmatchCount := 0\r\n\tfor _, part := range elemParts {\r\n\t\tif strings.Contains(contextText, part) {\r\n\t\t\tmatchCount++\r\n\t\t}\r\n\t}\r\n\r\n\t// Si plus de la moitié des parties correspondent, considérez-le comme une correspondance\r\n\tif float64(matchCount)/float64(len(elemParts)) \u003e 0.5 {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Vérification spéciale pour les éléments contenant \"est\" ou \"a\"\r\n\tif strings.Contains(elemLower, \"est_\") || strings.Contains(elemLower, \"a_\") {\r\n\t\tparts := strings.SplitN(elemLower, \"_\", 2)\r\n\t\tif len(parts) == 2 \u0026\u0026 strings.Contains(contextText, parts[1]) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\nfunc (ms *MemoryStorage) GetElementContexts(elementName string) ([]models.JSONContext, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tlog.Info(\"GetElementContext Called for: \" + elementName)\r\n\tnormalizedName := normalizeElementName(elementName)\r\n\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tfor _, elem := range ontology.Elements {\r\n\t\t\tif normalizeElementName(elem.Name) == normalizedName {\r\n\t\t\t\tlog.Info(fmt.Sprintf(\"GetElementContext found for %s with %d contexts\", elem.Name, len(elem.Contexts)))\r\n\t\t\t\treturn elem.Contexts, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil, fmt.Errorf(\"element not found: %s\", elementName)\r\n}\r\n",
    "size": 14623,
    "modTime": "2024-11-18T18:14:41.4439527+01:00",
    "path": "internal\\storage\\memory.go"
  },
  {
    "name": "memory_test.go",
    "content": "package storage\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"testing\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestNewMemoryStorage(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tif ms == nil {\r\n\t\tt.Error(\"NewMemoryStorage returned nil\")\r\n\t}\r\n\tif ms.ontologies == nil {\r\n\t\tt.Error(\"ontologies map is not initialized\")\r\n\t}\r\n}\r\n\r\nfunc TestAddOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\r\n\terr := ms.AddOntology(ontology)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to add ontology: %v\", err)\r\n\t}\r\n\r\n\t// Try to add the same ontology again\r\n\terr = ms.AddOntology(ontology)\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when adding duplicate ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestGetOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\tretrieved, err := ms.GetOntology(\"test1\")\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to get ontology: %v\", err)\r\n\t}\r\n\tif retrieved.ID != ontology.ID || retrieved.Name != ontology.Name {\r\n\t\tt.Error(\"Retrieved ontology does not match the original\")\r\n\t}\r\n\r\n\t_, err = ms.GetOntology(\"nonexistent\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when getting nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestUpdateOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\tupdatedOntology := \u0026models.Ontology{ID: \"test1\", Name: \"Updated Test Ontology\"}\r\n\terr := ms.UpdateOntology(updatedOntology)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to update ontology: %v\", err)\r\n\t}\r\n\r\n\tretrieved, _ := ms.GetOntology(\"test1\")\r\n\tif retrieved.Name != \"Updated Test Ontology\" {\r\n\t\tt.Error(\"Ontology was not updated correctly\")\r\n\t}\r\n\r\n\tnonexistentOntology := \u0026models.Ontology{ID: \"nonexistent\", Name: \"Nonexistent\"}\r\n\terr = ms.UpdateOntology(nonexistentOntology)\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when updating nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestDeleteOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\terr := ms.DeleteOntology(\"test1\")\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to delete ontology: %v\", err)\r\n\t}\r\n\r\n\t_, err = ms.GetOntology(\"test1\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when getting deleted ontology, got nil\")\r\n\t}\r\n\r\n\terr = ms.DeleteOntology(\"nonexistent\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when deleting nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestListOntologies(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology1 := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology 1\"}\r\n\tontology2 := \u0026models.Ontology{ID: \"test2\", Name: \"Test Ontology 2\"}\r\n\tms.AddOntology(ontology1)\r\n\tms.AddOntology(ontology2)\r\n\r\n\tontologies := ms.ListOntologies()\r\n\tif len(ontologies) != 2 {\r\n\t\tt.Errorf(\"Expected 2 ontologies, got %d\", len(ontologies))\r\n\t}\r\n\r\n\tfoundOntology1 := false\r\n\tfoundOntology2 := false\r\n\tfor _, o := range ontologies {\r\n\t\tif o.ID == \"test1\" {\r\n\t\t\tfoundOntology1 = true\r\n\t\t}\r\n\t\tif o.ID == \"test2\" {\r\n\t\t\tfoundOntology2 = true\r\n\t\t}\r\n\t}\r\n\r\n\tif !foundOntology1 || !foundOntology2 {\r\n\t\tt.Error(\"ListOntologies did not return all added ontologies\")\r\n\t}\r\n}\r\n\r\nfunc TestConcurrency(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tconcurrentOperations := 1000\r\n\r\n\t// Concurrent additions\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tgo func(id int) {\r\n\t\t\tontology := \u0026models.Ontology{ID: fmt.Sprintf(\"test%d\", id), Name: fmt.Sprintf(\"Test Ontology %d\", id)}\r\n\t\t\tms.AddOntology(ontology)\r\n\t\t}(i)\r\n\t}\r\n\r\n\ttime.Sleep(time.Second) // Give time for goroutines to complete\r\n\r\n\t// Verify all ontologies were added\r\n\tontologies := ms.ListOntologies()\r\n\tif len(ontologies) != concurrentOperations {\r\n\t\tt.Errorf(\"Expected %d ontologies, got %d\", concurrentOperations, len(ontologies))\r\n\t}\r\n\r\n\t// Concurrent reads and updates\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tgo func(id int) {\r\n\t\t\tontologyID := fmt.Sprintf(\"test%d\", id)\r\n\t\t\tms.GetOntology(ontologyID)\r\n\t\t\tupdatedOntology := \u0026models.Ontology{ID: ontologyID, Name: fmt.Sprintf(\"Updated Test Ontology %d\", id)}\r\n\t\t\tms.UpdateOntology(updatedOntology)\r\n\t\t}(i)\r\n\t}\r\n\r\n\ttime.Sleep(time.Second) // Give time for goroutines to complete\r\n\r\n\t// Verify all ontologies were updated\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tontology, _ := ms.GetOntology(fmt.Sprintf(\"test%d\", i))\r\n\t\tif ontology.Name != fmt.Sprintf(\"Updated Test Ontology %d\", i) {\r\n\t\t\tt.Errorf(\"Ontology %d was not updated correctly\", i)\r\n\t\t}\r\n\t}\r\n}\r\nfunc TestLoadOntologyWithMetadata(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\r\n\t// Créer un fichier de métadonnées temporaire avec la nouvelle structure\r\n\tmetadataContent := `{\r\n        \"ontology_file\": \"test.tsv\",\r\n        \"processing_date\": \"2024-10-29T08:54:33.959Z\",\r\n        \"files\": {\r\n            \"file1\": {\r\n                \"id\": \"file1\",\r\n                \"source_file\": \"test.txt\",\r\n                \"directory\": \"/test/path\",\r\n                \"file_date\": \"2024-10-29T08:54:33.959Z\",\r\n                \"sha256_hash\": \"test-hash\"\r\n            }\r\n        }\r\n    }`\r\n\r\n\tmetadataFile := filepath.Join(t.TempDir(), \"metadata.json\")\r\n\tif err := os.WriteFile(metadataFile, []byte(metadataContent), 0644); err != nil {\r\n\t\tt.Fatalf(\"Failed to create test metadata file: %v\", err)\r\n\t}\r\n\r\n\t// Créer un fichier TSV minimal pour le test\r\n\ttsvContent := \"Element1\\tType1\\tDescription1\\t1,2,3\"\r\n\ttsvFile := filepath.Join(t.TempDir(), \"test.tsv\")\r\n\tif err := os.WriteFile(tsvFile, []byte(tsvContent), 0644); err != nil {\r\n\t\tt.Fatalf(\"Failed to create test TSV file: %v\", err)\r\n\t}\r\n\r\n\t// Test du chargement\r\n\terr := ms.LoadOntologyFromFile(tsvFile, \"\", metadataFile)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to load ontology with metadata: %v\", err)\r\n\t}\r\n\r\n\t// Vérifier que les ontologies sont chargées avec les métadonnées\r\n\tontologies := ms.ListOntologies()\r\n\tif len(ontologies) != 1 {\r\n\t\tt.Errorf(\"Expected 1 ontology, got %d\", len(ontologies))\r\n\t}\r\n\r\n\t// Vérifier les métadonnées\r\n\tontology := ontologies[0]\r\n\tif ontology.Source == nil {\r\n\t\tt.Error(\"Expected source metadata to be present\")\r\n\t} else {\r\n\t\tif ontology.Source.OntologyFile != \"test.tsv\" {\r\n\t\t\tt.Errorf(\"Expected ontology file 'test.tsv', got '%s'\", ontology.Source.OntologyFile)\r\n\t\t}\r\n\t\tif len(ontology.Source.Files) != 1 {\r\n\t\t\tt.Errorf(\"Expected 1 file in metadata, got %d\", len(ontology.Source.Files))\r\n\t\t}\r\n\t\tfileInfo, exists := ontology.Source.Files[\"file1\"]\r\n\t\tif !exists {\r\n\t\t\tt.Error(\"Expected file info for 'file1' to exist\")\r\n\t\t} else {\r\n\t\t\tif fileInfo.SourceFile != \"test.txt\" {\r\n\t\t\t\tt.Errorf(\"Expected source file 'test.txt', got '%s'\", fileInfo.SourceFile)\r\n\t\t\t}\r\n\t\t\tif fileInfo.SHA256Hash != \"test-hash\" {\r\n\t\t\t\tt.Errorf(\"Expected SHA256 hash 'test-hash', got '%s'\", fileInfo.SHA256Hash)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n",
    "size": 6915,
    "modTime": "2024-11-18T09:58:33.6182886+01:00",
    "path": "internal\\storage\\memory_test.go"
  },
  {
    "name": "api.js",
    "content": "// api.js\r\nconst API_BASE_URL = '/api';\r\n\r\n// Charger la liste des ontologies\r\nexport async function loadOntologies() {\r\n    try {\r\n        const response = await fetch(`${API_BASE_URL}/ontologies`);\r\n        if (!response.ok) {\r\n            throw new Error('Error loading ontologies');\r\n        }\r\n        const ontologies = await response.json();\r\n        console.log(\"Raw ontologies data:\", ontologies);\r\n        \r\n        // Récupérer les métadonnées pour chaque ontologie\r\n        const ontologiesWithMetadata = await Promise.all(ontologies.map(async (ontology) =\u003e {\r\n            try {\r\n                const metadataResponse = await fetch(`${API_BASE_URL}/ontologies/${ontology.id}/metadata`);\r\n                if (metadataResponse.ok) {\r\n                    const metadata = await metadataResponse.json();\r\n                    return { ...ontology, Source: metadata };\r\n                }\r\n            } catch (error) {\r\n                console.error(`Error fetching metadata for ontology ${ontology.id}:`, error);\r\n            }\r\n            return ontology;\r\n        }));\r\n        \r\n        console.log(\"Ontologies with metadata:\", ontologiesWithMetadata);\r\n        return ontologiesWithMetadata;\r\n    } catch (error) {\r\n        console.error('Error loading ontologies:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Charger les types d'éléments (à implémenter côté serveur)\r\nexport async function loadElementTypes() {\r\n    // TODO: Implémenter l'appel API réel\r\n    return ['Concept', 'Relation', 'Instance'];\r\n}\r\n\r\n// Rechercher dans les ontologies\r\nexport async function searchOntologies(query, fileId, elementType) {\r\n    if (!query) {\r\n        throw new Error('Un terme de recherche est requis');\r\n    }\r\n\r\n    let url = `${API_BASE_URL}/search?q=${encodeURIComponent(query)}`;\r\n    if (fileId) url += `\u0026file_id=${encodeURIComponent(fileId)}`;\r\n    if (elementType) url += `\u0026element_type=${encodeURIComponent(elementType)}`;\r\n\r\n    console.log(\"Search URL:\", url);\r\n\r\n    const response = await fetch(url);\r\n    if (!response.ok) {\r\n        const errorText = await response.text();\r\n        console.error(\"Search API error:\", errorText);\r\n        throw new Error('Erreur lors de la recherche: ' + errorText);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    console.log('Résultats bruts de la recherche:', data);\r\n\r\n    return Array.isArray(data) ? data.map(item =\u003e ({\r\n        ...item,\r\n        sourceFile: item.Source?.source_file || 'Unknown',\r\n        sourceMetadata: item.Source || null\r\n    })) : [];\r\n}\r\n\r\n// api.js\r\nexport async function getElementDetails(elementName) {\r\n    const url = `${API_BASE_URL}/elements/details/${encodeURIComponent(elementName)}`;\r\n    console.log('Fetching element details from:', url);\r\n    try {\r\n        const response = await fetch(url);\r\n        console.log('Response status:', response.status);\r\n        if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        const data = await response.json();\r\n        console.log('Received element details:', data);\r\n        \r\n        // Assurez-vous que toutes les propriétés attendues sont présentes\r\n        return {\r\n            Name: data.Name || '',\r\n            Type: data.Type || '',\r\n            Description: data.Description || '',\r\n            Positions: data.Positions || [],\r\n            Relations: data.Relations || [],\r\n            Contexts: data.Contexts || []\r\n        };\r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des détails de l\\'élément:', error);\r\n        throw new Error('Erreur lors de la récupération des détails de l\\'élément');\r\n    }\r\n}\r\n\r\n// Charger une ontologie avec ses métadonnées\r\nexport async function uploadOntology(formData) {\r\n    try {\r\n        const response = await fetch(`${API_BASE_URL}/ontologies/load`, {\r\n            method: 'POST',\r\n            body: formData\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.json();\r\n            throw new Error(error.error || 'Failed to upload ontology');\r\n        }\r\n\r\n        return await response.json();\r\n    } catch (error) {\r\n        console.error('Error uploading ontology:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\nexport async function getElementRelations(elementName) {\r\n    try {\r\n        // Encoder proprement le nom de l'élément pour l'URL\r\n        const encodedName = encodeURIComponent(elementName);\r\n        const url = `${API_BASE_URL}/elements/relations/${encodedName}`;\r\n        \r\n        const response = await fetch(url);\r\n        if (!response.ok \u0026\u0026 response.status !== 404) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        \r\n        // En cas de 404 ou si la réponse est ok, parser le JSON\r\n        const data = await response.json();\r\n        \r\n        // S'assurer de toujours retourner un tableau\r\n        return Array.isArray(data) ? data : [];\r\n        \r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des relations:', error);\r\n        return []; // Retourner un tableau vide en cas d'erreur\r\n    }\r\n}\r\n\r\n// Récupérer les métadonnées d'une ontologie\r\nexport async function getOntologyMetadata(ontologyId) {\r\n    try {\r\n        const response = await fetch(`${API_BASE_URL}/ontologies/${ontologyId}/metadata`);\r\n        if (!response.ok) {\r\n            throw new Error('Failed to fetch ontology metadata');\r\n        }\r\n        return await response.json();\r\n    } catch (error) {\r\n        console.error('Error fetching ontology metadata:', error);\r\n        throw error;\r\n    }\r\n}",
    "size": 5635,
    "modTime": "2024-11-18T12:33:26.3408647+01:00",
    "path": "web\\api.js"
  },
  {
    "name": "graph.js",
    "content": "import { performSearch } from './search.js';\r\n\r\nexport function createRelationsGraph(element, relations) {\r\n    console.log(\"Création du graphique pour:\", element.Name);\r\n    const graphContainer = document.getElementById('element-relations-graph');\r\n    graphContainer.innerHTML = '';\r\n\r\n    const escapeId = (str) =\u003e {\r\n        return str.replace(/[^\\w\\s-]/g, '_').replace(/\\s+/g, '_');\r\n    };\r\n\r\n    let mermaidDef = 'graph LR\\n';\r\n\r\n    // Créer un Map pour stocker les nœuds uniques\r\n    const nodes = new Map();\r\n\r\n    // Ajouter le nœud principal\r\n    const mainNodeId = escapeId(element.Name);\r\n    nodes.set(mainNodeId, element.Name);\r\n    mermaidDef += `    ${mainNodeId}[\"${element.Name}\u003cbr\u003e\u003ci\u003e${element.Type}\u003c/i\u003e\"]\\n`;\r\n\r\n    // Ajouter les relations\r\n    relations.forEach(relation =\u003e {\r\n        const sourceId = escapeId(relation.Source);\r\n        const targetId = escapeId(relation.Target);\r\n\r\n        // Ajouter les nœuds s'ils n'existent pas déjà\r\n        if (!nodes.has(sourceId)) {\r\n            nodes.set(sourceId, relation.Source);\r\n            mermaidDef += `    ${sourceId}[\"${relation.Source}\"]\\n`;\r\n        }\r\n        if (!nodes.has(targetId)) {\r\n            nodes.set(targetId, relation.Target);\r\n            mermaidDef += `    ${targetId}[\"${relation.Target}\"]\\n`;\r\n        }\r\n\r\n        // Ajouter la relation\r\n        mermaidDef += `    ${sourceId} --\u003e|\"${relation.Type}\"| ${targetId}\\n`;\r\n    });\r\n\r\n    const mermaidDiv = document.createElement('div');\r\n    mermaidDiv.className = 'mermaid';\r\n    mermaidDiv.textContent = mermaidDef;\r\n    graphContainer.appendChild(mermaidDiv);\r\n\r\n    mermaid.initialize({ \r\n        startOnLoad: true, \r\n        theme: 'default',\r\n        flowchart: {\r\n            useMaxWidth: true,\r\n            htmlLabels: true,\r\n            curve: 'basis'\r\n        },\r\n        securityLevel: 'loose'\r\n    });\r\n\r\n    mermaid.render('graphDiv', mermaidDef).then(result =\u003e {\r\n        mermaidDiv.innerHTML = result.svg;\r\n\r\n        const svg = mermaidDiv.querySelector('svg');\r\n        \r\n        // Réappliquer panzoom\r\n        const instance = panzoom(svg, {\r\n            maxZoom: 5,\r\n            minZoom: 0.1,\r\n            initialZoom: 1\r\n        });\r\n\r\n        // Centrer le graphique\r\n        const bbox = svg.getBBox();\r\n        const viewportWidth = graphContainer.clientWidth;\r\n        const viewportHeight = graphContainer.clientHeight;\r\n        instance.moveTo(viewportWidth/2 - bbox.width/2, viewportHeight/2 - bbox.height/2);\r\n\r\n        // Ajouter des gestionnaires d'événements de clic aux nœuds\r\n        svg.querySelectorAll('.node').forEach(node =\u003e {\r\n            node.style.cursor = 'pointer';\r\n            node.addEventListener('click', function(event) {\r\n                event.preventDefault();\r\n                event.stopPropagation();\r\n                const nodeText = this.querySelector('tspan')?.textContent || this.textContent;\r\n                console.log(\"Nœud cliqué, texte:\", nodeText);\r\n                if (nodeText) {\r\n                    // Extraire uniquement le nom de l'élément (première partie avant un espace ou un caractère spécial)\r\n                    const elementName = nodeText.split(/\\s/)[0].trim();\r\n                    console.log(\"Recherche pour l'élément:\", elementName);\r\n                    performSearch(elementName);\r\n                }\r\n            });\r\n        });\r\n\r\n        console.log(\"Graphique créé avec\", nodes.size, \"nœuds\");\r\n    }).catch(error =\u003e {\r\n        console.error(\"Erreur lors de la création du graphique:\", error);\r\n    });\r\n}",
    "size": 3564,
    "modTime": "2024-11-18T18:19:07.3354287+01:00",
    "path": "web\\graph.js"
  },
  {
    "name": "index.html",
    "content": "\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"fr\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\r\n    \u003ctitle\u003eOntology Explorer\u003c/title\u003e\r\n    \u003clink href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700\u0026family=Roboto+Mono\u0026display=swap\" rel=\"stylesheet\"\u003e\r\n    \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e\r\n    \u003cscript src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"\u003e\u003c/script\u003e\r\n    \u003cscript src=\"https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js\"\u003e\u003c/script\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n    \u003cheader\u003e\r\n        \u003cnav\u003e\r\n            \u003cdiv class=\"logo\"\u003eOntology Explorer\u003c/div\u003e\r\n            \u003cdiv class=\"menu\"\u003e\r\n                \u003cbutton id=\"upload-button\"\u003eCharger des fichiers\u003c/button\u003e\r\n                \u003cbutton id=\"about-button\"\u003eÀ propos\u003c/button\u003e\r\n            \u003c/div\u003e\r\n        \u003c/nav\u003e\r\n    \u003c/header\u003e\r\n\r\n    \u003cmain\u003e\r\n        \u003csection id=\"search-section\"\u003e\r\n            \u003cinput type=\"text\" id=\"search-input\" placeholder=\"Rechercher...\"\u003e\r\n            \u003cbutton id=\"search-button\"\u003eRechercher\u003c/button\u003e\r\n            \u003cselect id=\"ontology-select\"\u003e\r\n                \u003coption value=\"\"\u003eTous les fichiers\u003c/option\u003e\r\n            \u003c/select\u003e\r\n            \u003cselect id=\"element-type-select\"\u003e\r\n                \u003coption value=\"\"\u003eTous les types\u003c/option\u003e\r\n            \u003c/select\u003e\r\n        \u003c/section\u003e\r\n\r\n        \u003cdiv class=\"content-wrapper\"\u003e\r\n            \u003cdiv class=\"left-column\"\u003e\r\n                \u003csection id=\"results-section\"\u003e\r\n                    \u003ch2\u003eRésultats\u003c/h2\u003e\r\n                    \u003cdiv id=\"results-list\"\u003e\u003c/div\u003e\r\n                \u003c/section\u003e\r\n            \u003c/div\u003e\r\n            \u003cdiv class=\"right-column\"\u003e\r\n                \u003csection id=\"details-section\"\u003e\r\n                    \u003ch2\u003eDétails\u003c/h2\u003e\r\n                    \u003cdiv id=\"element-details\"\u003e\u003c/div\u003e\r\n                    \u003cdiv id=\"element-contexts\"\u003e\u003c/div\u003e\r\n                \u003c/section\u003e\r\n            \u003c/div\u003e\r\n        \u003c/div\u003e\r\n        \r\n        \u003cdiv class=\"relations-wrapper\"\u003e\r\n            \u003csection id=\"graph-section\"\u003e\r\n                \u003ch2\u003eGraphique des relations\u003c/h2\u003e\r\n                \u003cdiv id=\"element-relations-graph\"\u003e\u003c/div\u003e\r\n            \u003c/section\u003e\r\n            \u003csection id=\"relations-section\"\u003e\r\n                \u003ch2\u003eListe des relations\u003c/h2\u003e\r\n                \u003cdiv id=\"element-relations-list\"\u003e\u003c/div\u003e\r\n            \u003c/section\u003e\r\n        \u003c/div\u003e\r\n    \u003c/main\u003e\r\n\r\n    \u003c!-- Modal de chargement --\u003e\r\n    \u003cdiv id=\"upload-modal\" class=\"modal\"\u003e\r\n        \u003cdiv class=\"modal-content\"\u003e\r\n            \u003cspan class=\"close\"\u003e\u0026times;\u003c/span\u003e\r\n            \u003ch2\u003eCharger des fichiers\u003c/h2\u003e\r\n            \r\n            \u003cdiv id=\"error-message\" class=\"error-message\"\u003e\u003c/div\u003e\r\n            \u003cdiv id=\"success-message\" class=\"success-message\"\u003e\u003c/div\u003e\r\n            \r\n            \u003cform id=\"upload-form\"\u003e\r\n                \u003cdiv class=\"form-group\"\u003e\r\n                    \u003clabel for=\"ontology-file\"\u003eFichier d'ontologie (TSV, OWL, RDF):\u003c/label\u003e\r\n                    \u003cinput type=\"file\" id=\"ontology-file\" name=\"ontologyFile\" accept=\".tsv,.owl,.rdf\" required\u003e\r\n                    \u003csmall class=\"help-text\"\u003eFichier principal contenant l'ontologie\u003c/small\u003e\r\n                \u003c/div\u003e\r\n                \u003cdiv class=\"form-group\"\u003e\r\n                    \u003clabel for=\"metadata-file\"\u003eFichier de métadonnées (JSON):\u003c/label\u003e\r\n                    \u003cinput type=\"file\" id=\"metadata-file\" name=\"metadataFile\" accept=\".json\" required\u003e\r\n                    \u003csmall class=\"help-text\"\u003eMétadonnées de la source (obligatoire)\u003c/small\u003e\r\n                \u003c/div\u003e\r\n                \u003cdiv class=\"form-group\"\u003e\r\n                    \u003clabel for=\"context-file\"\u003eFichier de contexte (JSON):\u003c/label\u003e\r\n                    \u003cinput type=\"file\" id=\"context-file\" name=\"contextFile\" accept=\".json\"\u003e\r\n                    \u003csmall class=\"help-text\"\u003eContextes des éléments (optionnel)\u003c/small\u003e\r\n                \u003c/div\u003e\r\n                \u003cdiv class=\"form-actions\"\u003e\r\n                    \u003cbutton type=\"submit\" class=\"primary-button\"\u003eCharger\u003c/button\u003e\r\n                    \u003cbutton type=\"button\" class=\"secondary-button\" onclick=\"closeModal()\"\u003eAnnuler\u003c/button\u003e\r\n                \u003c/div\u003e\r\n            \u003c/form\u003e\r\n            \r\n            \u003cdiv id=\"upload-progress\" class=\"hidden\"\u003e\r\n                \u003cdiv class=\"spinner\"\u003e\u003c/div\u003e\r\n                \u003cp\u003eChargement en cours...\u003c/p\u003e\r\n            \u003c/div\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003c!-- Tooltip pour les métadonnées --\u003e\r\n    \u003cdiv id=\"metadata-tooltip\" class=\"metadata-tooltip\"\u003e\u003c/div\u003e\r\n\r\n    \u003c!-- Spinner de chargement global --\u003e\r\n    \u003cdiv id=\"loading-spinner\" class=\"loading-spinner hidden\"\u003e\r\n        \u003cdiv class=\"spinner\"\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n\r\n    \u003c!-- Scripts --\u003e\r\n    \u003cscript type=\"module\" src=\"main.js\"\u003e\u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e",
    "size": 4622,
    "modTime": "2024-10-30T22:47:03.8766996+01:00",
    "path": "web\\index.html"
  },
  {
    "name": "main.js",
    "content": "// main.js\r\nimport { initUI } from './ui.js';\r\nimport { initSearch, handleSearch } from './search.js';\r\nimport { initOntologyLoader } from './ontologyLoader.js';\r\nimport './results.js';\r\n\r\n// Fonction utilitaire pour afficher les messages d'erreur\r\nexport function showErrorMessage(message) {\r\n    alert(message);\r\n}\r\n\r\n// Initialisation de l'application\r\ndocument.addEventListener('DOMContentLoaded', async () =\u003e {\r\n    try {\r\n        await initUI();\r\n        initSearch();\r\n        initOntologyLoader();\r\n\r\n        // Ajouter un écouteur pour l'événement personnalisé\r\n        document.addEventListener('performSearch', (event) =\u003e {\r\n            const searchQuery = event.detail.query;\r\n            document.getElementById('search-input').value = searchQuery;\r\n            handleSearch();\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Erreur lors de l\\'initialisation:', error);\r\n        showErrorMessage('Une erreur est survenue lors de l\\'initialisation de l\\'application.');\r\n    }\r\n});\r\n\r\nwindow.addEventListener('resize', () =\u003e {\r\n    const selectedElement = document.querySelector('.result-item.selected');\r\n    if (selectedElement) {\r\n        const elementName = selectedElement.querySelector('h3').textContent;\r\n        showElementDetails(elementName);\r\n    }\r\n});",
    "size": 1294,
    "modTime": "2024-10-30T22:47:03.8792161+01:00",
    "path": "web\\main.js"
  },
  {
    "name": "ontologyLoader.js",
    "content": "// web/ontologyLoader.js\r\nimport { uploadOntology } from './api.js';\r\nimport { showErrorMessage } from './main.js';\r\n\r\n// Initialisation du chargeur d'ontologie\r\nexport function initOntologyLoader() {\r\n    const uploadButton = document.getElementById('upload-button');\r\n    const uploadModal = document.getElementById('upload-modal');\r\n    const closeButton = uploadModal?.querySelector('.close');\r\n    const uploadForm = document.getElementById('upload-form');\r\n    const uploadProgress = document.getElementById('upload-progress');\r\n    const errorMessage = document.getElementById('error-message');\r\n    const successMessage = document.getElementById('success-message');\r\n\r\n    // Vérifier que tous les éléments nécessaires sont présents\r\n    if (!uploadButton || !uploadModal || !closeButton || !uploadForm || !uploadProgress) {\r\n        console.error(\"Un ou plusieurs éléments requis sont manquants\");\r\n        return;\r\n    }\r\n\r\n    // Fonction pour réinitialiser les messages\r\n    const resetMessages = () =\u003e {\r\n        if (errorMessage) errorMessage.style.display = 'none';\r\n        if (successMessage) successMessage.style.display = 'none';\r\n    };\r\n\r\n    // Ouvrir le modal\r\n    uploadButton.addEventListener('click', () =\u003e {\r\n        uploadModal.style.display = 'block';\r\n        resetMessages();\r\n    });\r\n\r\n    // Fermer le modal\r\n    closeButton.addEventListener('click', () =\u003e {\r\n        uploadModal.style.display = 'none';\r\n        resetMessages();\r\n        uploadForm.reset();\r\n    });\r\n\r\n    // Fermer le modal en cliquant à l'extérieur\r\n    window.addEventListener('click', (event) =\u003e {\r\n        if (event.target === uploadModal) {\r\n            uploadModal.style.display = 'none';\r\n            resetMessages();\r\n            uploadForm.reset();\r\n        }\r\n    });\r\n\r\n    // Gérer la soumission du formulaire\r\n    uploadForm.addEventListener('submit', async (event) =\u003e {\r\n        event.preventDefault();\r\n        resetMessages();\r\n        \r\n        try {\r\n            // Récupérer les fichiers\r\n            const ontologyFile = document.getElementById('ontology-file')?.files[0];\r\n            const metadataFile = document.getElementById('metadata-file')?.files[0];\r\n\r\n            // Vérifier que les fichiers requis sont présents\r\n            if (!ontologyFile || !metadataFile) {\r\n                throw new Error('Les fichiers d\\'ontologie et de métadonnées sont obligatoires');\r\n            }\r\n\r\n            // Afficher le spinner de chargement\r\n            uploadForm.classList.add('hidden');\r\n            uploadProgress.classList.remove('hidden');\r\n            \r\n            // Préparer les données\r\n            const formData = new FormData();\r\n            formData.append('ontologyFile', ontologyFile);\r\n            formData.append('metadataFile', metadataFile);\r\n            \r\n            // Ajouter le fichier de contexte s'il est présent\r\n            const contextFile = document.getElementById('context-file')?.files[0];\r\n            if (contextFile) {\r\n                formData.append('contextFile', contextFile);\r\n            }\r\n\r\n            // Envoyer les fichiers\r\n            const response = await uploadOntology(formData);\r\n            \r\n            // Afficher le message de succès\r\n            if (successMessage) {\r\n                successMessage.textContent = 'Ontologie chargée avec succès';\r\n                successMessage.style.display = 'block';\r\n            }\r\n\r\n            // Réinitialiser et fermer après un délai\r\n            setTimeout(() =\u003e {\r\n                uploadModal.style.display = 'none';\r\n                uploadForm.reset();\r\n                resetMessages();\r\n                // Déclencher un événement pour mettre à jour l'interface\r\n                document.dispatchEvent(new CustomEvent('ontologyLoaded'));\r\n            }, 2000);\r\n\r\n        } catch (error) {\r\n            console.error('Erreur lors du chargement:', error);\r\n            if (errorMessage) {\r\n                errorMessage.textContent = error.message || 'Une erreur est survenue lors du chargement';\r\n                errorMessage.style.display = 'block';\r\n            }\r\n        } finally {\r\n            // Toujours réafficher le formulaire et cacher le spinner\r\n            uploadForm.classList.remove('hidden');\r\n            uploadProgress.classList.add('hidden');\r\n        }\r\n    });\r\n}\r\n\r\n// Fonction pour fermer le modal de manière programmée\r\nexport function closeModal() {\r\n    const uploadModal = document.getElementById('upload-modal');\r\n    const uploadForm = document.getElementById('upload-form');\r\n    const errorMessage = document.getElementById('error-message');\r\n    const successMessage = document.getElementById('success-message');\r\n\r\n    if (uploadModal) {\r\n        uploadModal.style.display = 'none';\r\n        if (uploadForm) uploadForm.reset();\r\n        if (errorMessage) errorMessage.style.display = 'none';\r\n        if (successMessage) successMessage.style.display = 'none';\r\n    }\r\n}",
    "size": 4966,
    "modTime": "2024-10-30T22:47:03.8812134+01:00",
    "path": "web\\ontologyLoader.js"
  },
  {
    "name": "results.js",
    "content": "// web/results.js\r\n\r\nimport { \r\n    getElementDetails, \r\n    getElementRelations,\r\n    loadOntologies \r\n} from './api.js';\r\nimport { createRelationsGraph } from './graph.js';\r\nimport { showErrorMessage } from './main.js';\r\nimport { performSearch } from './search.js'; // Ajout de l'import manquant\r\n\r\nexport function displayResults(results) {\r\n    console.log(\"Received results:\", results);\r\n    const resultsList = document.getElementById('results-list');\r\n    resultsList.innerHTML = '';\r\n\r\n    if (!results || results.length === 0) {\r\n        resultsList.innerHTML = '\u003cdiv class=\"empty-state\"\u003eAucun résultat trouvé\u003c/div\u003e';\r\n        return;\r\n    }\r\n    \r\n    results.forEach(result =\u003e {\r\n        const resultItem = document.createElement('div');\r\n        resultItem.className = 'result-item';\r\n        \r\n        // Extraire les informations spécifiques au fichier\r\n        const metadata = result.SourceMetadata;\r\n        let fileID = result.FileID;  // Ceci devrait être le FileID spécifique à ce résultat\r\n        let fileInfo = null;\r\n\r\n        console.log(\"Processing result:\", result);\r\n\r\n        if (metadata \u0026\u0026 metadata.files) {\r\n            if (fileID \u0026\u0026 metadata.files[fileID]) {\r\n                fileInfo = metadata.files[fileID];\r\n            } else {\r\n                console.warn(\"FileID not found in metadata, using first available file\");\r\n                const fileIds = Object.keys(metadata.files);\r\n                if (fileIds.length \u003e 0) {\r\n                    fileID = fileIds[0];\r\n                    fileInfo = metadata.files[fileID];\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(\"Using FileID:\", fileID, \"FileInfo:\", fileInfo);\r\n\r\n        // Stocker les informations dans dataset\r\n        resultItem.dataset.fileId = fileID || '';\r\n        resultItem.dataset.sourceFile = fileInfo ? fileInfo.source_file : '';\r\n        resultItem.dataset.directory = fileInfo ? fileInfo.directory : '';\r\n        resultItem.dataset.fileDate = fileInfo ? fileInfo.file_date : '';\r\n        resultItem.dataset.sha256Hash = fileInfo ? fileInfo.sha256_hash : '';\r\n        resultItem.dataset.ontologyFile = metadata ? metadata.ontology_file : '';\r\n        resultItem.dataset.processingDate = metadata ? metadata.processing_date : '';\r\n        \r\n        resultItem.innerHTML = `\r\n            \u003cdiv class=\"result-item-content\"\u003e\r\n                \u003ch3\u003e${escapeHtml(result.ElementName)}\u003c/h3\u003e\r\n                \u003cp\u003e${escapeHtml(result.Description || '')}\u003c/p\u003e\r\n            \u003c/div\u003e\r\n            \u003cdiv class=\"result-item-meta\"\u003e\r\n                \u003cdiv class=\"file-name\"\u003e${escapeHtml(fileInfo ? fileInfo.source_file : 'Fichier inconnu')} (${fileID || 'ID inconnu'})\u003c/div\u003e\r\n            \u003c/div\u003e\r\n        `;\r\n\r\n        // Gestion de la fenêtre flottante (tooltip)\r\n        resultItem.addEventListener('mouseenter', (e) =\u003e {\r\n            showMetadataTooltip(e.currentTarget);\r\n        });\r\n\r\n        resultItem.addEventListener('mousemove', (e) =\u003e {\r\n            updateTooltipPosition(e);\r\n        });\r\n\r\n        resultItem.addEventListener('mouseleave', () =\u003e {\r\n            hideMetadataTooltip();\r\n        });\r\n\r\n        // Gestion de la sélection de l'élément\r\n        resultItem.addEventListener('click', () =\u003e {\r\n            document.querySelectorAll('.result-item').forEach(item =\u003e \r\n                item.classList.remove('selected'));\r\n            resultItem.classList.add('selected');\r\n            showElementDetails(result.ElementName);\r\n        });\r\n\r\n        resultsList.appendChild(resultItem);\r\n    });\r\n}\r\n\r\nfunction escapeHtml(unsafe) {\r\n    if (!unsafe) return '';\r\n    return unsafe\r\n        .replace(/\u0026/g, \"\u0026amp;\")\r\n        .replace(/\u003c/g, \"\u0026lt;\")\r\n        .replace(/\u003e/g, \"\u0026gt;\")\r\n        .replace(/\"/g, \"\u0026quot;\")\r\n        .replace(/'/g, \"\u0026#039;\");\r\n}\r\n\r\nfunction openSourceFile(metadata, fileID) {\r\n    if (!metadata || !fileID) {\r\n        console.error('Métadonnées ou FileID manquants pour ouvrir le fichier');\r\n        return;\r\n    }\r\n\r\n    const fileInfo = metadata.files[fileID];\r\n    if (!fileInfo) {\r\n        console.error('Informations du fichier non trouvées');\r\n        return;\r\n    }\r\n\r\n    // Construisez l'URL pour ouvrir le fichier en visualisation\r\n    const viewerUrl = `/api/view-source?path=${encodeURIComponent(fileInfo.directory + '/' + fileInfo.source_file)}`;\r\n    \r\n    // Ouvrez le fichier dans un nouvel onglet ou une nouvelle fenêtre\r\n    window.open(viewerUrl, '_blank');\r\n}\r\n\r\nasync function showElementDetails(elementName) {\r\n    const loadingSpinner = document.getElementById('loading-spinner');\r\n    if (loadingSpinner) loadingSpinner.classList.remove('hidden');\r\n\r\n    try {\r\n        // Récupérer les détails de l'élément\r\n        const element = await getElementDetails(elementName);\r\n        console.log(\"Détails de l'élément reçus:\", element);\r\n\r\n        // Afficher les détails\r\n        const detailsContainer = document.getElementById('element-details');\r\n        if (detailsContainer) {\r\n            detailsContainer.innerHTML = `\r\n                \u003cdiv class=\"element-info\"\u003e\r\n                    \u003ch3\u003e${escapeHtml(element.Name)}\u003c/h3\u003e\r\n                    \u003cp\u003e\u003cstrong\u003eType:\u003c/strong\u003e ${escapeHtml(element.Type || '')}\u003c/p\u003e\r\n                    \u003cp\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e ${escapeHtml(element.Description || '')}\u003c/p\u003e\r\n                \u003c/div\u003e\r\n            `;\r\n        }\r\n\r\n        // Afficher les contextes\r\n        displayElementContexts(element);\r\n        \r\n        // Gérer les relations\r\n        const relations = await getElementRelations(elementName);\r\n        if (relations \u0026\u0026 relations.length \u003e 0) {\r\n            createRelationsGraph(element, relations);\r\n            displayRelationsList(relations);\r\n        } else {\r\n            document.getElementById('element-relations-graph').innerHTML = \r\n                '\u003cdiv class=\"empty-state\"\u003eAucune relation à afficher\u003c/div\u003e';\r\n            document.getElementById('element-relations-list').innerHTML = \r\n                '\u003cdiv class=\"empty-state\"\u003eAucune relation disponible\u003c/div\u003e';\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des détails:', error);\r\n        showErrorMessage('Impossible de charger les détails de l\\'élément.');\r\n    } finally {\r\n        if (loadingSpinner) loadingSpinner.classList.add('hidden');\r\n    }\r\n}\r\n\r\n// Rendre les éléments marqués cliquables\r\nfunction displayElementContexts(element) {\r\n    const contextsContainer = document.getElementById('element-contexts');\r\n    if (!contextsContainer) return;\r\n\r\n    contextsContainer.innerHTML = '\u003ch3\u003eContextes\u003c/h3\u003e';\r\n\r\n    if (!element.Contexts || element.Contexts.length === 0) {\r\n        contextsContainer.innerHTML += '\u003cdiv class=\"empty-state\"\u003eAucun contexte disponible\u003c/div\u003e';\r\n        return;\r\n    }\r\n\r\n    element.Contexts.forEach((ctx, index) =\u003e {\r\n        const contextDiv = document.createElement('div');\r\n        contextDiv.className = 'context';\r\n\r\n        const highlightedBefore = highlightElement(ctx.before?.join(' ') || '', element.Name);\r\n        const highlightedAfter = highlightElement(ctx.after?.join(' ') || '', element.Name);\r\n\r\n        contextDiv.innerHTML = `\r\n        \u003cdiv class=\"context-content\"\u003e\r\n            \u003cspan class=\"before\"\u003e${highlightElement(ctx.before?.join(' ') || '', element.Name)}\u003c/span\u003e\r\n            \u003cmark class=\"element\"\u003e${escapeHtml(ctx.element)}\u003c/mark\u003e\r\n            \u003cspan class=\"after\"\u003e${highlightElement(ctx.after?.join(' ') || '', element.Name)}\u003c/span\u003e\r\n        \u003c/div\u003e\r\n        \u003cdiv class=\"context-meta\"\u003e\r\n            \u003cspan class=\"file-id\"\u003eFileID: ${ctx.file_id} - \u003c/span\u003e\r\n            \u003cspan class=\"file-position\"\u003ePosition: ${ctx.file_position}\u003c/span\u003e\r\n        \u003c/div\u003e\r\n    `;\r\n        // Ajouter les gestionnaires d'événements pour les éléments marqués\r\n        contextDiv.querySelectorAll('mark').forEach(mark =\u003e {\r\n            mark.style.cursor = 'pointer';\r\n            mark.addEventListener('click', () =\u003e {\r\n                performSearch(mark.textContent);\r\n            });\r\n        });\r\n\r\n        contextsContainer.appendChild(contextDiv);\r\n    });\r\n}\r\n\r\nfunction displayRelationsList(relations) {\r\n    const listContainer = document.getElementById('element-relations-list');\r\n    if (!listContainer) return;\r\n\r\n    listContainer.innerHTML = '';\r\n\r\n    if (!relations || relations.length === 0) {\r\n        listContainer.innerHTML = '\u003cdiv class=\"empty-state\"\u003eAucune relation disponible\u003c/div\u003e';\r\n        return;\r\n    }\r\n\r\n    const ul = document.createElement('ul');\r\n    ul.className = 'relations-list';\r\n\r\n    relations.forEach(relation =\u003e {\r\n        const li = document.createElement('li');\r\n        li.className = 'relation-item';\r\n        li.innerHTML = `\r\n            \u003cspan class=\"relation-source\"\u003e${escapeHtml(relation.Source)}\u003c/span\u003e\r\n            \u003cspan class=\"relation-type\"\u003e${escapeHtml(relation.Type)}\u003c/span\u003e\r\n            \u003cspan class=\"relation-target\"\u003e${escapeHtml(relation.Target)}\u003c/span\u003e\r\n        `;\r\n        ul.appendChild(li);\r\n    });\r\n\r\n    listContainer.appendChild(ul);\r\n}\r\n\r\n// Fonction pour afficher le tooltip\r\nfunction showMetadataTooltip(element) {\r\n    const tooltip = document.getElementById('metadata-tooltip');\r\n    if (!tooltip) {\r\n        console.error(\"Tooltip element not found in the DOM\");\r\n        return;\r\n    }\r\n    if (!element) {\r\n        console.error(\"Source element is undefined\");\r\n        return;\r\n    }\r\n\r\n    console.log(\"Element dataset:\", element.dataset);\r\n\r\n    const fileID = element.dataset.fileId;\r\n    const sourceFile = element.dataset.sourceFile;\r\n    const directory = element.dataset.directory;\r\n    const fileDate = element.dataset.fileDate;\r\n    const sha256Hash = element.dataset.sha256Hash;\r\n    const ontologyFile = element.dataset.ontologyFile;\r\n    const processingDate = element.dataset.processingDate;\r\n\r\n    console.log(\"Showing tooltip for file:\", fileID, sourceFile);\r\n\r\n    const formattedDate = fileDate ? new Date(fileDate).toLocaleString() : 'Date non disponible';\r\n    const formattedProcessingDate = processingDate ? new Date(processingDate).toLocaleString() : 'Date non disponible';\r\n\r\n    tooltip.innerHTML = `\r\n        \u003cdiv class=\"tooltip-content\"\u003e\r\n            \u003ch4\u003eInformations du document\u003c/h4\u003e\r\n            \u003cp\u003e\u003cstrong\u003eFichier ontologie :\u003c/strong\u003e ${escapeHtml(ontologyFile || 'Non spécifié')}\u003c/p\u003e\r\n            \u003cp\u003e\u003cstrong\u003eDate de traitement :\u003c/strong\u003e ${formattedProcessingDate}\u003c/p\u003e\r\n            \u003cp\u003e\u003cstrong\u003eFile ID :\u003c/strong\u003e ${escapeHtml(fileID || 'Non spécifié')}\u003c/p\u003e\r\n            \u003cp\u003e\u003cstrong\u003eFichier source :\u003c/strong\u003e ${escapeHtml(sourceFile || 'Non spécifié')}\u003c/p\u003e\r\n            \u003cp\u003e\u003cstrong\u003eRépertoire :\u003c/strong\u003e ${escapeHtml(directory || 'Non spécifié')}\u003c/p\u003e\r\n            \u003cp\u003e\u003cstrong\u003eDate du fichier :\u003c/strong\u003e ${formattedDate}\u003c/p\u003e\r\n            \u003cp\u003e\u003cstrong\u003eSHA256 :\u003c/strong\u003e \u003cspan class=\"hash\"\u003e${sha256Hash || 'Non disponible'}\u003c/span\u003e\u003c/p\u003e\r\n        \u003c/div\u003e\r\n    `;\r\n\r\n    tooltip.style.display = 'block';\r\n}\r\n\r\n// Fonction pour mettre à jour la position du tooltip\r\nfunction updateTooltipPosition(event) {\r\n    const tooltip = document.getElementById('metadata-tooltip');\r\n    if (!tooltip) return;\r\n\r\n    const margin = 10;\r\n    const tooltipRect = tooltip.getBoundingClientRect();\r\n    const windowWidth = window.innerWidth;\r\n    const windowHeight = window.innerHeight;\r\n\r\n    let left = event.clientX + margin;\r\n    let top = event.clientY + margin;\r\n\r\n    if (left + tooltipRect.width \u003e windowWidth) {\r\n        left = windowWidth - tooltipRect.width - margin;\r\n    }\r\n\r\n    if (top + tooltipRect.height \u003e windowHeight) {\r\n        top = windowHeight - tooltipRect.height - margin;\r\n    }\r\n\r\n    tooltip.style.left = `${left}px`;\r\n    tooltip.style.top = `${top}px`;\r\n}\r\n\r\n// Fonction pour cacher le tooltip\r\nfunction hideMetadataTooltip() {\r\n    const tooltip = document.getElementById('metadata-tooltip');\r\n    if (tooltip) {\r\n        tooltip.style.display = 'none';\r\n    }\r\n}\r\n\r\nfunction highlightElement(text, elementName) {\r\n    if (!text) return '';\r\n    return text.replace(new RegExp(elementName, 'gi'), match =\u003e `\u003cmark\u003e${match}\u003c/mark\u003e`);\r\n}\r\n\r\n// Export des fonctions nécessaires\r\nexport { showElementDetails };",
    "size": 12127,
    "modTime": "2024-11-18T11:48:55.6433154+01:00",
    "path": "web\\results.js"
  },
  {
    "name": "search.js",
    "content": "// web/search.js\r\n\r\nimport { searchOntologies } from './api.js';\r\nimport { displayResults } from './results.js';\r\nimport { showErrorMessage } from './main.js';\r\n\r\nconst searchInput = document.getElementById('search-input');\r\nconst searchButton = document.getElementById('search-button');\r\nconst ontologySelect = document.getElementById('ontology-select');\r\nconst elementTypeSelect = document.getElementById('element-type-select');\r\n\r\n// Initialisation de la recherche\r\nexport function initSearch() {\r\n    if (!searchButton || !searchInput || !ontologySelect || !elementTypeSelect) {\r\n        console.error('Éléments de recherche manquants');\r\n        return;\r\n    }\r\n\r\n    // Gestionnaire de clic sur le bouton de recherche\r\n    searchButton.addEventListener('click', handleSearch);\r\n\r\n    // Gestionnaire de la touche Entrée dans le champ de recherche\r\n    searchInput.addEventListener('keypress', (e) =\u003e {\r\n        if (e.key === 'Enter') {\r\n            e.preventDefault();\r\n            handleSearch();\r\n        }\r\n    });\r\n\r\n    // Recherche automatique lors du changement de filtre\r\n    ontologySelect.addEventListener('change', debounce(handleSearch, 300));\r\n    elementTypeSelect.addEventListener('change', debounce(handleSearch, 300));\r\n\r\n    // Recherche automatique lors de la saisie\r\n    searchInput.addEventListener('input', debounce(handleSearch, 300));\r\n}\r\n\r\n// Gestion de la recherche\r\nexport async function handleSearch(event) {\r\n    if (event) event.preventDefault();\r\n\r\n    const query = document.getElementById('search-input').value.trim();\r\n    const fileId = document.getElementById('ontology-select').value;\r\n    const elementType = document.getElementById('element-type-select').value;\r\n\r\n    console.log(\"Search parameters:\", { query, fileId, elementType });\r\n\r\n    if (!query) {\r\n        console.log(\"Search aborted: query is empty\");\r\n        showErrorMessage('Veuillez entrer un terme de recherche.');\r\n        return;\r\n    }\r\n\r\n    const loadingSpinner = document.getElementById('loading-spinner');\r\n    if (loadingSpinner) loadingSpinner.classList.remove('hidden');\r\n\r\n    try {\r\n        const results = await searchOntologies(query, fileId, elementType);\r\n        console.log(\"Search results:\", results);\r\n        \r\n        displayResults(results);\r\n\r\n    } catch (error) {\r\n        console.error('Erreur lors de la recherche:', error);\r\n        showErrorMessage('Une erreur est survenue lors de la recherche: ' + error.message);\r\n        displayResults([]);\r\n    } finally {\r\n        if (loadingSpinner) loadingSpinner.classList.add('hidden');\r\n    }\r\n}\r\n\r\n// Fonction de recherche explicite pour être appelée depuis d'autres modules\r\nexport function performSearch(query) {\r\n    if (searchInput) {\r\n        searchInput.value = query;\r\n        handleSearch();\r\n    }\r\n}\r\n\r\n// Utilitaire pour le debounce\r\nfunction debounce(func, wait) {\r\n    let timeout;\r\n    return function executedFunction(...args) {\r\n        const later = () =\u003e {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}",
    "size": 3130,
    "modTime": "2024-11-18T12:31:18.5214432+01:00",
    "path": "web\\search.js"
  },
  {
    "name": "style.css",
    "content": ":root {\r\n    --primary-color: #3498db;\r\n    --secondary-color: #2c3e50;\r\n    --background-color: #ecf0f1;\r\n    --text-color: #34495e;\r\n    --border-color: #ddd;\r\n}\r\n\r\n* {\r\n    box-sizing: border-box;\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\n\r\nbody {\r\n    font-family: 'Roboto', sans-serif;\r\n    line-height: 1.4;\r\n    color: var(--text-color);\r\n    background-color: var(--background-color);\r\n    height: 100vh;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n/* Header and Navigation */\r\nheader {\r\n    background-color: var(--primary-color);\r\n    color: white;\r\n    padding: 0.5rem;\r\n}\r\n\r\nnav {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    max-width: 1400px;\r\n    margin: 0 auto;\r\n}\r\n\r\n.logo {\r\n    font-size: 1.3rem;\r\n    font-weight: bold;\r\n}\r\n\r\n.menu button {\r\n    background: none;\r\n    border: 1px solid white;\r\n    color: white;\r\n    cursor: pointer;\r\n    margin-left: 0.5rem;\r\n    padding: 0.3rem 0.8rem;\r\n    border-radius: 4px;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n/* Main Layout */\r\nmain {\r\n    flex-grow: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    overflow: hidden;\r\n}\r\n\r\n/* Search Section */\r\n#search-section {\r\n    padding: 1rem;\r\n    display: flex;\r\n    gap: 1rem;\r\n    background-color: white;\r\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n}\r\n\r\n#search-input, #ontology-select, #element-type-select {\r\n    flex-grow: 1;\r\n    padding: 0.5rem;\r\n    font-size: 1rem;\r\n    border: 1px solid var(--border-color);\r\n    border-radius: 4px;\r\n}\r\n\r\n#search-button {\r\n    padding: 0.5rem 1rem;\r\n    background-color: var(--primary-color);\r\n    color: white;\r\n    border: none;\r\n    cursor: pointer;\r\n    border-radius: 4px;\r\n}\r\n\r\n/* Content Layout */\r\n.content-wrapper, .relations-wrapper {\r\n    display: flex;\r\n    margin: 0.5rem;\r\n    gap: 1rem;\r\n}\r\n\r\n.content-wrapper {\r\n    height: 40vh;\r\n}\r\n\r\n.relations-wrapper {\r\n    height: calc(60vh - 2rem);\r\n}\r\n\r\n.left-column, .right-column {\r\n    flex: 1;\r\n    background-color: white;\r\n    border-radius: 8px;\r\n    box-shadow: 0 2px 10px rgba(0,0,0,0.1);\r\n    overflow: hidden;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n/* Graph and Relations Sections */\r\n#graph-section {\r\n    flex: 2; /* Takes 2/3 of the space */\r\n    background-color: white;\r\n    border-radius: 8px;\r\n    box-shadow: 0 2px 10px rgba(0,0,0,0.1);\r\n    overflow: hidden;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n#relations-section {\r\n    flex: 1; /* Takes 1/3 of the space */\r\n    background-color: white;\r\n    border-radius: 8px;\r\n    box-shadow: 0 2px 10px rgba(0,0,0,0.1);\r\n    overflow: hidden;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n/* Section Headers */\r\n#results-section, #details-section {\r\n    display: flex;\r\n    flex-direction: column;\r\n    height: 100%;\r\n}\r\n\r\n#results-section h2, #details-section h2, #graph-section h2, #relations-section h2 {\r\n    background-color: #aca8a8;\r\n    margin: 0;\r\n    padding: 0.1rem 1rem;\r\n    font-size: 1.1rem;\r\n    color: #333;\r\n    border-bottom: 1px solid #ddd;\r\n}\r\n\r\n/* Results and Lists */\r\n#results-list, #element-relations-list {\r\n    flex: 1;\r\n    height: 100%;\r\n    overflow-y: auto;\r\n    padding: 0.5rem;\r\n}\r\n\r\n/* Element Details and Contexts */\r\n#element-details, #element-contexts {\r\n    overflow-y: auto;\r\n    padding: 1rem;\r\n}\r\n\r\n#element-details {\r\n    flex: 0 0 auto;\r\n    background-color: #f8f9fa;\r\n}\r\n\r\n#element-contexts {\r\n    flex: 1;\r\n}\r\n\r\n/* Results Items */\r\n.result-item {\r\n    position: relative;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: start;\r\n    padding: 0.8rem;\r\n    border-bottom: 1px solid #eee;\r\n    transition: background-color 0.3s ease;\r\n    cursor: pointer;\r\n}\r\n\r\n.result-item:hover {\r\n    background-color: #f5f5f5;\r\n}\r\n\r\n.result-item.selected {\r\n    background-color: #e6f3ff;\r\n    border-left: 4px solid var(--primary-color);\r\n}\r\n\r\n.result-item-content {\r\n    flex: 1;\r\n}\r\n\r\n.result-item-content h3 {\r\n    margin: 0 0 0.5rem 0;\r\n    font-size: 1rem;\r\n}\r\n\r\n.result-item-meta {\r\n    text-align: right;\r\n    min-width: 200px;\r\n    margin-left: 1rem;\r\n}\r\n\r\n.result-item-meta .file-name {\r\n    color: var(--primary-color);\r\n    font-size: 0.9rem;\r\n    font-weight: 500;\r\n    margin-bottom: 0.2rem;\r\n}\r\n\r\n.result-item-meta .file-path {\r\n    color: #666;\r\n    font-size: 0.8rem;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    max-width: 200px;\r\n}\r\n\r\n/* Metadata Tooltip */\r\n.metadata-tooltip {\r\n    position: absolute;\r\n    background: white;\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n    box-shadow: 0 4px 15px rgba(0,0,0,0.2);\r\n    z-index: 1000;\r\n    min-width: 300px;\r\n    max-width: 400px;\r\n    display: none;\r\n    pointer-events: none;\r\n}\r\n\r\n.tooltip-content {\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.tooltip-content h4 {\r\n    margin: 0 0 0.8rem 0;\r\n    color: var(--primary-color);\r\n}\r\n\r\n.tooltip-content p {\r\n    margin: 0.4rem 0;\r\n}\r\n\r\n.tooltip-content .hash {\r\n    font-family: 'Roboto Mono', monospace;\r\n    font-size: 0.85em;\r\n    color: #666;\r\n    word-break: break-all;\r\n}\r\n\r\n/* Context Styling */\r\n.context {\r\n    padding: 1rem;\r\n    border-bottom: 1px solid #eee;\r\n}\r\n\r\n.context-content {\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.context-position {\r\n    font-size: 0.8rem;\r\n    color: #666;\r\n}\r\n\r\nmark {\r\n    background-color: yellow;\r\n    padding: 0.1rem 0.3rem;\r\n    border-radius: 2px;\r\n    cursor: pointer;\r\n    transition: background-color 0.2s ease;\r\n}\r\n\r\nmark:hover {\r\n    background-color: #ffd700;\r\n}\r\n\r\n/* Modal Styles */\r\n.modal {\r\n    display: none;\r\n    position: fixed;\r\n    z-index: 1000;\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n}\r\n\r\n.modal-content {\r\n    background-color: #fefefe;\r\n    margin: 15% auto;\r\n    padding: 20px;\r\n    border: 1px solid #888;\r\n    width: 80%;\r\n    max-width: 500px;\r\n    border-radius: 5px;\r\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.close {\r\n    color: #aaa;\r\n    float: right;\r\n    font-size: 28px;\r\n    font-weight: bold;\r\n    cursor: pointer;\r\n}\r\n\r\n/* Form Styles */\r\n.form-group {\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.form-group label {\r\n    display: block;\r\n    margin-bottom: 0.5rem;\r\n    font-weight: 500;\r\n}\r\n\r\n.help-text {\r\n    display: block;\r\n    margin-top: 0.25rem;\r\n    font-size: 0.875rem;\r\n    color: #6c757d;\r\n}\r\n\r\n/* Loading Spinner */\r\n.spinner {\r\n    border: 4px solid #f3f3f3;\r\n    border-top: 4px solid var(--primary-color);\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n    margin: 0 auto;\r\n}\r\n\r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n/* Utility Classes */\r\n.hidden {\r\n    display: none;\r\n}\r\n\r\n/* Empty States */\r\n.empty-state {\r\n    padding: 2rem;\r\n    text-align: center;\r\n    color: #666;\r\n    font-style: italic;\r\n    background-color: #f8f9fa;\r\n    border-radius: 4px;\r\n}\r\n\r\n.result-item-meta .file-name {\r\n    color: var(--primary-color);\r\n    font-size: 0.9rem;\r\n    font-weight: 500;\r\n    margin-top: 0.5rem;\r\n}",
    "size": 7054,
    "modTime": "2024-10-30T22:47:03.886213+01:00",
    "path": "web\\style.css"
  },
  {
    "name": "ui.js",
    "content": "// ui.js\r\nimport { loadOntologies, loadElementTypes } from './api.js';\r\n\r\n// Éléments du DOM\r\nconst ontologySelect = document.getElementById('ontology-select');\r\nconst elementTypeSelect = document.getElementById('element-type-select');\r\nconst uploadButton = document.getElementById('upload-button');\r\nconst uploadModal = document.getElementById('upload-modal');\r\nconst closeModal = document.querySelector('.close');\r\n\r\n// Initialisation de l'interface utilisateur\r\nexport async function initUI() {\r\n    console.log(\"Initializing UI\");\r\n    await populateOntologySelect();\r\n    await populateElementTypeSelect();\r\n    await updateOntologySelect(); \r\n    setupModalListeners();\r\n\r\n    document.addEventListener('ontologyLoaded', () =\u003e {\r\n        console.log(\"ontologyLoaded event triggered\");\r\n        updateOntologySelect();\r\n    });\r\n}\r\n\r\n// Remplir le sélecteur d'ontologies\r\nasync function populateOntologySelect() {\r\n    try {\r\n        const ontologies = await loadOntologies();\r\n        ontologySelect.innerHTML = '\u003coption value=\"\"\u003eToutes les ontologies\u003c/option\u003e';\r\n        ontologies.forEach(ontology =\u003e {\r\n            const option = document.createElement('option');\r\n            option.value = ontology.id;\r\n            option.textContent = ontology.name;\r\n            ontologySelect.appendChild(option);\r\n        });\r\n    } catch (error) {\r\n        console.error('Erreur lors du chargement des ontologies:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Remplir le sélecteur de types d'éléments\r\nasync function populateElementTypeSelect() {\r\n    try {\r\n        const types = await loadElementTypes();\r\n        elementTypeSelect.innerHTML = '\u003coption value=\"\"\u003eTous les types\u003c/option\u003e';\r\n        types.forEach(type =\u003e {\r\n            const option = document.createElement('option');\r\n            option.value = type;\r\n            option.textContent = type;\r\n            elementTypeSelect.appendChild(option);\r\n        });\r\n    } catch (error) {\r\n        console.error('Erreur lors du chargement des types d\\'éléments:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Configuration des écouteurs d'événements pour le modal\r\nfunction setupModalListeners() {\r\n    uploadButton.addEventListener('click', () =\u003e uploadModal.style.display = 'block');\r\n    closeModal.addEventListener('click', () =\u003e uploadModal.style.display = 'none');\r\n    window.addEventListener('click', (event) =\u003e {\r\n        if (event.target === uploadModal) {\r\n            uploadModal.style.display = 'none';\r\n        }\r\n    });\r\n}\r\nasync function updateOntologySelect() {\r\n    try {\r\n        const ontologies = await loadOntologies();\r\n        console.log(\"Ontologies received in updateOntologySelect:\", ontologies);\r\n        \r\n        const select = document.getElementById('ontology-select');\r\n        select.innerHTML = '\u003coption value=\"\"\u003eTous les fichiers\u003c/option\u003e';\r\n        \r\n        ontologies.forEach(ontology =\u003e {\r\n            console.log(\"Processing ontology:\", ontology);\r\n            if (ontology.Source \u0026\u0026 ontology.Source.files) {\r\n                Object.entries(ontology.Source.files).forEach(([fileId, fileInfo]) =\u003e {\r\n                    const option = document.createElement('option');\r\n                    option.value = fileId;\r\n                    option.textContent = `${ontology.name} - ${fileInfo.source_file}`;\r\n                    select.appendChild(option);\r\n                });\r\n            } else {\r\n                // Fallback si les informations de fichier ne sont pas disponibles\r\n                const option = document.createElement('option');\r\n                option.value = ontology.id;\r\n                option.textContent = ontology.name;\r\n                select.appendChild(option);\r\n            }\r\n        });\r\n\r\n        console.log(\"Select options after update:\", select.innerHTML);\r\n\r\n    } catch (error) {\r\n        console.error('Erreur lors de la mise à jour de la liste des fichiers:', error);\r\n        showErrorMessage('Erreur lors de la mise à jour de la liste des fichiers.');\r\n    }\r\n}",
    "size": 4013,
    "modTime": "2024-11-18T12:14:22.5460147+01:00",
    "path": "web\\ui.js"
  }
]