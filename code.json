[
  {
    "name": "main.go",
    "content": "package main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/api\"\r\n\t\"github.com/chrlesur/ontology-server/internal/config\"\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n)\r\n\r\nfunc main() {\r\n\t// Load configuration\r\n\tcfg, err := config.LoadConfig(\"config.yaml\")\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Failed to load configuration: %v\", err)\r\n\t}\r\n\r\n\t// Initialize logger\r\n\tlogLevel := logger.INFO // You might want to parse this from the config\r\n\tl, err := logger.NewLogger(logLevel, cfg.Logging.Directory)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Failed to initialize logger: %v\", err)\r\n\t}\r\n\r\n\tl.Info(\"Starting Ontology Server\")\r\n\r\n\t// Initialize storage\r\n\tmemoryStorage := storage.NewMemoryStorage()\r\n\r\n\t// Initialize router\r\n\trouter := api.NewRouter(memoryStorage)\r\n\r\n\t// Prepare HTTP server\r\n\taddr := fmt.Sprintf(\"%s:%d\", cfg.Server.Host, cfg.Server.Port)\r\n\tl.Info(fmt.Sprintf(\"Server listening on %s\", addr))\r\n\r\n\t// Start the server\r\n\terr = http.ListenAndServe(addr, router)\r\n\tif err != nil {\r\n\t\tl.Error(fmt.Sprintf(\"Server failed to start: %v\", err))\r\n\t}\r\n}\r\n",
    "size": 1157,
    "modTime": "2024-10-26T14:53:16.8382876+02:00",
    "path": "cmd\\server\\main.go"
  },
  {
    "name": "errors.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n)\r\n\r\n// APIError représente une erreur de l'API\r\ntype APIError struct {\r\n\tCode    int    `json:\"code\"`\r\n\tMessage string `json:\"message\"`\r\n}\r\n\r\nfunc (e APIError) Error() string {\r\n\treturn fmt.Sprintf(\"API Error %d: %s\", e.Code, e.Message)\r\n}\r\n\r\n// Constantes pour les codes d'erreur\r\nconst (\r\n\tErrBadRequest          = 400\r\n\tErrNotFound            = 404\r\n\tErrInternalServerError = 500\r\n)\r\n\r\n// Constantes pour les messages d'erreur communs\r\nconst (\r\n\tMsgInvalidInput        = \"Invalid input provided\"\r\n\tMsgResourceNotFound    = \"Requested resource not found\"\r\n\tMsgInternalServerError = \"An internal server error occurred\"\r\n)\r\n\r\n// NewAPIError crée une nouvelle instance de APIError\r\nfunc NewAPIError(code int, message string) APIError {\r\n\treturn APIError{Code: code, Message: message}\r\n}\r\n\r\n// WriteJSONError écrit une réponse d'erreur JSON\r\nfunc WriteJSONError(w http.ResponseWriter, err APIError) {\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tw.WriteHeader(err.Code)\r\n\tjson.NewEncoder(w).Encode(err)\r\n}\r\n",
    "size": 1084,
    "modTime": "2024-10-26T15:10:17.9357821+02:00",
    "path": "internal\\api\\errors.go"
  },
  {
    "name": "handlers.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gorilla/mux\"\r\n)\r\n\r\n// Handler encapsule les dépendances nécessaires pour gérer les requêtes API\r\ntype Handler struct {\r\n\tStorage *storage.MemoryStorage\r\n\tLogger  *logger.Logger\r\n\tSearch  *search.SearchEngine\r\n}\r\n\r\n// NewHandler crée une nouvelle instance de Handler avec le stockage, le logger et le moteur de recherche fournis\r\nfunc NewHandler(storage *storage.MemoryStorage, logger *logger.Logger, search *search.SearchEngine) *Handler {\r\n\treturn \u0026Handler{Storage: storage, Logger: logger, Search: search}\r\n}\r\n\r\n// GetOntology récupère une ontologie par son ID\r\nfunc (h *Handler) GetOntology(w http.ResponseWriter, r *http.Request) {\r\n\tvars := mux.Vars(r)\r\n\tid := vars[\"id\"]\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting ontology with ID: %s\", id))\r\n\r\n\tontology, err := h.Storage.GetOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting ontology: %v\", err))\r\n\t\tWriteJSONError(w, NewAPIError(ErrNotFound, MsgResourceNotFound))\r\n\t\treturn\r\n\t}\r\n\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tjson.NewEncoder(w).Encode(ontology)\r\n}\r\n\r\n// AddOntology ajoute une nouvelle ontologie\r\nfunc (h *Handler) AddOntology(w http.ResponseWriter, r *http.Request) {\r\n\tvar ontology models.Ontology\r\n\terr := json.NewDecoder(r.Body).Decode(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tWriteJSONError(w, NewAPIError(ErrBadRequest, MsgInvalidInput))\r\n\t\treturn\r\n\t}\r\n\r\n\t// Générer un ID unique\r\n\tontology.ID = fmt.Sprintf(\"onto_%d\", time.Now().UnixNano())\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Adding new ontology: %s with ID: %s\", ontology.Name, ontology.ID))\r\n\r\n\terr = h.Storage.AddOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error adding ontology: %v\", err))\r\n\t\tWriteJSONError(w, NewAPIError(ErrInternalServerError, MsgInternalServerError))\r\n\t\treturn\r\n\t}\r\n\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tw.WriteHeader(http.StatusCreated)\r\n\tjson.NewEncoder(w).Encode(ontology)\r\n}\r\n\r\n// UpdateOntology met à jour une ontologie existante\r\nfunc (h *Handler) UpdateOntology(w http.ResponseWriter, r *http.Request) {\r\n\tvars := mux.Vars(r)\r\n\tid := vars[\"id\"]\r\n\r\n\tvar ontology models.Ontology\r\n\terr := json.NewDecoder(r.Body).Decode(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tWriteJSONError(w, NewAPIError(ErrBadRequest, MsgInvalidInput))\r\n\t\treturn\r\n\t}\r\n\r\n\tontology.ID = id\r\n\th.Logger.Info(fmt.Sprintf(\"Updating ontology: %s\", id))\r\n\r\n\terr = h.Storage.UpdateOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error updating ontology: %v\", err))\r\n\t\tWriteJSONError(w, NewAPIError(ErrInternalServerError, MsgInternalServerError))\r\n\t\treturn\r\n\t}\r\n\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tjson.NewEncoder(w).Encode(ontology)\r\n}\r\n\r\n// DeleteOntology supprime une ontologie par son ID\r\nfunc (h *Handler) DeleteOntology(w http.ResponseWriter, r *http.Request) {\r\n\tvars := mux.Vars(r)\r\n\tid := vars[\"id\"]\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Deleting ontology: %s\", id))\r\n\r\n\terr := h.Storage.DeleteOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error deleting ontology: %v\", err))\r\n\t\tWriteJSONError(w, NewAPIError(ErrInternalServerError, MsgInternalServerError))\r\n\t\treturn\r\n\t}\r\n\r\n\tw.WriteHeader(http.StatusNoContent)\r\n}\r\n\r\n// ListOntologies récupère la liste de toutes les ontologies\r\nfunc (h *Handler) ListOntologies(w http.ResponseWriter, r *http.Request) {\r\n\th.Logger.Info(\"Listing all ontologies\")\r\n\r\n\tontologies := h.Storage.ListOntologies()\r\n\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tjson.NewEncoder(w).Encode(ontologies)\r\n}\r\n\r\n// SearchOntologies effectue une recherche dans les ontologies\r\nfunc (h *Handler) SearchOntologies(w http.ResponseWriter, r *http.Request) {\r\n\tquery := r.URL.Query().Get(\"q\")\r\n\tontologyID := r.URL.Query().Get(\"ontology_id\")\r\n\r\n\tif query == \"\" {\r\n\t\tWriteJSONError(w, NewAPIError(ErrBadRequest, \"Query parameter 'q' is required\"))\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Searching ontologies with query: %s\", query))\r\n\r\n\t// Déboguer: afficher toutes les ontologies\r\n\tallOntologies := h.Storage.ListOntologies()\r\n\th.Logger.Info(fmt.Sprintf(\"All ontologies: %+v\", allOntologies))\r\n\r\n\tresults := h.Search.Search(query, ontologyID)\r\n\r\n\t// Déboguer: afficher les résultats\r\n\th.Logger.Info(fmt.Sprintf(\"Search results: %+v\", results))\r\n\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tjson.NewEncoder(w).Encode(results)\r\n}\r\n\r\n// ElementDetailsHandler récupère les détails d'un élément spécifique\r\nfunc (h *Handler) ElementDetailsHandler(w http.ResponseWriter, r *http.Request) {\r\n\tvars := mux.Vars(r)\r\n\telementName := vars[\"element_id\"]\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting details for element: %s\", elementName))\r\n\r\n\telement, err := h.Storage.GetElement(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting element details: %v\", err))\r\n\t\tWriteJSONError(w, NewAPIError(ErrNotFound, MsgResourceNotFound))\r\n\t\treturn\r\n\t}\r\n\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tjson.NewEncoder(w).Encode(element)\r\n}\r\n",
    "size": 5388,
    "modTime": "2024-10-26T15:23:57.5507191+02:00",
    "path": "internal\\api\\handlers.go"
  },
  {
    "name": "handlers_test.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"encoding/json\"\r\n\t\"net/http\"\r\n\t\"net/http/httptest\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gorilla/mux\"\r\n)\r\n\r\nfunc setupTestHandler() *Handler {\r\n\tstorage := storage.NewMemoryStorage()\r\n\tlogger, _ := logger.NewLogger(logger.INFO, \"test_logs\")\r\n\tsearchEngine := search.NewSearchEngine(storage)\r\n\treturn NewHandler(storage, logger, searchEngine)\r\n}\r\n\r\nfunc TestGetOntology(t *testing.T) {\r\n\th := setupTestHandler()\r\n\r\n\t// Add a test ontology\r\n\ttestOntology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\t// Test successful retrieval\r\n\treq, _ := http.NewRequest(\"GET\", \"/ontologies/test1\", nil)\r\n\trr := httptest.NewRecorder()\r\n\trouter := mux.NewRouter()\r\n\trouter.HandleFunc(\"/ontologies/{id}\", h.GetOntology)\r\n\trouter.ServeHTTP(rr, req)\r\n\r\n\tif status := rr.Code; status != http.StatusOK {\r\n\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusOK)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\tjson.Unmarshal(rr.Body.Bytes(), \u0026returnedOntology)\r\n\tif returnedOntology.ID != testOntology.ID {\r\n\t\tt.Errorf(\"handler returned unexpected body: got %v want %v\", returnedOntology.ID, testOntology.ID)\r\n\t}\r\n\r\n\t// Test non-existent ontology\r\n\treq, _ = http.NewRequest(\"GET\", \"/ontologies/nonexistent\", nil)\r\n\trr = httptest.NewRecorder()\r\n\trouter.ServeHTTP(rr, req)\r\n\r\n\tif status := rr.Code; status != http.StatusNotFound {\r\n\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusNotFound)\r\n\t}\r\n}\r\n\r\nfunc TestAddOntology(t *testing.T) {\r\n\th := setupTestHandler()\r\n\r\n\tnewOntology := models.Ontology{Name: \"New Test Ontology\"}\r\n\tbody, _ := json.Marshal(newOntology)\r\n\treq, _ := http.NewRequest(\"POST\", \"/ontologies\", bytes.NewBuffer(body))\r\n\trr := httptest.NewRecorder()\r\n\r\n\trouter := mux.NewRouter()\r\n\trouter.HandleFunc(\"/ontologies\", h.AddOntology).Methods(\"POST\")\r\n\trouter.ServeHTTP(rr, req)\r\n\r\n\tif status := rr.Code; status != http.StatusCreated {\r\n\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusCreated)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\tjson.Unmarshal(rr.Body.Bytes(), \u0026returnedOntology)\r\n\tif returnedOntology.Name != newOntology.Name {\r\n\t\tt.Errorf(\"handler returned unexpected body: got %v want %v\", returnedOntology.Name, newOntology.Name)\r\n\t}\r\n}\r\n\r\nfunc TestSearchOntologies(t *testing.T) {\r\n\th := setupTestHandler()\r\n\r\n\t// Add test ontologies with elements\r\n\th.Storage.AddOntology(\u0026models.Ontology{\r\n\t\tID:   \"test1\",\r\n\t\tName: \"Test Ontology 1\",\r\n\t\tElements: []*models.OntologyElement{\r\n\t\t\t{Name: \"Test Element 1\", Type: \"Type1\", Description: \"Description 1\"},\r\n\t\t},\r\n\t})\r\n\th.Storage.AddOntology(\u0026models.Ontology{\r\n\t\tID:   \"test2\",\r\n\t\tName: \"Test Ontology 2\",\r\n\t\tElements: []*models.OntologyElement{\r\n\t\t\t{Name: \"Test Element 2\", Type: \"Type2\", Description: \"Description 2\"},\r\n\t\t},\r\n\t})\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/search?q=Test\", nil)\r\n\trr := httptest.NewRecorder()\r\n\r\n\trouter := mux.NewRouter()\r\n\trouter.HandleFunc(\"/search\", h.SearchOntologies).Methods(\"GET\")\r\n\trouter.ServeHTTP(rr, req)\r\n\r\n\tif status := rr.Code; status != http.StatusOK {\r\n\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusOK)\r\n\t}\r\n\r\n\tvar results []search.SearchResult\r\n\tjson.Unmarshal(rr.Body.Bytes(), \u0026results)\r\n\tif len(results) != 2 {\r\n\t\tt.Errorf(\"handler returned unexpected number of results: got %v want %v\", len(results), 2)\r\n\t}\r\n}\r\n\r\nfunc TestElementDetailsHandler(t *testing.T) {\r\n\th := setupTestHandler()\r\n\r\n\t// Add a test ontology with an element\r\n\ttestElement := \u0026models.OntologyElement{\r\n\t\tName:        \"Test Element\",\r\n\t\tType:        \"TestType\",\r\n\t\tDescription: \"This is a test element\",\r\n\t}\r\n\ttestOntology := \u0026models.Ontology{\r\n\t\tID:       \"test1\",\r\n\t\tName:     \"Test Ontology\",\r\n\t\tElements: []*models.OntologyElement{testElement},\r\n\t}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/elements/Test Element\", nil)\r\n\trr := httptest.NewRecorder()\r\n\r\n\trouter := mux.NewRouter()\r\n\trouter.HandleFunc(\"/elements/{element_id}\", h.ElementDetailsHandler).Methods(\"GET\")\r\n\trouter.ServeHTTP(rr, req)\r\n\r\n\tif status := rr.Code; status != http.StatusOK {\r\n\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusOK)\r\n\t}\r\n\r\n\tvar returnedElement models.OntologyElement\r\n\tjson.Unmarshal(rr.Body.Bytes(), \u0026returnedElement)\r\n\tif returnedElement.Name != \"Test Element\" {\r\n\t\tt.Errorf(\"handler returned unexpected body: got %v want %v\", returnedElement.Name, \"Test Element\")\r\n\t}\r\n}\r\n",
    "size": 4750,
    "modTime": "2024-10-26T15:22:00.748566+02:00",
    "path": "internal\\api\\handlers_test.go"
  },
  {
    "name": "router.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gorilla/mux\"\r\n)\r\n\r\nfunc NewRouter(storage *storage.MemoryStorage, logger *logger.Logger) *mux.Router {\r\n\tsearchEngine := search.NewSearchEngine(storage)\r\n\thandler := NewHandler(storage, logger, searchEngine)\r\n\trouter := mux.NewRouter()\r\n\r\n\trouter.HandleFunc(\"/ontologies\", handler.ListOntologies).Methods(\"GET\")\r\n\trouter.HandleFunc(\"/ontologies\", handler.AddOntology).Methods(\"POST\")\r\n\trouter.HandleFunc(\"/ontologies/{id}\", handler.GetOntology).Methods(\"GET\")\r\n\trouter.HandleFunc(\"/ontologies/{id}\", handler.UpdateOntology).Methods(\"PUT\")\r\n\trouter.HandleFunc(\"/ontologies/{id}\", handler.DeleteOntology).Methods(\"DELETE\")\r\n\trouter.HandleFunc(\"/search\", handler.SearchOntologies).Methods(\"GET\")\r\n\trouter.HandleFunc(\"/elements/{element_id}\", handler.ElementDetailsHandler).Methods(\"GET\")\r\n\r\n\treturn router\r\n}\r\n",
    "size": 1014,
    "modTime": "2024-10-26T15:16:08.0747214+02:00",
    "path": "internal\\api\\router.go"
  },
  {
    "name": "config.go",
    "content": "package config\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"gopkg.in/yaml.v2\"\r\n)\r\n\r\n// Config holds the application configuration\r\ntype Config struct {\r\n\tServer struct {\r\n\t\tPort int    `yaml:\"port\"`\r\n\t\tHost string `yaml:\"host\"`\r\n\t} `yaml:\"server\"`\r\n\tLogging struct {\r\n\t\tLevel     string `yaml:\"level\"`\r\n\t\tDirectory string `yaml:\"directory\"`\r\n\t} `yaml:\"logging\"`\r\n\tStorage struct {\r\n\t\tTempDirectory string `yaml:\"temp_directory\"`\r\n\t} `yaml:\"storage\"`\r\n}\r\n\r\n// LoadConfig reads the config file and returns a Config struct\r\nfunc LoadConfig(filename string) (*Config, error) {\r\n\tconfig := \u0026Config{}\r\n\r\n\t// Read the config file\r\n\tdata, err := os.ReadFile(filename)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error reading config file: %w\", err)\r\n\t}\r\n\r\n\t// Parse the YAML\r\n\terr = yaml.Unmarshal(data, config)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error parsing config YAML: %w\", err)\r\n\t}\r\n\r\n\treturn config, nil\r\n}\r\n",
    "size": 905,
    "modTime": "2024-10-26T12:19:07.1706669+02:00",
    "path": "internal\\config\\config.go"
  },
  {
    "name": "logger.go",
    "content": "package logger\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"runtime\"\r\n\t\"time\"\r\n)\r\n\r\n// LogLevel represents the severity of a log message\r\ntype LogLevel int\r\n\r\nconst (\r\n\t// DEBUG level\r\n\tDEBUG LogLevel = iota\r\n\t// INFO level\r\n\tINFO\r\n\t// WARNING level\r\n\tWARNING\r\n\t// ERROR level\r\n\tERROR\r\n)\r\n\r\nvar levelStrings = map[LogLevel]string{\r\n\tDEBUG:   \"DEBUG\",\r\n\tINFO:    \"INFO\",\r\n\tWARNING: \"WARNING\",\r\n\tERROR:   \"ERROR\",\r\n}\r\n\r\n// Logger represents a custom logger\r\ntype Logger struct {\r\n\tlevel     LogLevel\r\n\tlogFile   *os.File\r\n\tlogger    *log.Logger\r\n\tdirectory string\r\n}\r\n\r\n// NewLogger creates a new Logger instance\r\nfunc NewLogger(level LogLevel, directory string) (*Logger, error) {\r\n\tlogger := \u0026Logger{\r\n\t\tlevel:     level,\r\n\t\tdirectory: directory,\r\n\t}\r\n\r\n\t// Ensure the log directory exists\r\n\tif err := os.MkdirAll(directory, 0755); err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to create log directory: %w\", err)\r\n\t}\r\n\r\n\terr := logger.rotate()\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"error creating logger: %w\", err)\r\n\t}\r\n\treturn logger, nil\r\n}\r\n\r\n// rotate creates a new log file for the current day\r\nfunc (l *Logger) rotate() error {\r\n\tif l.logFile != nil {\r\n\t\tl.logFile.Close()\r\n\t}\r\n\r\n\tnow := time.Now()\r\n\tfilename := filepath.Join(l.directory, fmt.Sprintf(\"%s.log\", now.Format(\"2006-01-02\")))\r\n\r\n\tfile, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"error opening log file: %w\", err)\r\n\t}\r\n\r\n\tl.logFile = file\r\n\tl.logger = log.New(file, \"\", 0)\r\n\treturn nil\r\n}\r\n\r\n// log writes a log message with the given level\r\nfunc (l *Logger) log(level LogLevel, message string) {\r\n\tif level \u003c l.level {\r\n\t\treturn\r\n\t}\r\n\r\n\tnow := time.Now()\r\n\tif now.Day() != time.Now().Day() {\r\n\t\terr := l.rotate()\r\n\t\tif err != nil {\r\n\t\t\tfmt.Printf(\"Error rotating log file: %v\\n\", err)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\r\n\t_, file, line, _ := runtime.Caller(2)\r\n\tlogMessage := fmt.Sprintf(\"[%s] [%s] [%s:%d] %s\",\r\n\t\tlevelStrings[level],\r\n\t\tnow.Format(\"2006-01-02 15:04:05\"),\r\n\t\tfilepath.Base(file),\r\n\t\tline,\r\n\t\tmessage)\r\n\r\n\tl.logger.Println(logMessage)\r\n\tfmt.Printf(\"\\n%s\", logMessage)\r\n}\r\n\r\n// Debug logs a debug message\r\nfunc (l *Logger) Debug(message string) {\r\n\tl.log(DEBUG, message)\r\n}\r\n\r\n// Info logs an info message\r\nfunc (l *Logger) Info(message string) {\r\n\tl.log(INFO, message)\r\n}\r\n\r\n// Warning logs a warning message\r\nfunc (l *Logger) Warning(message string) {\r\n\tl.log(WARNING, message)\r\n}\r\n\r\n// Error logs an error message\r\nfunc (l *Logger) Error(message string) {\r\n\tl.log(ERROR, message)\r\n}\r\n",
    "size": 2547,
    "modTime": "2024-10-26T15:25:00.231732+02:00",
    "path": "internal\\logger\\logger.go"
  },
  {
    "name": "element.go",
    "content": "package models\r\n\r\ntype JSONContext struct {\r\n\tPosition int      `json:\"position\"`\r\n\tBefore   []string `json:\"before\"`\r\n\tAfter    []string `json:\"after\"`\r\n\tElement  string   `json:\"element\"`\r\n\tLength   int      `json:\"length\"`\r\n}\r\n",
    "size": 230,
    "modTime": "2024-10-26T14:17:32.5636772+02:00",
    "path": "internal\\models\\element.go"
  },
  {
    "name": "ontology.go",
    "content": "package models\r\n\r\nimport (\r\n\t\"time\"\r\n)\r\n\r\n// OntologyElement représente un élément individuel dans l'ontologie\r\ntype OntologyElement struct {\r\n\tName        string\r\n\tType        string\r\n\tPositions   []int\r\n\tDescription string\r\n}\r\n\r\n// Relation représente une relation entre deux éléments de l'ontologie\r\ntype Relation struct {\r\n\tSource      string\r\n\tType        string\r\n\tTarget      string\r\n\tDescription string\r\n}\r\n\r\n// Ontology représente une ontologie complète\r\ntype Ontology struct {\r\n\tID         string\r\n\tName       string\r\n\tFilename   string\r\n\tFormat     string\r\n\tSize       int64\r\n\tSHA256     string\r\n\tImportedAt time.Time\r\n\tElements   []*OntologyElement\r\n\tRelations  []*Relation\r\n}\r\n",
    "size": 697,
    "modTime": "2024-10-26T14:22:49.2777282+02:00",
    "path": "internal\\models\\ontology.go"
  },
  {
    "name": "ontology_test.go",
    "content": "package models\r\n\r\nimport (\r\n\t\"testing\"\r\n\t\"time\"\r\n)\r\n\r\nfunc TestOntologyStructure(t *testing.T) {\r\n\t// Créer une nouvelle ontologie\r\n\tontology := Ontology{\r\n\t\tID:         \"test-ontology\",\r\n\t\tName:       \"Test Ontology\",\r\n\t\tFilename:   \"test.tsv\",\r\n\t\tFormat:     \"TSV\",\r\n\t\tSize:       1024,\r\n\t\tSHA256:     \"abcdef1234567890\",\r\n\t\tImportedAt: time.Now(),\r\n\t\tElements: []*OntologyElement{\r\n\t\t\t{\r\n\t\t\t\tName:        \"TestElement\",\r\n\t\t\t\tType:        \"Concept\",\r\n\t\t\t\tPositions:   []int{1, 2, 3},\r\n\t\t\t\tDescription: \"This is a test element\",\r\n\t\t\t},\r\n\t\t},\r\n\t\tRelations: []*Relation{\r\n\t\t\t{\r\n\t\t\t\tSource:      \"TestElement\",\r\n\t\t\t\tType:        \"isA\",\r\n\t\t\t\tTarget:      \"ParentElement\",\r\n\t\t\t\tDescription: \"Test relation\",\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\t// Vérifier que les champs sont correctement définis\r\n\tif ontology.ID != \"test-ontology\" {\r\n\t\tt.Errorf(\"Expected ID to be 'test-ontology', got '%s'\", ontology.ID)\r\n\t}\r\n\r\n\tif len(ontology.Elements) != 1 {\r\n\t\tt.Errorf(\"Expected 1 element, got %d\", len(ontology.Elements))\r\n\t}\r\n\r\n\tif len(ontology.Relations) != 1 {\r\n\t\tt.Errorf(\"Expected 1 relation, got %d\", len(ontology.Relations))\r\n\t}\r\n}\r\n\r\nfunc TestJSONContextStructure(t *testing.T) {\r\n\t// Tester la structure JSONContext\r\n\tcontext := JSONContext{\r\n\t\tPosition: 1,\r\n\t\tBefore:   []string{\"before\"},\r\n\t\tAfter:    []string{\"after\"},\r\n\t\tElement:  \"TestElement\",\r\n\t\tLength:   1,\r\n\t}\r\n\r\n\tif context.Element != \"TestElement\" {\r\n\t\tt.Errorf(\"Expected Element to be 'TestElement', got '%s'\", context.Element)\r\n\t}\r\n}\r\n",
    "size": 1485,
    "modTime": "2024-10-26T14:23:08.141458+02:00",
    "path": "internal\\models\\ontology_test.go"
  },
  {
    "name": "json.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\n// ParseJSON parses a JSON file and returns a slice of JSONContext structures\r\nfunc ParseJSON(filename string) ([]models.JSONContext, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse JSON file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tvar contexts []models.JSONContext\r\n\tdecoder := json.NewDecoder(file)\r\n\r\n\terr = decoder.Decode(\u0026contexts)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to decode JSON: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to decode JSON: %w\", err)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing JSON file. Found %d contexts.\", len(contexts)))\r\n\treturn contexts, nil\r\n}\r\n",
    "size": 899,
    "modTime": "2024-10-26T14:17:15.0095734+02:00",
    "path": "internal\\parser\\json.go"
  },
  {
    "name": "json_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseJSON(t *testing.T) {\r\n\t// Create a temporary JSON file for testing\r\n\ttestContexts := []models.JSONContext{\r\n\t\t{\r\n\t\t\tPosition: 1,\r\n\t\t\tBefore:   []string{\"La\"},\r\n\t\t\tAfter:    []string{\"juridique\", \"sert\", \"de\", \"premier\", \"plan.\"},\r\n\t\t\tElement:  \"Qualification_Juridique\",\r\n\t\t\tLength:   1,\r\n\t\t},\r\n\t\t{\r\n\t\t\tPosition: 8,\r\n\t\t\tBefore:   []string{\"La\", \"qualification\", \"juridique\", \"sert\", \"de\", \"premier\", \"plan.\", \"Dans\"},\r\n\t\t\tAfter:    []string{\"cas\", \"des\", \"internationales,\", \"le\", \"Conseil\"},\r\n\t\t\tElement:  \"Joueuse_Internationale\",\r\n\t\t\tLength:   1,\r\n\t\t},\r\n\t}\r\n\r\n\tcontent, err := json.Marshal(testContexts)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to marshal test data: %v\", err)\r\n\t}\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.json\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write(content); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Test the ParseJSON function\r\n\tcontexts, err := ParseJSON(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseJSON returned an error: %v\", err)\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(contexts, testContexts) {\r\n\t\tt.Errorf(\"ParseJSON returned unexpected result. Got %v, want %v\", contexts, testContexts)\r\n\t}\r\n}\r\n",
    "size": 1538,
    "modTime": "2024-10-26T14:17:29.0160883+02:00",
    "path": "internal\\parser\\json_test.go"
  },
  {
    "name": "owl.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/knakk/rdf\"\r\n)\r\n\r\n// ParseOWL parses an OWL file and returns a slice of OntologyElement structures\r\nfunc ParseOWL(filename string) ([]models.OntologyElement, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse OWL file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tdecoder := rdf.NewTripleDecoder(file, rdf.RDFXML)\r\n\telements := make(map[string]*models.OntologyElement)\r\n\r\n\tfor triple, err := decoder.Decode(); err == nil; triple, err = decoder.Decode() {\r\n\t\tsubj := triple.Subj.String()\r\n\t\tpred := triple.Pred.String()\r\n\t\tobj := triple.Obj.String()\r\n\r\n\t\tif _, exists := elements[subj]; !exists {\r\n\t\t\telements[subj] = \u0026models.OntologyElement{Name: subj}\r\n\t\t}\r\n\r\n\t\tswitch pred {\r\n\t\tcase \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\":\r\n\t\t\telements[subj].Type = obj\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#label\":\r\n\t\t\telements[subj].Name = obj\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#comment\":\r\n\t\t\telements[subj].Description = obj\r\n\t\t}\r\n\t}\r\n\r\n\tresult := make([]models.OntologyElement, 0, len(elements))\r\n\tfor _, element := range elements {\r\n\t\tresult = append(result, *element)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing OWL file. Found %d elements.\", len(result)))\r\n\treturn result, nil\r\n}\r\n",
    "size": 1488,
    "modTime": "2024-10-26T14:26:17.5864472+02:00",
    "path": "internal\\parser\\owl.go"
  },
  {
    "name": "owl_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseOWL(t *testing.T) {\r\n\t// Create a temporary OWL file for testing\r\n\tcontent := `\r\n    \u003c?xml version=\"1.0\"?\u003e\r\n    \u003crdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n             xmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\r\n             xmlns:owl=\"http://www.w3.org/2002/07/owl#\"\u003e\r\n      \u003cowl:Class rdf:about=\"http://example.org/Class1\"\u003e\r\n        \u003crdfs:label\u003eClass 1\u003c/rdfs:label\u003e\r\n        \u003crdfs:comment\u003eThis is class 1\u003c/rdfs:comment\u003e\r\n      \u003c/owl:Class\u003e\r\n    \u003c/rdf:RDF\u003e\r\n    `\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.owl\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Test the ParseOWL function\r\n\telements, err := ParseOWL(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseOWL returned an error: %v\", err)\r\n\t}\r\n\r\n\tif len(elements) != 1 {\r\n\t\tt.Fatalf(\"Expected 1 element, got %d\", len(elements))\r\n\t}\r\n\r\n\texpected := models.OntologyElement{\r\n\t\tName:        \"Class 1\",\r\n\t\tType:        \"http://www.w3.org/2002/07/owl#Class\",\r\n\t\tDescription: \"This is class 1\",\r\n\t}\r\n\r\n\tif elements[0].Name != expected.Name || elements[0].Type != expected.Type || elements[0].Description != expected.Description {\r\n\t\tt.Errorf(\"ParseOWL returned unexpected result. Got %v, want %v\", elements[0], expected)\r\n\t}\r\n}\r\n",
    "size": 1654,
    "modTime": "2024-10-26T14:27:40.0735532+02:00",
    "path": "internal\\parser\\owl_test.go"
  },
  {
    "name": "rdf.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/knakk/rdf\"\r\n)\r\n\r\n// ParseRDF parses an RDF file and returns a slice of OntologyElement structures\r\nfunc ParseRDF(filename string) ([]models.OntologyElement, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse RDF file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\tdecoder := rdf.NewTripleDecoder(file, rdf.RDFXML)\r\n\telements := make(map[string]*models.OntologyElement)\r\n\r\n\tfor triple, err := decoder.Decode(); err == nil; triple, err = decoder.Decode() {\r\n\t\tsubj := triple.Subj.String()\r\n\t\tpred := triple.Pred.String()\r\n\t\tobj := triple.Obj.String()\r\n\r\n\t\tif _, exists := elements[subj]; !exists {\r\n\t\t\telements[subj] = \u0026models.OntologyElement{Name: subj}\r\n\t\t}\r\n\r\n\t\tswitch pred {\r\n\t\tcase \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\":\r\n\t\t\telements[subj].Type = obj\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#label\":\r\n\t\t\telements[subj].Name = obj\r\n\t\tcase \"http://www.w3.org/2000/01/rdf-schema#comment\":\r\n\t\t\telements[subj].Description = obj\r\n\t\t}\r\n\t}\r\n\r\n\tresult := make([]models.OntologyElement, 0, len(elements))\r\n\tfor _, element := range elements {\r\n\t\tresult = append(result, *element)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing RDF file. Found %d elements.\", len(result)))\r\n\treturn result, nil\r\n}\r\n",
    "size": 1488,
    "modTime": "2024-10-26T14:25:52.3181757+02:00",
    "path": "internal\\parser\\rdf.go"
  },
  {
    "name": "rdf_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseRDF(t *testing.T) {\r\n\t// Create a temporary RDF file for testing\r\n\tcontent := `\r\n    \u003c?xml version=\"1.0\"?\u003e\r\n    \u003crdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n             xmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\u003e\r\n      \u003crdf:Description rdf:about=\"http://example.org/resource1\"\u003e\r\n        \u003crdf:type rdf:resource=\"http://example.org/Type1\"/\u003e\r\n        \u003crdfs:label\u003eResource 1\u003c/rdfs:label\u003e\r\n        \u003crdfs:comment\u003eThis is resource 1\u003c/rdfs:comment\u003e\r\n      \u003c/rdf:Description\u003e\r\n    \u003c/rdf:RDF\u003e\r\n    `\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.rdf\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Test the ParseRDF function\r\n\telements, err := ParseRDF(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseRDF returned an error: %v\", err)\r\n\t}\r\n\r\n\tif len(elements) != 1 {\r\n\t\tt.Fatalf(\"Expected 1 element, got %d\", len(elements))\r\n\t}\r\n\r\n\texpected := models.OntologyElement{\r\n\t\tName:        \"Resource 1\",\r\n\t\tType:        \"http://example.org/Type1\",\r\n\t\tDescription: \"This is resource 1\",\r\n\t}\r\n\r\n\tif elements[0].Name != expected.Name || elements[0].Type != expected.Type || elements[0].Description != expected.Description {\r\n\t\tt.Errorf(\"ParseRDF returned unexpected result. Got %v, want %v\", elements[0], expected)\r\n\t}\r\n}\r\n",
    "size": 1674,
    "modTime": "2024-10-26T14:26:20.471837+02:00",
    "path": "internal\\parser\\rdf_test.go"
  },
  {
    "name": "tsv.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"bufio\"\r\n\t\"encoding/csv\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nvar log *logger.Logger\r\n\r\nfunc init() {\r\n\tvar err error\r\n\tlogDir := filepath.Join(\".\", \"logs\") // Use a relative path\r\n\tlog, err = logger.NewLogger(logger.INFO, logDir)\r\n\tif err != nil {\r\n\t\tpanic(fmt.Sprintf(\"Failed to initialize logger: %v\", err))\r\n\t}\r\n}\r\n\r\n// ParseTSV parses a TSV file and returns a slice of Element structures\r\nfunc ParseTSV(filename string) ([]models.OntologyElement, error) {\r\n\tlog.Info(fmt.Sprintf(\"Starting to parse TSV file: %s\", filename))\r\n\r\n\tfile, err := os.Open(filename)\r\n\tif err != nil {\r\n\t\tlog.Error(fmt.Sprintf(\"Failed to open file: %v\", err))\r\n\t\treturn nil, fmt.Errorf(\"failed to open file: %w\", err)\r\n\t}\r\n\tdefer file.Close()\r\n\r\n\treader := csv.NewReader(bufio.NewReader(file))\r\n\treader.Comma = '\\t'         // Use tab as delimiter\r\n\treader.FieldsPerRecord = -1 // Allow variable number of fields\r\n\r\n\tvar elements []models.OntologyElement\r\n\r\n\tfor {\r\n\t\trecord, err := reader.Read()\r\n\t\tif err == io.EOF {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif err != nil {\r\n\t\t\tlog.Error(fmt.Sprintf(\"Error reading TSV record: %v\", err))\r\n\t\t\treturn nil, fmt.Errorf(\"error reading TSV record: %w\", err)\r\n\t\t}\r\n\r\n\t\tif len(record) \u003c 4 {\r\n\t\t\tlog.Warning(fmt.Sprintf(\"Skipping invalid record: %v\", record))\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tpositions, err := parsePositions(record[3])\r\n\t\tif err != nil {\r\n\t\t\tlog.Warning(fmt.Sprintf(\"Error parsing positions for record %v: %v\", record, err))\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\telement := models.OntologyElement{\r\n\t\t\tName:        strings.TrimSpace(record[0]),\r\n\t\t\tType:        strings.TrimSpace(record[1]),\r\n\t\t\tDescription: strings.TrimSpace(record[2]),\r\n\t\t\tPositions:   positions,\r\n\t\t}\r\n\r\n\t\telements = append(elements, element)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"Finished parsing TSV file. Found %d elements.\", len(elements)))\r\n\treturn elements, nil\r\n}\r\n\r\nfunc parsePositions(positionsStr string) ([]int, error) {\r\n\tpositionsStr = strings.TrimSpace(positionsStr)\r\n\tif positionsStr == \"\" {\r\n\t\treturn []int{}, nil\r\n\t}\r\n\r\n\tpositionStrs := strings.Split(positionsStr, \",\")\r\n\tpositions := make([]int, 0, len(positionStrs))\r\n\r\n\tfor _, pos := range positionStrs {\r\n\t\tpos = strings.TrimSpace(pos)\r\n\t\tif pos == \"\" {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tposition, err := strconv.Atoi(pos)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, fmt.Errorf(\"invalid position: %s\", pos)\r\n\t\t}\r\n\t\tpositions = append(positions, position)\r\n\t}\r\n\r\n\treturn positions, nil\r\n}\r\n",
    "size": 2570,
    "modTime": "2024-10-26T14:29:50.6851448+02:00",
    "path": "internal\\parser\\tsv.go"
  },
  {
    "name": "tsv_test.go",
    "content": "package parser\r\n\r\nimport (\r\n\t\"io/ioutil\"\r\n\t\"os\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestParseTSV(t *testing.T) {\r\n\t// Create a temporary TSV file for testing\r\n\tcontent := `Element1\tType1\tDescription1\t1,2,3\r\nElement2\tType2\tDescription2\t4,5,6\r\nInvalid\tRow\r\nElement3\tType3\tDescription3\t7,8,9`\r\n\r\n\ttmpfile, err := ioutil.TempFile(\"\", \"test.tsv\")\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\r\n\t}\r\n\tdefer os.Remove(tmpfile.Name())\r\n\r\n\tif _, err := tmpfile.Write([]byte(content)); err != nil {\r\n\t\tt.Fatalf(\"Failed to write to temporary file: %v\", err)\r\n\t}\r\n\tif err := tmpfile.Close(); err != nil {\r\n\t\tt.Fatalf(\"Failed to close temporary file: %v\", err)\r\n\t}\r\n\r\n\t// Test the ParseTSV function\r\n\telements, err := ParseTSV(tmpfile.Name())\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"ParseTSV returned an error: %v\", err)\r\n\t}\r\n\r\n\texpected := []models.OntologyElement{\r\n\t\t{Name: \"Element1\", Type: \"Type1\", Description: \"Description1\", Positions: []int{1, 2, 3}},\r\n\t\t{Name: \"Element2\", Type: \"Type2\", Description: \"Description2\", Positions: []int{4, 5, 6}},\r\n\t\t{Name: \"Element3\", Type: \"Type3\", Description: \"Description3\", Positions: []int{7, 8, 9}},\r\n\t}\r\n\r\n\tif !reflect.DeepEqual(elements, expected) {\r\n\t\tt.Errorf(\"ParseTSV returned unexpected result. Got %v, want %v\", elements, expected)\r\n\t}\r\n}\r\n\r\nfunc TestParsePositions(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tinput    string\r\n\t\texpected []int\r\n\t\twantErr  bool\r\n\t}{\r\n\t\t{\"1,2,3\", []int{1, 2, 3}, false},\r\n\t\t{\"\", []int{}, false},\r\n\t\t{\"1, 2, 3\", []int{1, 2, 3}, false},\r\n\t\t{\"1,a,3\", nil, true},\r\n\t\t{\" 1 , 2 , 3 \", []int{1, 2, 3}, false},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tresult, err := parsePositions(tt.input)\r\n\t\tif (err != nil) != tt.wantErr {\r\n\t\t\tt.Errorf(\"parsePositions(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif !reflect.DeepEqual(result, tt.expected) {\r\n\t\t\tt.Errorf(\"parsePositions(%q) = %v, want %v\", tt.input, result, tt.expected)\r\n\t\t}\r\n\t}\r\n}\r\n",
    "size": 2008,
    "modTime": "2024-10-26T14:27:35.0087928+02:00",
    "path": "internal\\parser\\tsv_test.go"
  },
  {
    "name": "engine.go",
    "content": "package search\r\n\r\nimport (\r\n\t\"sort\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/agnivade/levenshtein\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n)\r\n\r\n// SearchEngine représente le moteur de recherche\r\ntype SearchEngine struct {\r\n\tStorage *storage.MemoryStorage\r\n}\r\n\r\n// NewSearchEngine crée une nouvelle instance de SearchEngine\r\nfunc NewSearchEngine(storage *storage.MemoryStorage) *SearchEngine {\r\n\treturn \u0026SearchEngine{Storage: storage}\r\n}\r\n\r\n// SearchResult représente un résultat de recherche\r\ntype SearchResult struct {\r\n\tOntology  *models.Ontology\r\n\tElement   *models.OntologyElement\r\n\tRelevance float64\r\n}\r\n\r\n// Search effectue une recherche dans les ontologies\r\nfunc (se *SearchEngine) Search(query string, ontologyID string) []SearchResult {\r\n\tquery = strings.ToLower(query)\r\n\tvar results []SearchResult\r\n\r\n\tontologies := se.Storage.ListOntologies()\r\n\tfor _, ontology := range ontologies {\r\n\t\tif ontologyID != \"\" \u0026\u0026 ontology.ID != ontologyID {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tfor _, element := range ontology.Elements {\r\n\t\t\trelevance := calculateRelevance(query, element)\r\n\t\t\tif relevance \u003e 0 {\r\n\t\t\t\tresults = append(results, SearchResult{\r\n\t\t\t\t\tOntology:  ontology,\r\n\t\t\t\t\tElement:   element,\r\n\t\t\t\t\tRelevance: relevance,\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Trier les résultats par pertinence (du plus pertinent au moins pertinent)\r\n\tsortSearchResults(results)\r\n\r\n\treturn results\r\n}\r\n\r\n// sortSearchResults trie les résultats de recherche par pertinence décroissante\r\nfunc sortSearchResults(results []SearchResult) {\r\n\tsort.Slice(results, func(i, j int) bool {\r\n\t\treturn results[i].Relevance \u003e results[j].Relevance\r\n\t})\r\n}\r\n\r\n// calculateRelevance calcule la pertinence d'un élément par rapport à la requête\r\nfunc calculateRelevance(query string, element *models.OntologyElement) float64 {\r\n\trelevance := 0.0\r\n\r\n\t// Recherche floue dans le nom\r\n\tnameRelevance := fuzzyMatch(query, element.Name)\r\n\trelevance += nameRelevance * 1.0\r\n\r\n\t// Recherche floue dans le type\r\n\ttypeRelevance := fuzzyMatch(query, element.Type)\r\n\trelevance += typeRelevance * 0.5\r\n\r\n\t// Recherche floue dans la description\r\n\tdescRelevance := fuzzyMatch(query, element.Description)\r\n\trelevance += descRelevance * 0.3\r\n\r\n\treturn relevance\r\n}\r\n\r\n// fuzzyMatch calcule la similarité entre deux chaînes\r\nfunc fuzzyMatch(s1, s2 string) float64 {\r\n\ts1 = strings.ToLower(s1)\r\n\ts2 = strings.ToLower(s2)\r\n\r\n\tdistance := levenshtein.ComputeDistance(s1, s2)\r\n\tmaxLen := float64(max(len(s1), len(s2)))\r\n\r\n\tif maxLen == 0 {\r\n\t\treturn 0\r\n\t}\r\n\r\n\treturn 1 - float64(distance)/maxLen\r\n}\r\n\r\nfunc max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n",
    "size": 2675,
    "modTime": "2024-10-26T14:59:36.3982398+02:00",
    "path": "internal\\search\\engine.go"
  },
  {
    "name": "engine_test.go",
    "content": "package search\r\n\r\nimport (\r\n\t\"math\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n)\r\n\r\nfunc TestSearch(t *testing.T) {\r\n\t// Créer un stockage en mémoire mock\r\n\tmockStorage := storage.NewMemoryStorage()\r\n\r\n\t// Ajouter quelques ontologies de test\r\n\tontology1 := \u0026models.Ontology{\r\n\t\tID:   \"onto1\",\r\n\t\tName: \"Test Ontology 1\",\r\n\t\tElements: []*models.OntologyElement{\r\n\t\t\t{Name: \"Apple\", Type: \"Fruit\", Description: \"A sweet fruit\"},\r\n\t\t\t{Name: \"Banana\", Type: \"Fruit\", Description: \"A yellow fruit\"},\r\n\t\t},\r\n\t}\r\n\tontology2 := \u0026models.Ontology{\r\n\t\tID:   \"onto2\",\r\n\t\tName: \"Test Ontology 2\",\r\n\t\tElements: []*models.OntologyElement{\r\n\t\t\t{Name: \"Car\", Type: \"Vehicle\", Description: \"A road vehicle\"},\r\n\t\t\t{Name: \"Bicycle\", Type: \"Vehicle\", Description: \"A two-wheeled vehicle\"},\r\n\t\t},\r\n\t}\r\n\tmockStorage.AddOntology(ontology1)\r\n\tmockStorage.AddOntology(ontology2)\r\n\r\n\t// Créer le moteur de recherche\r\n\tsearchEngine := NewSearchEngine(mockStorage)\r\n\r\n\t// Test 1: Recherche générale\r\n\tresults := searchEngine.Search(\"fruit\", \"\")\r\n\tif len(results) != 4 {\r\n\t\tt.Errorf(\"Expected 4 results, got %d\", len(results))\r\n\t}\r\n\r\n\t// Test 2: Recherche dans une ontologie spécifique\r\n\tresults = searchEngine.Search(\"vehicle\", \"onto2\")\r\n\tif len(results) != 2 {\r\n\t\tt.Errorf(\"Expected 2 results, got %d\", len(results))\r\n\t}\r\n\r\n\t// Test 3: Recherche avec résultats partiels\r\n\tresults = searchEngine.Search(\"airplane\", \"\")\r\n\tif len(results) == 0 {\r\n\t\tt.Errorf(\"Expected some results, got 0\")\r\n\t}\r\n\r\n\t// Test 4: Vérifier l'ordre des résultats\r\n\tresults = searchEngine.Search(\"a\", \"\")\r\n\tif len(results) \u003c 2 || results[0].Relevance \u003c= results[1].Relevance {\r\n\t\tt.Errorf(\"Results not in expected order\")\r\n\t}\r\n}\r\n\r\nfunc TestCalculateRelevance(t *testing.T) {\r\n\telement := \u0026models.OntologyElement{\r\n\t\tName:        \"Apple\",\r\n\t\tType:        \"Fruit\",\r\n\t\tDescription: \"A sweet red fruit\",\r\n\t}\r\n\r\n\ttests := []struct {\r\n\t\tquery       string\r\n\t\tminExpected float64\r\n\t\tmaxExpected float64\r\n\t}{\r\n\t\t{\"apple\", 0.9, 1.1},  // Correspondance presque parfaite pour le nom\r\n\t\t{\"fruit\", 0.5, 0.7},  // Correspondance parfaite pour le type\r\n\t\t{\"sweet\", 0.1, 0.3},  // Correspondance partielle dans la description\r\n\t\t{\"red\", 0.1, 0.3},    // Correspondance partielle dans la description\r\n\t\t{\"banana\", 0.0, 0.2}, // Aucune correspondance exacte, mais peut avoir une légère similarité\r\n\t}\r\n\r\n\tfor _, test := range tests {\r\n\t\trelevance := calculateRelevance(test.query, element)\r\n\t\tif relevance \u003c test.minExpected || relevance \u003e test.maxExpected {\r\n\t\t\tt.Errorf(\"For query '%s', expected relevance between %f and %f, got %f\",\r\n\t\t\t\ttest.query, test.minExpected, test.maxExpected, relevance)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestFuzzyMatch(t *testing.T) {\r\n\ttests := []struct {\r\n\t\ts1       string\r\n\t\ts2       string\r\n\t\texpected float64\r\n\t}{\r\n\t\t{\"apple\", \"apple\", 1.0},\r\n\t\t{\"apple\", \"appl\", 0.8},\r\n\t\t{\"apple\", \"aple\", 0.8},\r\n\t\t{\"apple\", \"banana\", 0.1666},\r\n\t}\r\n\r\n\tfor _, test := range tests {\r\n\t\tresult := fuzzyMatch(test.s1, test.s2)\r\n\t\tif math.Abs(result-test.expected) \u003e 0.01 {\r\n\t\t\tt.Errorf(\"For '%s' and '%s', expected %f, got %f\", test.s1, test.s2, test.expected, result)\r\n\t\t}\r\n\t}\r\n}\r\n",
    "size": 3210,
    "modTime": "2024-10-26T15:01:01.8718298+02:00",
    "path": "internal\\search\\engine_test.go"
  },
  {
    "name": "memory.go",
    "content": "package storage\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"sync\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nvar log *logger.Logger\r\n\r\nfunc init() {\r\n\tvar err error\r\n\tlog, err = logger.NewLogger(logger.INFO, \"logs\")\r\n\tif err != nil {\r\n\t\tpanic(fmt.Sprintf(\"Failed to initialize logger: %v\", err))\r\n\t}\r\n}\r\n\r\n// MemoryStorage represents an in-memory storage for ontologies\r\ntype MemoryStorage struct {\r\n\tontologies map[string]*models.Ontology\r\n\tmutex      sync.RWMutex\r\n}\r\n\r\n// NewMemoryStorage initializes and returns a new MemoryStorage\r\nfunc NewMemoryStorage() *MemoryStorage {\r\n\treturn \u0026MemoryStorage{\r\n\t\tontologies: make(map[string]*models.Ontology),\r\n\t}\r\n}\r\n\r\n// AddOntology adds a new ontology to the storage\r\nfunc (ms *MemoryStorage) AddOntology(ontology *models.Ontology) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[ontology.ID]; exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s already exists\", ontology.ID)\r\n\t}\r\n\r\n\tms.ontologies[ontology.ID] = ontology\r\n\tlog.Info(fmt.Sprintf(\"Added ontology with ID: %s\", ontology.ID))\r\n\treturn nil\r\n}\r\n\r\n// GetOntology retrieves an ontology by its ID\r\nfunc (ms *MemoryStorage) GetOntology(id string) (*models.Ontology, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tontology, exists := ms.ontologies[id]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"ontology with ID %s not found\", id)\r\n\t}\r\n\r\n\treturn ontology, nil\r\n}\r\n\r\n// UpdateOntology updates an existing ontology\r\nfunc (ms *MemoryStorage) UpdateOntology(ontology *models.Ontology) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[ontology.ID]; !exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s not found\", ontology.ID)\r\n\t}\r\n\r\n\tms.ontologies[ontology.ID] = ontology\r\n\tlog.Info(fmt.Sprintf(\"Updated ontology with ID: %s\", ontology.ID))\r\n\treturn nil\r\n}\r\n\r\n// DeleteOntology removes an ontology by its ID\r\nfunc (ms *MemoryStorage) DeleteOntology(id string) error {\r\n\tms.mutex.Lock()\r\n\tdefer ms.mutex.Unlock()\r\n\r\n\tif _, exists := ms.ontologies[id]; !exists {\r\n\t\treturn fmt.Errorf(\"ontology with ID %s not found\", id)\r\n\t}\r\n\r\n\tdelete(ms.ontologies, id)\r\n\tlog.Info(fmt.Sprintf(\"Deleted ontology with ID: %s\", id))\r\n\treturn nil\r\n}\r\n\r\n// ListOntologies returns a list of all stored ontologies\r\nfunc (ms *MemoryStorage) ListOntologies() []*models.Ontology {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\r\n\tontologies := make([]*models.Ontology, 0, len(ms.ontologies))\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tontologies = append(ontologies, ontology)\r\n\t}\r\n\r\n\treturn ontologies\r\n}\r\n\r\nfunc (ms *MemoryStorage) GetElement(elementName string) (*models.OntologyElement, error) {\r\n\tms.mutex.RLock()\r\n\tdefer ms.mutex.RUnlock()\r\n\tfor _, ontology := range ms.ontologies {\r\n\t\tfor _, element := range ontology.Elements {\r\n\t\t\tif element.Name == elementName {\r\n\t\t\t\treturn element, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn nil, fmt.Errorf(\"element not found\")\r\n}\r\n",
    "size": 2978,
    "modTime": "2024-10-26T15:22:21.0792531+02:00",
    "path": "internal\\storage\\memory.go"
  },
  {
    "name": "memory_test.go",
    "content": "package storage\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"testing\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n)\r\n\r\nfunc TestNewMemoryStorage(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tif ms == nil {\r\n\t\tt.Error(\"NewMemoryStorage returned nil\")\r\n\t}\r\n\tif ms.ontologies == nil {\r\n\t\tt.Error(\"ontologies map is not initialized\")\r\n\t}\r\n}\r\n\r\nfunc TestAddOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\r\n\terr := ms.AddOntology(ontology)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to add ontology: %v\", err)\r\n\t}\r\n\r\n\t// Try to add the same ontology again\r\n\terr = ms.AddOntology(ontology)\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when adding duplicate ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestGetOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\tretrieved, err := ms.GetOntology(\"test1\")\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to get ontology: %v\", err)\r\n\t}\r\n\tif retrieved.ID != ontology.ID || retrieved.Name != ontology.Name {\r\n\t\tt.Error(\"Retrieved ontology does not match the original\")\r\n\t}\r\n\r\n\t_, err = ms.GetOntology(\"nonexistent\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when getting nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestUpdateOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\tupdatedOntology := \u0026models.Ontology{ID: \"test1\", Name: \"Updated Test Ontology\"}\r\n\terr := ms.UpdateOntology(updatedOntology)\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to update ontology: %v\", err)\r\n\t}\r\n\r\n\tretrieved, _ := ms.GetOntology(\"test1\")\r\n\tif retrieved.Name != \"Updated Test Ontology\" {\r\n\t\tt.Error(\"Ontology was not updated correctly\")\r\n\t}\r\n\r\n\tnonexistentOntology := \u0026models.Ontology{ID: \"nonexistent\", Name: \"Nonexistent\"}\r\n\terr = ms.UpdateOntology(nonexistentOntology)\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when updating nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestDeleteOntology(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\tms.AddOntology(ontology)\r\n\r\n\terr := ms.DeleteOntology(\"test1\")\r\n\tif err != nil {\r\n\t\tt.Errorf(\"Failed to delete ontology: %v\", err)\r\n\t}\r\n\r\n\t_, err = ms.GetOntology(\"test1\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when getting deleted ontology, got nil\")\r\n\t}\r\n\r\n\terr = ms.DeleteOntology(\"nonexistent\")\r\n\tif err == nil {\r\n\t\tt.Error(\"Expected error when deleting nonexistent ontology, got nil\")\r\n\t}\r\n}\r\n\r\nfunc TestListOntologies(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tontology1 := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology 1\"}\r\n\tontology2 := \u0026models.Ontology{ID: \"test2\", Name: \"Test Ontology 2\"}\r\n\tms.AddOntology(ontology1)\r\n\tms.AddOntology(ontology2)\r\n\r\n\tontologies := ms.ListOntologies()\r\n\tif len(ontologies) != 2 {\r\n\t\tt.Errorf(\"Expected 2 ontologies, got %d\", len(ontologies))\r\n\t}\r\n\r\n\tfoundOntology1 := false\r\n\tfoundOntology2 := false\r\n\tfor _, o := range ontologies {\r\n\t\tif o.ID == \"test1\" {\r\n\t\t\tfoundOntology1 = true\r\n\t\t}\r\n\t\tif o.ID == \"test2\" {\r\n\t\t\tfoundOntology2 = true\r\n\t\t}\r\n\t}\r\n\r\n\tif !foundOntology1 || !foundOntology2 {\r\n\t\tt.Error(\"ListOntologies did not return all added ontologies\")\r\n\t}\r\n}\r\n\r\nfunc TestConcurrency(t *testing.T) {\r\n\tms := NewMemoryStorage()\r\n\tconcurrentOperations := 1000\r\n\r\n\t// Concurrent additions\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tgo func(id int) {\r\n\t\t\tontology := \u0026models.Ontology{ID: fmt.Sprintf(\"test%d\", id), Name: fmt.Sprintf(\"Test Ontology %d\", id)}\r\n\t\t\tms.AddOntology(ontology)\r\n\t\t}(i)\r\n\t}\r\n\r\n\ttime.Sleep(time.Second) // Give time for goroutines to complete\r\n\r\n\t// Verify all ontologies were added\r\n\tontologies := ms.ListOntologies()\r\n\tif len(ontologies) != concurrentOperations {\r\n\t\tt.Errorf(\"Expected %d ontologies, got %d\", concurrentOperations, len(ontologies))\r\n\t}\r\n\r\n\t// Concurrent reads and updates\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tgo func(id int) {\r\n\t\t\tontologyID := fmt.Sprintf(\"test%d\", id)\r\n\t\t\tms.GetOntology(ontologyID)\r\n\t\t\tupdatedOntology := \u0026models.Ontology{ID: ontologyID, Name: fmt.Sprintf(\"Updated Test Ontology %d\", id)}\r\n\t\t\tms.UpdateOntology(updatedOntology)\r\n\t\t}(i)\r\n\t}\r\n\r\n\ttime.Sleep(time.Second) // Give time for goroutines to complete\r\n\r\n\t// Verify all ontologies were updated\r\n\tfor i := 0; i \u003c concurrentOperations; i++ {\r\n\t\tontology, _ := ms.GetOntology(fmt.Sprintf(\"test%d\", i))\r\n\t\tif ontology.Name != fmt.Sprintf(\"Updated Test Ontology %d\", i) {\r\n\t\t\tt.Errorf(\"Ontology %d was not updated correctly\", i)\r\n\t\t}\r\n\t}\r\n}\r\n",
    "size": 4603,
    "modTime": "2024-10-26T14:49:58.7993994+02:00",
    "path": "internal\\storage\\memory_test.go"
  }
]