[
  {
    "name": "errors.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n)\r\n\r\n// APIError représente une erreur de l'API\r\ntype APIError struct {\r\n\tCode    int    `json:\"code\"`\r\n\tMessage string `json:\"message\"`\r\n}\r\n\r\nfunc (e APIError) Error() string {\r\n\treturn fmt.Sprintf(\"API Error %d: %s\", e.Code, e.Message)\r\n}\r\n\r\n// Constantes pour les codes d'erreur\r\nconst (\r\n\tErrBadRequest          = 400\r\n\tErrNotFound            = 404\r\n\tErrInternalServerError = 500\r\n)\r\n\r\n// Constantes pour les messages d'erreur communs\r\nconst (\r\n\tMsgInvalidInput        = \"Invalid input provided\"\r\n\tMsgResourceNotFound    = \"Requested resource not found\"\r\n\tMsgInternalServerError = \"An internal server error occurred\"\r\n)\r\n\r\n// NewAPIError crée une nouvelle instance de APIError\r\nfunc NewAPIError(code int, message string) APIError {\r\n\treturn APIError{Code: code, Message: message}\r\n}\r\n\r\n// WriteJSONError écrit une réponse d'erreur JSON\r\nfunc WriteJSONError(w http.ResponseWriter, err APIError) {\r\n\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\tw.WriteHeader(err.Code)\r\n\tjson.NewEncoder(w).Encode(err)\r\n}\r\n",
    "size": 1084,
    "modTime": "2024-10-30T22:47:03.7801611+01:00",
    "path": "errors.go"
  },
  {
    "name": "handlers.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strings\"\r\n\t\"time\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\n// Handler encapsule les dépendances nécessaires pour gérer les requêtes API\r\ntype Handler struct {\r\n\tStorage *storage.MemoryStorage\r\n\tLogger  *logger.Logger\r\n\tSearch  *search.SearchEngine\r\n}\r\n\r\n// NewHandler crée une nouvelle instance de Handler avec le stockage, le logger et le moteur de recherche fournis\r\nfunc NewHandler(storage *storage.MemoryStorage, logger *logger.Logger, search *search.SearchEngine) *Handler {\r\n\treturn \u0026Handler{Storage: storage, Logger: logger, Search: search}\r\n}\r\n\r\n// GetOntology récupère une ontologie par son ID\r\nfunc (h *Handler) GetOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting ontology with ID: %s\", id))\r\n\r\n\tontology, err := h.Storage.GetOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting ontology: %v\", err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": MsgResourceNotFound})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology)\r\n}\r\n\r\n// AddOntology ajoute une nouvelle ontologie\r\nfunc (h *Handler) AddOntology(c *gin.Context) {\r\n\tvar ontology models.Ontology\r\n\tif err := c.ShouldBindJSON(\u0026ontology); err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": MsgInvalidInput})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Générer un ID unique\r\n\tontology.ID = fmt.Sprintf(\"onto_%d\", time.Now().UnixNano())\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Adding new ontology: %s with ID: %s\", ontology.Name, ontology.ID))\r\n\r\n\terr := h.Storage.AddOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error adding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusCreated, ontology)\r\n}\r\n\r\n// UpdateOntology met à jour une ontologie existante\r\nfunc (h *Handler) UpdateOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\tvar ontology models.Ontology\r\n\tif err := c.ShouldBindJSON(\u0026ontology); err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding ontology: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": MsgInvalidInput})\r\n\t\treturn\r\n\t}\r\n\r\n\tontology.ID = id\r\n\th.Logger.Info(fmt.Sprintf(\"Updating ontology: %s\", id))\r\n\r\n\terr := h.Storage.UpdateOntology(\u0026ontology)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error updating ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology)\r\n}\r\n\r\n// DeleteOntology supprime une ontologie par son ID\r\nfunc (h *Handler) DeleteOntology(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Deleting ontology: %s\", id))\r\n\r\n\terr := h.Storage.DeleteOntology(id)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error deleting ontology: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": MsgInternalServerError})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.Status(http.StatusNoContent)\r\n}\r\n\r\n// ListOntologies récupère la liste de toutes les ontologies\r\nfunc (h *Handler) ListOntologies(c *gin.Context) {\r\n\th.Logger.Info(\"Listing all ontologies\")\r\n\r\n\tontologies := h.Storage.ListOntologies()\r\n\r\n\t// Créer une structure pour l'affichage\r\n\ttype OntologyInfo struct {\r\n\t\tID           string `json:\"id\"`\r\n\t\tName         string `json:\"name\"`\r\n\t\tElementCount int    `json:\"elementCount\"`\r\n\t\tContextCount int    `json:\"contextCount\"`\r\n\t}\r\n\r\n\tvar ontologyInfos []OntologyInfo\r\n\r\n\tfor _, onto := range ontologies {\r\n\t\tcontextCount := 0\r\n\t\tfor _, elem := range onto.Elements {\r\n\t\t\tcontextCount += len(elem.Contexts)\r\n\t\t}\r\n\r\n\t\tontologyInfos = append(ontologyInfos, OntologyInfo{\r\n\t\t\tID:           onto.ID,\r\n\t\t\tName:         onto.Name,\r\n\t\t\tElementCount: len(onto.Elements),\r\n\t\t\tContextCount: contextCount,\r\n\t\t})\r\n\t}\r\n\r\n\t// Assurez-vous de toujours renvoyer un tableau, même s'il est vide\r\n\tif ontologyInfos == nil {\r\n\t\tontologyInfos = []OntologyInfo{}\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontologyInfos)\r\n}\r\n\r\n// SearchOntologies effectue une recherche dans les ontologies\r\nfunc (h *Handler) SearchOntologies(c *gin.Context) {\r\n\tquery := c.Query(\"q\")\r\n\tfileID := c.Query(\"file_id\") // Ajoutez cette ligne\r\n\tontologyID := c.Query(\"ontology_id\")\r\n\telementType := c.Query(\"type\")\r\n\tcontextSize := 5 // Valeur par défaut, vous pouvez la rendre configurable si nécessaire\r\n\r\n\tif query == \"\" {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Query parameter 'q' is required\"})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Searching ontologies with query: %s, fileID: %s\", query, fileID))\r\n\r\n\tresults, err := h.Search.Search(query, ontologyID, elementType, contextSize, fileID)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error during search: %v\", err))\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"An error occurred during the search\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Log des résultats côté serveur\r\n\th.Logger.Info(fmt.Sprintf(\"Search results: %+v\", results))\r\n\r\n\t// Enrichir les résultats avec les métadonnées\r\n\tenrichedResults := make([]gin.H, len(results))\r\n\tfor i, result := range results {\r\n\t\telement, err := h.Storage.GetElement(result.ElementName)\r\n\t\tif err == nil \u0026\u0026 element != nil {\r\n\t\t\tontology, _ := h.Storage.GetOntology(result.OntologyID)\r\n\t\t\tvar sourceFile string\r\n\t\t\tvar resultFileID string\r\n\t\t\tvar sourceMetadata *models.SourceMetadata\r\n\t\t\tif ontology != nil \u0026\u0026 ontology.Source != nil {\r\n\t\t\t\tsourceMetadata = ontology.Source\r\n\t\t\t\t// Utiliser le fileID de la requête s'il est fourni, sinon chercher dans les contextes\r\n\t\t\t\tif fileID != \"\" {\r\n\t\t\t\t\tif fileInfo, exists := sourceMetadata.Files[fileID]; exists {\r\n\t\t\t\t\t\tresultFileID = fileID\r\n\t\t\t\t\t\tsourceFile = fileInfo.SourceFile\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Logique existante pour trouver le FileID\r\n\t\t\t\t\tfor _, context := range element.Contexts {\r\n\t\t\t\t\t\tif fileInfo, exists := sourceMetadata.Files[context.FileID]; exists {\r\n\t\t\t\t\t\t\tresultFileID = context.FileID\r\n\t\t\t\t\t\t\tsourceFile = fileInfo.SourceFile\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\th.Logger.Info(fmt.Sprintf(\"File info for %s: ID=%s, SourceFile=%s\", result.ElementName, resultFileID, sourceFile))\r\n\t\t\t}\r\n\t\t\tenrichedResults[i] = gin.H{\r\n\t\t\t\t\"ElementName\": result.ElementName,\r\n\t\t\t\t\"ElementType\": result.ElementType,\r\n\t\t\t\t\"Description\": result.Description,\r\n\t\t\t\t\"OntologyID\":  result.OntologyID,\r\n\t\t\t\t\"Contexts\":    element.Contexts,\r\n\t\t\t\t\"FileID\":      resultFileID,\r\n\t\t\t\t\"SourceFile\":  sourceFile,\r\n\t\t\t\t\"SourceMetadata\": gin.H{\r\n\t\t\t\t\t\"ontology_file\":   sourceMetadata.OntologyFile,\r\n\t\t\t\t\t\"processing_date\": sourceMetadata.ProcessingDate,\r\n\t\t\t\t\t\"files\":           sourceMetadata.Files,\r\n\t\t\t\t},\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tc.JSON(http.StatusOK, enrichedResults)\r\n}\r\n\r\n// ElementDetailsHandler récupère les détails d'un élément spécifique\r\nfunc (h *Handler) ElementDetailsHandler(c *gin.Context) {\r\n\telementName := c.Param(\"element_id\")\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting details for element: %s\", elementName))\r\n\r\n\telement, err := h.Storage.GetElement(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting element details: %v\", err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": MsgResourceNotFound})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Si les contextes sont nuls, essayez de les récupérer séparément\r\n\tif element.Contexts == nil {\r\n\t\tcontexts, err := h.Storage.GetElementContexts(elementName)\r\n\t\tif err == nil {\r\n\t\t\telement.Contexts = contexts\r\n\t\t}\r\n\t}\r\n\tc.JSON(http.StatusOK, element)\r\n}\r\n\r\nfunc (h *Handler) LoadOntology(c *gin.Context) {\r\n\t// Fichier d'ontologie principal\r\n\tontologyFile, err := c.FormFile(\"ontologyFile\")\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No ontology file uploaded\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Fichier de métadonnées (obligatoire)\r\n\tmetadataFile, err := c.FormFile(\"metadataFile\")\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No metadata file uploaded\"})\r\n\t\treturn\r\n\t}\r\n\r\n\t// Fichier de contexte (optionnel)\r\n\tvar contextTempFile string\r\n\tcontextFile, err := c.FormFile(\"contextFile\")\r\n\r\n\t// Sauvegarder temporairement les fichiers\r\n\tontologyTempFile := filepath.Join(os.TempDir(), ontologyFile.Filename)\r\n\tif err := c.SaveUploadedFile(ontologyFile, ontologyTempFile); err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save ontology file\"})\r\n\t\treturn\r\n\t}\r\n\tdefer os.Remove(ontologyTempFile)\r\n\r\n\tmetadataTempFile := filepath.Join(os.TempDir(), metadataFile.Filename)\r\n\tif err := c.SaveUploadedFile(metadataFile, metadataTempFile); err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save metadata file\"})\r\n\t\treturn\r\n\t}\r\n\tdefer os.Remove(metadataTempFile)\r\n\r\n\tif contextFile != nil {\r\n\t\tcontextTempFile = filepath.Join(os.TempDir(), contextFile.Filename)\r\n\t\tif err := c.SaveUploadedFile(contextFile, contextTempFile); err != nil {\r\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to save context file\"})\r\n\t\t\treturn\r\n\t\t}\r\n\t\tdefer os.Remove(contextTempFile)\r\n\t}\r\n\r\n\t// Charger l'ontologie avec les métadonnées\r\n\terr = h.Storage.LoadOntologyFromFile(ontologyTempFile, contextTempFile, metadataTempFile)\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": fmt.Sprintf(\"Failed to load ontology: %v\", err)})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, gin.H{\"message\": \"Ontology loaded successfully\"})\r\n}\r\n\r\n// GetElementRelations récupère les relations d'un élément spécifique\r\nfunc (h *Handler) GetElementRelations(c *gin.Context) {\r\n\th.Logger.Info(\"GetElementRelations endpoint called\")\r\n\r\n\t// Décoder le nom de l'élément depuis l'URL\r\n\tencodedElementName := c.Param(\"element_name\")\r\n\telementName, err := url.QueryUnescape(encodedElementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error decoding element name: %v\", err))\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid element name\"})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Getting relations for element: %s\", elementName))\r\n\r\n\trelations, err := h.Storage.GetElementRelations(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting element relations: %v\", err))\r\n\t\t// Retourner un tableau vide avec status 200 si aucune relation n'est trouvée\r\n\t\tc.JSON(http.StatusOK, []models.Relation{})\r\n\t\treturn\r\n\t}\r\n\r\n\th.Logger.Info(fmt.Sprintf(\"Found %d relations for element: %s\", len(relations), elementName))\r\n\tc.JSON(http.StatusOK, relations)\r\n}\r\n\r\nfunc (h *Handler) GetElementContexts(c *gin.Context) {\r\n\telementName := c.Param(\"element_name\")\r\n\tcontexts, err := h.Storage.GetElementContexts(elementName)\r\n\tif err != nil {\r\n\t\th.Logger.Error(fmt.Sprintf(\"Error getting contexts for element %s: %v\", elementName, err))\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Element not found\"})\r\n\t\treturn\r\n\t}\r\n\tc.JSON(http.StatusOK, contexts)\r\n}\r\n\r\n// Ajouter un endpoint pour récupérer les métadonnées d'une ontologie\r\nfunc (h *Handler) GetOntologyMetadata(c *gin.Context) {\r\n\tid := c.Param(\"id\")\r\n\r\n\tontology, err := h.Storage.GetOntology(id)\r\n\tif err != nil {\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Ontology not found\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tif ontology.Source == nil {\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"No metadata available for this ontology\"})\r\n\t\treturn\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, ontology.Source)\r\n}\r\n\r\n// ViewSourceFile gère l'affichage des fichiers source\r\nfunc (h *Handler) ViewSourceFile(c *gin.Context) {\r\n\t// Récupérer le chemin du fichier depuis les query params\r\n\tfilePath := c.Query(\"path\")\r\n\tif filePath == \"\" {\r\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"No file path provided\"}) // gin.H pour format JSON cohérent\r\n\t\treturn\r\n\t}\r\n\r\n\t// Vérifier que le fichier existe\r\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\r\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"File not found\"}) // gin.H pour format JSON cohérent\r\n\t\treturn\r\n\t}\r\n\r\n\t// Déterminer le type MIME\r\n\text := strings.ToLower(filepath.Ext(filePath))\r\n\tvar contentType string\r\n\tswitch ext {\r\n\tcase \".pdf\":\r\n\t\tcontentType = \"application/pdf\"\r\n\tcase \".md\":\r\n\t\tcontentType = \"text/markdown\"\r\n\tcase \".txt\":\r\n\t\tcontentType = \"text/plain\"\r\n\tcase \".html\":\r\n\t\tcontentType = \"text/html\"\r\n\tdefault:\r\n\t\tcontentType = \"application/octet-stream\"\r\n\t}\r\n\r\n\t// Pour les fichiers markdown, convertir en HTML si nécessaire\r\n\tif ext == \".md\" {\r\n\t\tfile, err := os.ReadFile(filePath)\r\n\t\tif err != nil {\r\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to read file\"})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Si vous voulez ajouter une conversion Markdown vers HTML ici\r\n\t\t// Vous pouvez utiliser une bibliothèque comme blackfriday\r\n\r\n\t\tc.Header(\"Content-Type\", \"text/html\")\r\n\t\tc.Header(\"Content-Disposition\", \"inline; filename=\"+filepath.Base(filePath))\r\n\t\tc.String(http.StatusOK, `\r\n            \u003c!DOCTYPE html\u003e\r\n            \u003chtml\u003e\r\n            \u003chead\u003e\r\n                \u003cmeta charset=\"UTF-8\"\u003e\r\n                \u003cstyle\u003e\r\n                    body { \r\n                        font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\r\n                        line-height: 1.6;\r\n                        max-width: 800px;\r\n                        margin: 0 auto;\r\n                        padding: 20px;\r\n                    }\r\n                    pre {\r\n                        background: #f5f5f5;\r\n                        padding: 15px;\r\n                        border-radius: 5px;\r\n                    }\r\n                \u003c/style\u003e\r\n            \u003c/head\u003e\r\n            \u003cbody\u003e\r\n                \u003cpre\u003e%s\u003c/pre\u003e\r\n            \u003c/body\u003e\r\n            \u003c/html\u003e\r\n        `, string(file))\r\n\t\treturn\r\n\t}\r\n\r\n\t// Pour tous les autres types de fichiers\r\n\tc.Header(\"Content-Type\", contentType)\r\n\tc.Header(\"Content-Disposition\", \"inline; filename=\"+filepath.Base(filePath))\r\n\tc.File(filePath)\r\n}\r\n\r\n// GetOntologyFiles récupère la liste des fichiers de toutes les ontologies\r\nfunc (h *Handler) GetOntologyFiles(c *gin.Context) {\r\n\th.Logger.Info(\"Getting list of ontology files\")\r\n\r\n\tontologies := h.Storage.ListOntologies()\r\n\tfileList := make(map[string]string)\r\n\r\n\tfor _, onto := range ontologies {\r\n\t\tif onto.Source != nil {\r\n\t\t\tfor fileID, fileInfo := range onto.Source.Files {\r\n\t\t\t\tfileList[fileID] = fileInfo.SourceFile\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tc.JSON(http.StatusOK, fileList)\r\n}\r\n",
    "size": 14449,
    "modTime": "2024-11-18T12:56:13.1476629+01:00",
    "path": "handlers.go"
  },
  {
    "name": "handlers_test.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"net/http\"\r\n\t\"net/http/httptest\"\r\n\t\"net/url\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/models\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc setupTestHandler() (*Handler, *gin.Engine) {\r\n\tstorage := storage.NewMemoryStorage()\r\n\tlogger, _ := logger.NewLogger(logger.INFO, \"test_logs\")\r\n\tsearchEngine := search.NewSearchEngine(storage, logger)\r\n\thandler := NewHandler(storage, logger, searchEngine)\r\n\r\n\tgin.SetMode(gin.TestMode)\r\n\trouter := gin.New()\r\n\treturn handler, router\r\n}\r\n\r\nfunc TestGetOntology(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Add a test ontology\r\n\ttestOntology := \u0026models.Ontology{ID: \"test1\", Name: \"Test Ontology\"}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\t// Test successful retrieval\r\n\trouter.GET(\"/ontologies/:id\", h.GetOntology)\r\n\treq, _ := http.NewRequest(\"GET\", \"/ontologies/test1\", nil)\r\n\tw := httptest.NewRecorder()\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedOntology)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedOntology.ID != testOntology.ID {\r\n\t\tt.Errorf(\"Expected ontology ID %s, got %s\", testOntology.ID, returnedOntology.ID)\r\n\t}\r\n\r\n\t// Test non-existent ontology\r\n\treq, _ = http.NewRequest(\"GET\", \"/ontologies/nonexistent\", nil)\r\n\tw = httptest.NewRecorder()\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusNotFound {\r\n\t\tt.Errorf(\"Expected status 404, got %d\", w.Code)\r\n\t}\r\n}\r\n\r\nfunc TestAddOntology(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\trouter.POST(\"/ontologies\", h.AddOntology)\r\n\r\n\tnewOntology := models.Ontology{Name: \"New Test Ontology\"}\r\n\tbody, _ := json.Marshal(newOntology)\r\n\treq, _ := http.NewRequest(\"POST\", \"/ontologies\", bytes.NewBuffer(body))\r\n\treq.Header.Set(\"Content-Type\", \"application/json\")\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusCreated {\r\n\t\tt.Errorf(\"Expected status 201, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedOntology models.Ontology\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedOntology)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedOntology.Name != newOntology.Name {\r\n\t\tt.Errorf(\"Expected ontology name %s, got %s\", newOntology.Name, returnedOntology.Name)\r\n\t}\r\n}\r\n\r\nfunc TestSearchOntologies(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\trouter.GET(\"/search\", h.SearchOntologies)\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/search?q=Test\", nil)\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar results []search.SearchResult\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026results)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\r\n\t// Add more specific assertions based on your expected search results\r\n}\r\n\r\nfunc TestElementDetailsHandler(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Add a test ontology with an element\r\n\ttestElement := \u0026models.OntologyElement{\r\n\t\tName:        \"Test Element\",\r\n\t\tType:        \"TestType\",\r\n\t\tDescription: \"This is a test element\",\r\n\t}\r\n\ttestOntology := \u0026models.Ontology{\r\n\t\tID:       \"test1\",\r\n\t\tName:     \"Test Ontology\",\r\n\t\tElements: []*models.OntologyElement{testElement},\r\n\t}\r\n\th.Storage.AddOntology(testOntology)\r\n\r\n\trouter.GET(\"/elements/:element_id\", h.ElementDetailsHandler)\r\n\r\n\treq, _ := http.NewRequest(\"GET\", \"/elements/Test Element\", nil)\r\n\tw := httptest.NewRecorder()\r\n\r\n\trouter.ServeHTTP(w, req)\r\n\r\n\tif w.Code != http.StatusOK {\r\n\t\tt.Errorf(\"Expected status 200, got %d\", w.Code)\r\n\t}\r\n\r\n\tvar returnedElement models.OntologyElement\r\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026returnedElement)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Failed to unmarshal response: %v\", err)\r\n\t}\r\n\tif returnedElement.Name != \"Test Element\" {\r\n\t\tt.Errorf(\"Expected element name 'Test Element', got '%s'\", returnedElement.Name)\r\n\t}\r\n}\r\n\r\n// Ajouter après les tests existants...\r\n\r\nfunc TestViewSourceFile(t *testing.T) {\r\n\th, router := setupTestHandler()\r\n\r\n\t// Configurer la route pour le test\r\n\trouter.GET(\"/view-source\", h.ViewSourceFile)\r\n\r\n\t// Créer quelques fichiers de test temporaires\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// Fichier texte\r\n\ttxtContent := \"Test content\"\r\n\ttxtPath := filepath.Join(tmpDir, \"test.txt\")\r\n\tif err := os.WriteFile(txtPath, []byte(txtContent), 0644); err != nil {\r\n\t\tt.Fatalf(\"Failed to create test text file: %v\", err)\r\n\t}\r\n\r\n\t// Fichier Markdown\r\n\tmdContent := \"# Test Title\\nTest content\"\r\n\tmdPath := filepath.Join(tmpDir, \"test.md\")\r\n\tif err := os.WriteFile(mdPath, []byte(mdContent), 0644); err != nil {\r\n\t\tt.Fatalf(\"Failed to create test markdown file: %v\", err)\r\n\t}\r\n\r\n\ttests := []struct {\r\n\t\tname         string\r\n\t\tpath         string\r\n\t\texpectedCode int\r\n\t\texpectedType string\r\n\t\texpectedBody map[string]string // Changé pour correspondre à gin.H\r\n\t}{\r\n\t\t{\r\n\t\t\tname:         \"View Text File\",\r\n\t\t\tpath:         txtPath,\r\n\t\t\texpectedCode: http.StatusOK,\r\n\t\t\texpectedType: \"text/plain\",\r\n\t\t\texpectedBody: nil, // pas de body JSON pour les fichiers\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:         \"View Markdown File\",\r\n\t\t\tpath:         mdPath,\r\n\t\t\texpectedCode: http.StatusOK,\r\n\t\t\texpectedType: \"text/html\",\r\n\t\t\texpectedBody: nil, // pas de body JSON pour les fichiers\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:         \"File Not Found\",\r\n\t\t\tpath:         filepath.Join(tmpDir, \"nonexistent.txt\"),\r\n\t\t\texpectedCode: http.StatusNotFound,\r\n\t\t\texpectedType: \"application/json\",\r\n\t\t\texpectedBody: map[string]string{\"error\": \"File not found\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:         \"No Path Provided\",\r\n\t\t\tpath:         \"\",\r\n\t\t\texpectedCode: http.StatusBadRequest,\r\n\t\t\texpectedType: \"application/json\",\r\n\t\t\texpectedBody: map[string]string{\"error\": \"No file path provided\"},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\t// Construire la requête\r\n\t\t\turlPath := \"/view-source\"\r\n\t\t\tif tt.path != \"\" {\r\n\t\t\t\turlPath = fmt.Sprintf(\"/view-source?path=%s\", url.QueryEscape(tt.path)) // Correction ici\r\n\t\t\t}\r\n\r\n\t\t\treq, _ := http.NewRequest(\"GET\", urlPath, nil)\r\n\t\t\tw := httptest.NewRecorder()\r\n\r\n\t\t\trouter.ServeHTTP(w, req)\r\n\r\n\t\t\t// Vérifier le code de statut\r\n\t\t\tif w.Code != tt.expectedCode {\r\n\t\t\t\tt.Errorf(\"Expected status %d, got %d\", tt.expectedCode, w.Code)\r\n\t\t\t}\r\n\r\n\t\t\t// Vérifier le type de contenu\r\n\t\t\tcontentType := w.Header().Get(\"Content-Type\")\r\n\t\t\tif !strings.Contains(contentType, tt.expectedType) {\r\n\t\t\t\tt.Errorf(\"Expected content type %s, got %s\", tt.expectedType, contentType)\r\n\t\t\t}\r\n\r\n\t\t\t// Vérifier le contenu selon le type de réponse\r\n\t\t\tswitch tt.expectedType {\r\n\t\t\tcase \"application/json\":\r\n\t\t\t\tvar response map[string]string\r\n\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), \u0026response); err != nil {\r\n\t\t\t\t\tt.Fatalf(\"Failed to unmarshal error response: %v\", err)\r\n\t\t\t\t}\r\n\t\t\t\tif response[\"error\"] != tt.expectedBody[\"error\"] {\r\n\t\t\t\t\tt.Errorf(\"Expected error message %v, got %v\", tt.expectedBody[\"error\"], response[\"error\"])\r\n\t\t\t\t}\r\n\t\t\tcase \"text/html\":\r\n\t\t\t\t// Pour le markdown, vérifier que le contenu HTML est non vide\r\n\t\t\t\tif w.Body.Len() == 0 {\r\n\t\t\t\t\tt.Error(\"Expected non-empty HTML content\")\r\n\t\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t// Pour les autres types, vérifier que le contenu n'est pas vide\r\n\t\t\t\tif w.Body.Len() == 0 {\r\n\t\t\t\t\tt.Error(\"Expected non-empty content\")\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Vérifier l'en-tête Content-Disposition pour les fichiers\r\n\t\t\tif tt.expectedCode == http.StatusOK {\r\n\t\t\t\tcontentDisposition := w.Header().Get(\"Content-Disposition\")\r\n\t\t\t\texpectedFilename := filepath.Base(tt.path)\r\n\t\t\t\texpected := fmt.Sprintf(\"inline; filename=%s\", expectedFilename)\r\n\t\t\t\tif contentDisposition != expected {\r\n\t\t\t\t\tt.Errorf(\"Expected Content-Disposition %s, got %s\", expected, contentDisposition)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n",
    "size": 8088,
    "modTime": "2024-10-30T22:47:03.7831628+01:00",
    "path": "handlers_test.go"
  },
  {
    "name": "router.go",
    "content": "package api\r\n\r\nimport (\r\n\t\"github.com/chrlesur/ontology-server/internal/logger\"\r\n\t\"github.com/chrlesur/ontology-server/internal/search\"\r\n\t\"github.com/chrlesur/ontology-server/internal/storage\"\r\n\t\"github.com/gin-gonic/gin\"\r\n)\r\n\r\nfunc SetupRoutes(router *gin.RouterGroup, storage *storage.MemoryStorage, logger *logger.Logger) {\r\n\tsearchEngine := search.NewSearchEngine(storage, logger)\r\n\thandler := NewHandler(storage, logger, searchEngine)\r\n\r\n\trouter.GET(\"/ontologies\", handler.ListOntologies)\r\n\trouter.POST(\"/ontologies\", handler.AddOntology)\r\n\trouter.GET(\"/ontologies/:id\", handler.GetOntology)\r\n\trouter.PUT(\"/ontologies/:id\", handler.UpdateOntology)\r\n\trouter.DELETE(\"/ontologies/:id\", handler.DeleteOntology)\r\n\trouter.POST(\"/ontologies/load\", handler.LoadOntology)\r\n\trouter.GET(\"/ontologies/files\", handler.GetOntologyFiles)\r\n\trouter.GET(\"/ontologies/:id/metadata\", handler.GetOntologyMetadata)\r\n\r\n\trouter.GET(\"/search\", handler.SearchOntologies)\r\n\r\n\trouter.GET(\"/elements/details/:element_id\", handler.ElementDetailsHandler)\r\n\trouter.GET(\"/elements/relations/:element_name\", handler.GetElementRelations)\r\n\r\n\trouter.GET(\"/view-source\", handler.ViewSourceFile)\r\n\r\n}\r\n",
    "size": 1169,
    "modTime": "2024-11-18T12:10:23.9418905+01:00",
    "path": "router.go"
  }
]